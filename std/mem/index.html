<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>std::mem - Alumina Docs</title>
<link rel="stylesheet" href="/static/styles.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content=" Working with memory (allocation, slices, copying, ...)" />
<link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png" />
<link rel="manifest" href="/static/manifest.json" />
<link rel="mask-icon" href="/static/safari-pinned-tab.svg" color="#5bbad5" />
<link rel="shortcut icon" href="/static/favicon.ico" />
<link rel="canonical" href="https://docs.alumina-lang.net/std/mem/" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta name="msapplication-config" content="/static/browserconfig.xml" />
<meta name="description" content="Documentation for the Alumina standard library" />
<script src="/static/site.js"></script>
<script src="/search_index.js" async></script>
<link href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@400;500&family=Source+Code+Pro:wght@400;600&family=Source+Serif+4:opsz,wght@8..60,400;8..60,700&display=swap" rel="stylesheet">
</head>
<body>
<nav>
<a href="/">
<img width="100px" height="100px" class="logo" src="/static/logo.svg" alt="Alumina Docs">
</a>
<h1><a class="breadcrumbs" href="/std/">std</a>::<a class="breadcrumbs" href="/std/mem/">mem</a></h1>
</h1>
<h2>Protocols</h2>
<ul>
<li>
<a href="/std/mem/Freeable.html">Freeable</a>
</li>
<li>
<a href="/std/mem/Movable.html">Movable</a>
</li>
<li>
<a href="/std/mem/Clonable.html">Clonable</a>
</li>
<li>
<a href="/std/mem/Borrowable.html">Borrowable</a>
</li>
<li>
<a href="/std/mem/BorrowableMut.html">BorrowableMut</a>
</li>
<li>
<a href="/std/mem/AsSlice.html">AsSlice</a>
</li>
<li>
<a href="/std/mem/AsSliceMut.html">AsSliceMut</a>
</li>
</ul>
<h2>Structs</h2>
<ul>
<li>
<a href="/std/mem/slice.html">slice</a>
</li>
<li>
<a href="/std/mem/SliceIterator.html">SliceIterator</a>
</li>
<li>
<a href="/std/mem/SliceRefIterator.html">SliceRefIterator</a>
</li>
</ul>
<h2>Functions</h2>
<ul>
<li>
<a href="/std/mem/#item.alloc">alloc</a>
</li>
<li>
<a href="/std/mem/#item.alloc_zeroed">alloc_zeroed</a>
</li>
<li>
<a href="/std/mem/#item.stack_alloc">stack_alloc</a>
</li>
<li>
<a href="/std/mem/#item.free">free</a>
</li>
<li>
<a href="/std/mem/#item.size_of">size_of</a>
</li>
<li>
<a href="/std/mem/#item.align_of">align_of</a>
</li>
<li>
<a href="/std/mem/#item.swap">swap</a>
</li>
<li>
<a href="/std/mem/#item.replace">replace</a>
</li>
<li>
<a href="/std/mem/#item.zeroed">zeroed</a>
</li>
<li>
<a href="/std/mem/#item.uninitialized">uninitialized</a>
</li>
<li>
<a href="/std/mem/#item.copy_nonoverlapping">copy_nonoverlapping</a>
</li>
<li>
<a href="/std/mem/#item.copy">copy</a>
</li>
<li>
<a href="/std/mem/#item.read_volatile">read_volatile</a>
</li>
<li>
<a href="/std/mem/#item.write_volatile">write_volatile</a>
</li>
<li>
<a href="/std/mem/#item.read_unaligned">read_unaligned</a>
</li>
<li>
<a href="/std/mem/#item.write_unaligned">write_unaligned</a>
</li>
<li>
<a href="/std/mem/#item.dangling">dangling</a>
</li>
</ul>
</nav>
<div class="main-container">
<div id="search-container">
<a class="mobile-only" href="/">
<img width="40px" height="40px" class="logo" src="/static/logo.svg" alt="Alumina Docs">
</a>
<input id="search-input" class="search-input" autocomplete="off" spellcheck="false" placeholder="Search the documentation..." type="search"></input>
</div>
<div id="search-results"></div>
<main id="main-content">
<div class="main-title"><h1>Module <a class="breadcrumbs" href="/std/">std</a>::<a class="breadcrumbs" href="/std/mem/">mem</a></h1>
</h1>
</div>
<p>
Working with memory (allocation, slices, copying, ...)
</p><p>
The main feature of this module is the <a class="path-link" href="/std/mem/slice.html">slice</a> type, which is a pointer to a region
of memory. <code class="language-alumina">&amp;[T]</code> is a slice (read-only) of <code class="language-alumina">T</code>, and <code class="language-alumina">&amp;mut [T]</code> is a mutable slice.
</p><p>
</p>
<h2 id="Protocol">Protocols</h2>
<div class="item-short-table">
<div class="row" id="item.Freeable">
<div class="cell-name">
<a href="/std/mem/Freeable.html">Freeable</a>
</div>
<div class="cell-doc">Types that can be "freed".
</div>
</div>
<div class="row" id="item.Movable">
<div class="cell-name">
<a href="/std/mem/Movable.html">Movable</a>
</div>
<div class="cell-doc">Types that implement move semantics
</div>
</div>
<div class="row" id="item.Clonable">
<div class="cell-name">
<a href="/std/mem/Clonable.html">Clonable</a>
</div>
<div class="cell-doc">Types that be copied non-trivially (usually types containing a heap allocation).
</div>
</div>
<div class="row" id="item.Borrowable">
<div class="cell-name">
<a href="/std/mem/Borrowable.html">Borrowable</a>
</div>
<div class="cell-doc"></div>
</div>
<div class="row" id="item.BorrowableMut">
<div class="cell-name">
<a href="/std/mem/BorrowableMut.html">BorrowableMut</a>
</div>
<div class="cell-doc"></div>
</div>
<div class="row" id="item.AsSlice">
<div class="cell-name">
<a href="/std/mem/AsSlice.html">AsSlice</a>
</div>
<div class="cell-doc">Types that can be viewed as const slices
</div>
</div>
<div class="row" id="item.AsSliceMut">
<div class="cell-name">
<a href="/std/mem/AsSliceMut.html">AsSliceMut</a>
</div>
<div class="cell-doc">Types that can be viewed as mutable slices
</div>
</div>
</div>
<h2 id="Struct">Structs</h2>
<div class="item-short-table">
<div class="row" id="item.slice">
<div class="cell-name">
<a href="/std/mem/slice.html">slice</a>
</div>
<div class="cell-doc">Fat pointers to a contiguous region of memory.
</div>
</div>
<div class="row" id="item.SliceIterator">
<div class="cell-name">
<a href="/std/mem/SliceIterator.html">SliceIterator</a>
</div>
<div class="cell-doc">Iterator over elements of a slice
</div>
</div>
<div class="row" id="item.SliceRefIterator">
<div class="cell-name">
<a href="/std/mem/SliceRefIterator.html">SliceRefIterator</a>
</div>
<div class="cell-doc">Iterator over pointers to elements of a slice
</div>
</div>
</div>
<h2 id="Function">Functions</h2>
<ul>
<li>
<div class="signature" id="item.alloc">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">alloc</span>&lt;T&gt;() -> &amp;<span class="keyword">mut</span> T</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L778-L786"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Allocates a single object on the heap using a default allocator (<code class="language-alumina">malloc</code>)
</p><p>
The value is not initialized. See <a class="path-link" href="/std/mem/#item.alloc_zeroed">alloc_zeroed</a> which returns zeroed memory.
</p><p>
See also a <a class="" href="/std/mem/slice.html#item.alloc">the matching method</a> for allocating a slice.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::{alloc, free};

let x: &amp;mut i32 = alloc();
*x = 42;
assert_eq!(*x, 42);
free(x);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3a%7balloc%2c%20free%7d%3b%0a%20%20%20%20%0a%20%20%20%20let%20x%3a%20%26mut%20i32%20%3d%20alloc%28%29%3b%0a%20%20%20%20%2ax%20%3d%2042%3b%0a%20%20%20%20assert%5feq%21%28%2ax%2c%2042%29%3b%0a%20%20%20%20free%28x%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.alloc_zeroed">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">alloc_zeroed</span>&lt;T&gt;() -> &amp;<span class="keyword">mut</span> T</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L802-L812"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Allocates a single object on the heap using a default allocator (<code class="language-alumina">malloc</code>)
</p><p>
The value is zero-initialized.
</p><p>
See also a <a class="" href="/std/mem/slice.html#item.alloc_zeroed">the matching method</a> for allocating a slice.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::{alloc_zeroed, free};

let x: &amp;mut i32 = alloc_zeroed();
assert_eq!(*x, 0);
free(x);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3a%7balloc%5fzeroed%2c%20free%7d%3b%0a%20%20%20%20%0a%20%20%20%20let%20x%3a%20%26mut%20i32%20%3d%20alloc%5fzeroed%28%29%3b%0a%20%20%20%20assert%5feq%21%28%2ax%2c%200%29%3b%0a%20%20%20%20free%28x%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.stack_alloc">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">stack_alloc</span>&lt;T&gt;(len: <a href="/std/builtins/usize.html"><span class="identifier-type">usize</span></a>) -> &amp;<span class="keyword">mut</span> [T]</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L839-L852"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Allocates an array of specified size on the stack.
</p><p>
The values are not initialized. The array is allocated on the stack, so it will be
deallocated when the function returns.
</p><p>
Care must be taken to ensure that the array is not accessed after the function returns.
Additionally, there is no protection against stack overflow, so allocated arrays should
not be too large.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::stack_alloc;

let hw = "Hello, World!";
let s = stack_alloc::&lt;u8&gt;(hw.len());

hw.copy_to(&amp;s[0]);
assert_eq!(hw, s);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3astack%5falloc%3b%0a%20%20%20%20%0a%20%20%20%20let%20hw%20%3d%20%22Hello%2c%20World%21%22%3b%0a%20%20%20%20let%20s%20%3d%20stack%5falloc%3a%3a%3cu8%3e%28hw%2elen%28%29%29%3b%0a%20%20%20%20%0a%20%20%20%20hw%2ecopy%5fto%28%26s%5b0%5d%29%3b%0a%20%20%20%20assert%5feq%21%28hw%2c%20s%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
<pre class="with-playground-link panics"><code class="language-alumina">use std::mem::stack_alloc;

stack_alloc::&lt;i32&gt;(10000000); // stack overflow, probably
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3astack%5falloc%3b%0a%20%20%20%20%0a%20%20%20%20stack%5falloc%3a%3a%3ci32%3e%2810000000%29%3b%20%2f%2f%20stack%20overflow%2c%20probably%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.free">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">free</span>&lt;T&gt;(a: &amp;<span class="keyword">mut</span> T)</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L874-L882"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Frees a heap-allocated object
</p><p>
The pointer must be allocated with the default allocator (<code class="language-alumina">malloc</code>).
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">struct Box&lt;T&gt; { ptr: &amp;mut T }

impl Box&lt;T&gt; {
    fn new(value: T) -&gt; Box&lt;T&gt; {
        let ptr = std::mem::alloc::&lt;T&gt;();
        *ptr = value;
        Box { ptr: ptr }
    }

    fn free(self: &amp;mut Box&lt;T&gt;) {
        std::mem::free(self.ptr);
    }
}
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20struct%20Box%3cT%3e%20%7b%20ptr%3a%20%26mut%20T%20%7d%0a%20%20%20%20%0a%20%20%20%20impl%20Box%3cT%3e%20%7b%0a%20%20%20%20%20%20%20%20fn%20new%28value%3a%20T%29%20%2d%3e%20Box%3cT%3e%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3d%20std%3a%3amem%3a%3aalloc%3a%3a%3cT%3e%28%29%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2aptr%20%3d%20value%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20Box%20%7b%20ptr%3a%20ptr%20%7d%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%0a%20%20%20%20%20%20%20%20fn%20free%28self%3a%20%26mut%20Box%3cT%3e%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20std%3a%3amem%3a%3afree%28self%2eptr%29%3b%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.size_of">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">size_of</span>&lt;T&gt;() -> <a href="/std/builtins/usize.html"><span class="identifier-type">usize</span></a></h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L895-L898"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Memory size of for a given type in bytes.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::size_of;

assert_eq!(size_of::&lt;u8&gt;(), 1);
assert_eq!(size_of::&lt;u16&gt;(), 2);
assert_eq!(size_of::&lt;u32&gt;(), 4);
assert_eq!(size_of::&lt;u64&gt;(), 8);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3asize%5fof%3b%0a%20%20%20%20%0a%20%20%20%20assert%5feq%21%28size%5fof%3a%3a%3cu8%3e%28%29%2c%201%29%3b%0a%20%20%20%20assert%5feq%21%28size%5fof%3a%3a%3cu16%3e%28%29%2c%202%29%3b%0a%20%20%20%20assert%5feq%21%28size%5fof%3a%3a%3cu32%3e%28%29%2c%204%29%3b%0a%20%20%20%20assert%5feq%21%28size%5fof%3a%3a%3cu64%3e%28%29%2c%208%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.align_of">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">align_of</span>&lt;T&gt;() -> <a href="/std/builtins/usize.html"><span class="identifier-type">usize</span></a></h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L912-L915"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Minimum alignment for given type in bytes.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::align_of;

// On most platforms
assert_eq!(align_of::&lt;u8&gt;(), 1);
assert_eq!(align_of::&lt;u16&gt;(), 2);
assert_eq!(align_of::&lt;u32&gt;(), 4);
assert_eq!(align_of::&lt;u64&gt;(), 8);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3aalign%5fof%3b%0a%20%20%20%20%0a%20%20%20%20%2f%2f%20On%20most%20platforms%0a%20%20%20%20assert%5feq%21%28align%5fof%3a%3a%3cu8%3e%28%29%2c%201%29%3b%0a%20%20%20%20assert%5feq%21%28align%5fof%3a%3a%3cu16%3e%28%29%2c%202%29%3b%0a%20%20%20%20assert%5feq%21%28align%5fof%3a%3a%3cu32%3e%28%29%2c%204%29%3b%0a%20%20%20%20assert%5feq%21%28align%5fof%3a%3a%3cu64%3e%28%29%2c%208%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.swap">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">swap</span>&lt;T&gt;(a: &amp;<span class="keyword">mut</span> T, b: &amp;<span class="keyword">mut</span> T)</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L931-L935"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Swaps the data in two memory locations.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::swap;

let a = 1;
let b = 2;

swap(&amp;a, &amp;b);

assert_eq!(a, 2);
assert_eq!(b, 1);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3aswap%3b%0a%20%20%20%20%0a%20%20%20%20let%20a%20%3d%201%3b%0a%20%20%20%20let%20b%20%3d%202%3b%0a%20%20%20%20%0a%20%20%20%20swap%28%26a%2c%20%26b%29%3b%0a%20%20%20%20%0a%20%20%20%20assert%5feq%21%28a%2c%202%29%3b%0a%20%20%20%20assert%5feq%21%28b%2c%201%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.replace">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">replace</span>&lt;T&gt;(a: &amp;<span class="keyword">mut</span> T, b: T) -> T</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L950-L953"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Replaces a memory at location <code class="language-alumina">a</code> with value <code class="language-alumina">b</code>.
</p><p>
The existing value is returned.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::replace;

let a = 1;

assert_eq!(a.replace(2), 1);
assert_eq!(a, 2);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3areplace%3b%0a%20%20%20%20%0a%20%20%20%20let%20a%20%3d%201%3b%0a%20%20%20%20%0a%20%20%20%20assert%5feq%21%28a%2ereplace%282%29%2c%201%29%3b%0a%20%20%20%20assert%5feq%21%28a%2c%202%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.zeroed">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">zeroed</span>&lt;T&gt;() -> T</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L968-L971"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Zero-initialized object of a given type.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::zeroed;

struct Foo { a: u8, b: u16 }

let a: Foo = zeroed();

assert_eq!(a.a, 0);
assert_eq!(a.b, 0);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3azeroed%3b%0a%20%20%20%20%0a%20%20%20%20struct%20Foo%20%7b%20a%3a%20u8%2c%20b%3a%20u16%20%7d%0a%20%20%20%20%0a%20%20%20%20let%20a%3a%20Foo%20%3d%20zeroed%28%29%3b%0a%20%20%20%20%0a%20%20%20%20assert%5feq%21%28a%2ea%2c%200%29%3b%0a%20%20%20%20assert%5feq%21%28a%2eb%2c%200%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.uninitialized">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">uninitialized</span>&lt;T&gt;() -> T</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L1001-L1004"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Uninitialized object.
</p><p>
Using the return value is usually undefined behavior.
</p><p>
</p>
<h3> Examples</h3>
<p>
</p><p>
This is probably fine:
</p><p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::uninitialized;

struct MyOption&lt;T&gt; { some: bool, val: T }

let _: MyOption&lt;i32&gt; = MyOption { some: true, val: 2 };
let _: MyOption&lt;i32&gt; = MyOption { some: false, val: uninitialized() };
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3auninitialized%3b%0a%20%20%20%20%0a%20%20%20%20struct%20MyOption%3cT%3e%20%7b%20some%3a%20bool%2c%20val%3a%20T%20%7d%0a%20%20%20%20%0a%20%20%20%20let%20%5f%3a%20MyOption%3ci32%3e%20%3d%20MyOption%20%7b%20some%3a%20true%2c%20val%3a%202%20%7d%3b%0a%20%20%20%20let%20%5f%3a%20MyOption%3ci32%3e%20%3d%20MyOption%20%7b%20some%3a%20false%2c%20val%3a%20uninitialized%28%29%20%7d%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
This is not:
<pre class="with-playground-link panics"><code class="language-alumina">use std::mem::uninitialized;

let val: i32 = uninitialized();
if val &gt; 0 {  // UB!
    println!("positive");
} else {
    println!("negative");
}
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3auninitialized%3b%0a%20%20%20%20%0a%20%20%20%20let%20val%3a%20i32%20%3d%20uninitialized%28%29%3b%0a%20%20%20%20if%20val%20%3e%200%20%7b%20%20%2f%2f%20UB%21%0a%20%20%20%20%20%20%20%20println%21%28%22positive%22%29%3b%0a%20%20%20%20%7d%20else%20%7b%0a%20%20%20%20%20%20%20%20println%21%28%22negative%22%29%3b%0a%20%20%20%20%7d%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.copy_nonoverlapping">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">copy_nonoverlapping</span>&lt;T&gt;(src: &amp;T, dst: &amp;<span class="keyword">mut</span> T, count: <a href="/std/builtins/usize.html"><span class="identifier-type">usize</span></a>)</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L1009-L1019"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Copies a region of memory from <code class="language-alumina">src</code> to <code class="language-alumina">dst</code>.
</p><p>
The memory ranges must not overlap, use <a class="path-link" href="/std/mem/#item.copy">copy</a> if they may be overlapping.
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.copy">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">copy</span>&lt;T&gt;(src: &amp;T, dst: &amp;<span class="keyword">mut</span> T, count: <a href="/std/builtins/usize.html"><span class="identifier-type">usize</span></a>)</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L1024-L1037"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Copies a region of memory from <code class="language-alumina">src</code> to <code class="language-alumina">dst</code>.
</p><p>
The ranges may overlap.
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.read_volatile">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">read_volatile</span>&lt;T&gt;(ptr: &amp;T) -> T</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L1060-L1067"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Performs a volatile read from a memory location.
</p><p>
This is useful in limited situations such as when dealing with signals/interrupts
and is not likely to do what you'd expect in a multi-threaded scenario. Use <a class="path-link" href="/std/sync/Atomic.html">Atomic</a> instead.
</p><p>
When pointed-to type is zero-sized, no read is performed.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::{write_volatile, read_volatile};

static FLAG: i32;

fn signal_handler() {
    FLAG.write_volatile(1);
}

while FLAG.read_volatile() == 0 {
    // wait for something to set the flag
}
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3a%7bwrite%5fvolatile%2c%20read%5fvolatile%7d%3b%0a%20%20%20%20%0a%20%20%20%20static%20FLAG%3a%20i32%3b%0a%20%20%20%20%0a%20%20%20%20fn%20signal%5fhandler%28%29%20%7b%0a%20%20%20%20%20%20%20%20FLAG%2ewrite%5fvolatile%281%29%3b%0a%20%20%20%20%7d%0a%20%20%20%20%0a%20%20%20%20while%20FLAG%2eread%5fvolatile%28%29%20%3d%3d%200%20%7b%0a%20%20%20%20%20%20%20%20%2f%2f%20wait%20for%20something%20to%20set%20the%20flag%0a%20%20%20%20%7d%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.write_volatile">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">write_volatile</span>&lt;T&gt;(ptr: &amp;<span class="keyword">mut</span> T, val: T)</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L1090-L1095"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Performs a volatile write to a memory location.
</p><p>
This is useful in limited situations such as when dealing with signals/interrupts
and is not likely to do what you'd expect in a multi-threaded scenario. Use <a class="path-link" href="/std/sync/Atomic.html">Atomic</a> instead.
</p><p>
When pointed-to type is zero-sized, no write is performed.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::{write_volatile, read_volatile};

static FLAG: i32;

fn signal_handler() {
    FLAG.write_volatile(1);
}

while FLAG.read_volatile() == 0 {
    // wait for something to set the flag
}
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3a%7bwrite%5fvolatile%2c%20read%5fvolatile%7d%3b%0a%20%20%20%20%0a%20%20%20%20static%20FLAG%3a%20i32%3b%0a%20%20%20%20%0a%20%20%20%20fn%20signal%5fhandler%28%29%20%7b%0a%20%20%20%20%20%20%20%20FLAG%2ewrite%5fvolatile%281%29%3b%0a%20%20%20%20%7d%0a%20%20%20%20%0a%20%20%20%20while%20FLAG%2eread%5fvolatile%28%29%20%3d%3d%200%20%7b%0a%20%20%20%20%20%20%20%20%2f%2f%20wait%20for%20something%20to%20set%20the%20flag%0a%20%20%20%20%7d%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.read_unaligned">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">read_unaligned</span>&lt;T&gt;(ptr: &amp;T) -> T</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L1110-L1119"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Performs an unaligned read from a memory location.
</p><p>
When pointed-to type is zero-sized, no read is performed.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::read_unaligned;

let a = [255u8, 1, 0, 0, 0];
let b: u32 = (&amp;a[1] as &amp;u32).read_unaligned();

assert_eq!(b, 1);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3aread%5funaligned%3b%0a%20%20%20%20%0a%20%20%20%20let%20a%20%3d%20%5b255u8%2c%201%2c%200%2c%200%2c%200%5d%3b%0a%20%20%20%20let%20b%3a%20u32%20%3d%20%28%26a%5b1%5d%20as%20%26u32%29%2eread%5funaligned%28%29%3b%0a%20%20%20%20%0a%20%20%20%20assert%5feq%21%28b%2c%201%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.write_unaligned">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">write_unaligned</span>&lt;T&gt;(ptr: &amp;<span class="keyword">mut</span> T, val: T)</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L1135-L1140"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Performs an unaligned write to a memory location.
</p><p>
When pointed-to type is zero-sized, no write is performed.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::write_unaligned;

let a = [0u8, 0, 0, 0, 0];
(&amp;a[1] as &amp;mut u32).write_unaligned(2);


assert_eq!(a, [0, 2, 0, 0, 0]);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3awrite%5funaligned%3b%0a%20%20%20%20%0a%20%20%20%20let%20a%20%3d%20%5b0u8%2c%200%2c%200%2c%200%2c%200%5d%3b%0a%20%20%20%20%28%26a%5b1%5d%20as%20%26mut%20u32%29%2ewrite%5funaligned%282%29%3b%0a%20%20%20%20%0a%20%20%20%20%0a%20%20%20%20assert%5feq%21%28a%2c%20%5b0%2c%202%2c%200%2c%200%2c%200%5d%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
<li>
<div class="signature" id="item.dangling">
<h4>
<span class="keyword">fn</span> <span class="identifier-function">dangling</span>&lt;Ptr&gt;() -> Ptr<div class="protocol-bound">
Ptr: <a href="/std/builtins/Pointer.html"><span class="identifier-type">Pointer</span></a></div>
</h4>
<div class="source-link">
<a href="https://github.com/alumina-lang/alumina/blob/master/sysroot/std/mem.alu#L1173-L1176"/>source</a>
</div>
</div>
<div class="item-doc">
<p>
Returns a dangling non-null pointer.
</p><p>
The pointer is appropriately aligned for the provided type, and is non-null.
</p><p>
This can be used as a sentinel value for e.g. collections of zero-sized types or
empty slices where the pointer is never dereferenced, but <code class="language-alumina">null</code> cannot be used
for whatever reason.
</p><p>
This is the pointer that is returned when taking an address of a value that has a
zero-sized type.
</p><p>
If the pointer points to a sized type, dereferencing it is undefined behavior. If
the pointer points to a zero-sized type, dereferencing it is no-op.
</p><p>
</p>
<h3> Example</h3>
<p>
<pre class="with-playground-link"><code class="language-alumina">use std::mem::dangling;

struct Foo { a: (), b: [u64; 0] }

let foo: Foo;

assert_eq!(&amp;foo.a, dangling::&lt;&amp;mut ()&gt;());
assert_eq!(&amp;foo.b, dangling::&lt;&amp;mut [u64; 0]&gt;());

// Because the types have different alignment. Currently `dangling`
// just returns the alignment of the type (e.g. 1, 2, 4, ...)
// cast to the pointer type.
assert_ne!(&amp;foo.a, &amp;foo.b as &amp;mut void);
</code><a class="playground-link" target="_blank" href="https://play.alumina-lang.net/?q=fn%20main%28%29%20%7b%0a%20%20%20%20use%20std%3a%3amem%3a%3adangling%3b%0a%20%20%20%20%0a%20%20%20%20struct%20Foo%20%7b%20a%3a%20%28%29%2c%20b%3a%20%5bu64%3b%200%5d%20%7d%0a%20%20%20%20%0a%20%20%20%20let%20foo%3a%20Foo%3b%0a%20%20%20%20%0a%20%20%20%20assert%5feq%21%28%26foo%2ea%2c%20dangling%3a%3a%3c%26mut%20%28%29%3e%28%29%29%3b%0a%20%20%20%20assert%5feq%21%28%26foo%2eb%2c%20dangling%3a%3a%3c%26mut%20%5bu64%3b%200%5d%3e%28%29%29%3b%0a%20%20%20%20%0a%20%20%20%20%2f%2f%20Because%20the%20types%20have%20different%20alignment%2e%20Currently%20%60dangling%60%0a%20%20%20%20%2f%2f%20just%20returns%20the%20alignment%20of%20the%20type%20%28e%2eg%2e%201%2c%202%2c%204%2c%20%2e%2e%2e%29%0a%20%20%20%20%2f%2f%20cast%20to%20the%20pointer%20type%2e%0a%20%20%20%20assert%5fne%21%28%26foo%2ea%2c%20%26foo%2eb%20as%20%26mut%20void%29%3b%0a%7d%0a">Run this example</a></pre>
</p><p>
</p>
</div>
</li>
</ul>
</main>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js" integrity="sha512-RDQSW3KoqJMiX0L/UBgwBmH1EmRYp8LBOiLaA8rBHIy+7OGP/7Gxg8vbt8wG4ZYd29P0Fnoq6+LOytCqx3cyoQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="/static/prism-alumina.js"></script>
</body>
</html>
