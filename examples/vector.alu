struct stack<T> {
    data: &mut [T],
    length: usize,
}

impl stack {
    use std::mem::{slice, alloc, copy};

    fn new<T>() -> stack<T> {
        with_capacity(0)
    }

    fn with_capacity<T>(capacity: usize) -> stack<T> {
        stack {
            data: alloc::<T>(capacity),
            length: 0,
        }
    }

    fn reserve<T>(self: &mut stack<T>, new_capacity: usize) {
        if self.data.len < new_capacity {
            self.data = {
                let new_data = alloc::<T>(new_capacity);
                self.data.copy(new_data.ptr);
                self.free();
                new_data
            };
        }
    }

    fn push<T>(self: &mut stack<T>, value: T) {
        use std::math::max;

        if self.length == self.data.len {
            self.reserve(max(self.data.len, 1) * 2);
        }

        self.data[self.length] = value;
        self.length += 1;
    }

    fn pop<T>(self: &mut stack<T>) -> T {
        let value = self.data[self.length - 1];
        self.length -= 1;
        value
    }

    fn empty<T>(self: &stack<T>) -> bool {
        self.length == 0
    }

    fn free<T>(self: &mut stack<T>) {
        use std::mem::free;
        self.data.free();
    }
}

use std::io::print;

fn main() {
    let v: stack<&[u8]> = stack::new();
    defer v.free();
    
    v.push("stack.\n");
    v.push("a ");
    v.push("am ");
    v.push("I ");

    while !v.empty() {
        print!("{}", v.pop());
    }
}
