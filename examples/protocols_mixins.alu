use std::hash::{Hasher, Hashable};
use std::cmp::{Equatable, Comparable};

struct Djb2Hasher {
    hash: u64
}

impl Djb2Hasher {
    fn new() -> Djb2Hasher {
        Djb2Hasher {
            hash: 5381
        }
    }
    fn write(self: &mut Djb2Hasher, val: &[u8]) {
        let i = 0usize;
        while i < val.len {
            self.hash = ((self.hash << 5) + self.hash) + (val[i] as u64);
            i += 1
        }
    }
    fn finish(self: &mut Djb2Hasher) -> u64 { self.hash }
    
    mixin Hasher<Djb2Hasher>;
}

struct HashSet<K: Hashable<K, Djb2Hasher> + Equatable<K>> {}

impl HashSet {
    fn new<K>() -> HashSet<K> {
        HashSet::<K> {}
    }

    fn insert<K>(self: &mut HashSet<K>, key: K) {
        let hasher = Djb2Hasher::new();
        key.hash(&hasher);

        println!("inserting key with hash {}", hasher.finish());
    }
}

fn print_slice<T>(arr: &[T]) {
    print!("[");
    let i = 0usize;
    while i < arr.len {
        if i > 0 {
            print!(", ");
        }
        print!("{}", arr[i]);
        i += 1;
    }
    print!("]\n");
}

fn quicksort<T: Comparable<T>>(arr: &mut [T]) {
    if arr.len <= 1 {
        return;
    }
    
    let p = partition(arr);
    quicksort(arr[..p]);
    quicksort(arr[p+1..]);
}

fn partition<T: Comparable<T>>(arr: &mut [T]) -> usize {
    use std::mem::swap;

    let pivot = arr[arr.len - 1];

    let i = 0usize;
    let j = 0usize;
    while j < arr.len - 1 {
        if arr[j].less_than_or_equal(&pivot) {
            swap(&arr[i], &arr[j]);
            i += 1;
        }
        j += 1;
    }
    swap(&arr[i], &arr[arr.len - 1]);
    i
}

fn main() {
    let f : std::builtins::_u8;
    f = 0;

    let hm = HashSet::new::<u8>();
    hm.insert(12);
    hm.insert(13);
    hm.insert(14);

    let foo: &mut [&[u8]] = &[
        "hello",
        "hel",
        "abracadabra",
        "mordor",
        "zblj",
        "mor"
    ];

    print_slice(foo);
    quicksort(foo);
    print_slice(foo);

    let hm = HashSet::new::<&[u8]>();
    hm.insert(foo[0]);
}
