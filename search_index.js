const index = [["::"," #! Alumina programming language","/"],["libc"," \"FFI\" interfaces to libc.","/libc/"],["std"," Standard library for the Alumina language.","/std/"],["test"," Minimal unit test runner","/test/"],["libc::timespec","","/libc/timespec.html"],["libc::timeval","","/libc/timeval.html"],["libc::in_addr","","/libc/in_addr.html"],["libc::in6_addr","","/libc/in6_addr.html"],["libc::sockaddr","","/libc/sockaddr.html"],["libc::sockaddr_storage","","/libc/sockaddr_storage.html"],["libc::sockaddr_in","","/libc/sockaddr_in.html"],["libc::sockaddr_in6","","/libc/sockaddr_in6.html"],["libc::addrinfo","","/libc/addrinfo.html"],["libc::sockaddr","","/libc/sockaddr.1.html"],["libc::sockaddr_storage","","/libc/sockaddr_storage.1.html"],["libc::sockaddr_in","","/libc/sockaddr_in.1.html"],["libc::sockaddr_in6","","/libc/sockaddr_in6.1.html"],["libc::addrinfo","","/libc/addrinfo.1.html"],["libc::dirent","","/libc/dirent.html"],["libc::dirent64","","/libc/dirent64.html"],["libc::dirent","","/libc/dirent.1.html"],["libc::dirent","","/libc/dirent.2.html"],["libc::dirent64","","/libc/dirent64.1.html"],["libc::DIR","","/libc/DIR.html"],["libc::pollfd","","/libc/pollfd.html"],["libc::t_stat","","/libc/t_stat.html"],["libc::t_stat64","","/libc/t_stat64.html"],["libc::t_stat","","/libc/t_stat.1.html"],["libc::t_stat64","","/libc/t_stat64.1.html"],["libc::t_stat","","/libc/t_stat.2.html"],["libc::t_stat64","","/libc/t_stat64.2.html"],["libc::t_stat","","/libc/t_stat.3.html"],["libc::pthread_attr_t","","/libc/pthread_attr_t.html"],["libc::pthread_mutex_t","","/libc/pthread_mutex_t.html"],["libc::pthread_cond_t","","/libc/pthread_cond_t.html"],["libc::pthread_rwlock_t","","/libc/pthread_rwlock_t.html"],["libc::pthread_attr_t","","/libc/pthread_attr_t.1.html"],["libc::pthread_mutex_t","","/libc/pthread_mutex_t.1.html"],["libc::pthread_cond_t","","/libc/pthread_cond_t.1.html"],["libc::pthread_rwlock_t","","/libc/pthread_rwlock_t.1.html"],["libc::pthread_attr_t","","/libc/pthread_attr_t.2.html"],["libc::pthread_attr_t","","/libc/pthread_attr_t.3.html"],["libc::pthread_attr_t","","/libc/pthread_attr_t.4.html"],["libc::pthread_cond_t","","/libc/pthread_cond_t.2.html"],["libc::pthread_cond_t","","/libc/pthread_cond_t.3.html"],["libc::pthread_mutex_t","","/libc/pthread_mutex_t.2.html"],["libc::pthread_mutex_t","","/libc/pthread_mutex_t.3.html"],["libc::pthread_rwlock_t","","/libc/pthread_rwlock_t.2.html"],["libc::pthread_rwlock_t","","/libc/pthread_rwlock_t.3.html"],["libc::pthread_mutexattr_t","","/libc/pthread_mutexattr_t.1.html"],["libc::pthread_mutexattr_t","","/libc/pthread_mutexattr_t.2.html"],["libc::pthread_condattr_t","","/libc/pthread_condattr_t.1.html"],["libc::pthread_rwlockattr_t","","/libc/pthread_rwlockattr_t.1.html"],["libc::pthread_rwlockattr_t","","/libc/pthread_rwlockattr_t.2.html"],["libc::pthread_attr_t","","/libc/pthread_attr_t.5.html"],["libc::pthread_attr_t","","/libc/pthread_attr_t.6.html"],["libc::pthread_rwlock_t","","/libc/pthread_rwlock_t.4.html"],["libc::pthread_mutex_t","","/libc/pthread_mutex_t.4.html"],["libc::pthread_cond_t","","/libc/pthread_cond_t.4.html"],["libc::pthread_mutexattr_t","","/libc/pthread_mutexattr_t.3.html"],["libc::pthread_condattr_t","","/libc/pthread_condattr_t.2.html"],["libc::pthread_rwlockattr_t","","/libc/pthread_rwlockattr_t.3.html"],["libc::free","","/libc/#item.free"],["libc::memcpy","","/libc/#item.memcpy"],["libc::memset","","/libc/#item.memset"],["libc::memmove","","/libc/#item.memmove"],["libc::memcmp","","/libc/#item.memcmp"],["libc::memchr","","/libc/#item.memchr"],["libc::memmem","","/libc/#item.memmem"],["libc::malloc","","/libc/#item.malloc"],["libc::realloc","","/libc/#item.realloc"],["libc::calloc","","/libc/#item.calloc"],["libc::exit","","/libc/#item.exit"],["libc::abort","","/libc/#item.abort"],["libc::strlen","","/libc/#item.strlen"],["libc::puts","","/libc/#item.puts"],["libc::getrandom","","/libc/#item.getrandom"],["libc::write","","/libc/#item.write"],["libc::read","","/libc/#item.read"],["libc::open","","/libc/#item.open"],["libc::lseek","","/libc/#item.lseek"],["libc::lseek64","","/libc/#item.lseek64"],["libc::close","","/libc/#item.close"],["libc::fsync","","/libc/#item.fsync"],["libc::execv","","/libc/#item.execv"],["libc::execve","","/libc/#item.execve"],["libc::execvp","","/libc/#item.execvp"],["libc::execvpe","","/libc/#item.execvpe"],["libc::kill","","/libc/#item.kill"],["libc::getpid","","/libc/#item.getpid"],["libc::sleep","","/libc/#item.sleep"],["libc::nanosleep","","/libc/#item.nanosleep"],["libc::fork","","/libc/#item.fork"],["libc::pipe","","/libc/#item.pipe"],["libc::pipe2","","/libc/#item.pipe2"],["libc::poll","","/libc/#item.poll"],["libc::dup2","","/libc/#item.dup2"],["libc::waitpid","","/libc/#item.waitpid"],["libc::clock_getres","","/libc/#item.clock_getres"],["libc::clock_gettime","","/libc/#item.clock_gettime"],["libc::gettimeofday","","/libc/#item.gettimeofday"],["libc::signal","","/libc/#item.signal"],["libc::ioctl","","/libc/#item.ioctl"],["libc::ioctl","","/libc/#item.ioctl.1"],["libc::ioctl","","/libc/#item.ioctl.2"],["libc::fcntl","","/libc/#item.fcntl"],["libc::strerror_r","","/libc/#item.strerror_r"],["libc::strerror_r","","/libc/#item.strerror_r.1"],["libc::socket","","/libc/#item.socket"],["libc::connect","","/libc/#item.connect"],["libc::listen","","/libc/#item.listen"],["libc::accept","","/libc/#item.accept"],["libc::accept4","","/libc/#item.accept4"],["libc::setsockopt","","/libc/#item.setsockopt"],["libc::recv","","/libc/#item.recv"],["libc::send","","/libc/#item.send"],["libc::recvfrom","","/libc/#item.recvfrom"],["libc::sendto","","/libc/#item.sendto"],["libc::getaddrinfo","","/libc/#item.getaddrinfo"],["libc::freeaddrinfo","","/libc/#item.freeaddrinfo"],["libc::gai_strerror","","/libc/#item.gai_strerror"],["libc::getpeername","","/libc/#item.getpeername"],["libc::getsockname","","/libc/#item.getsockname"],["libc::bind","","/libc/#item.bind"],["libc::shutdown","","/libc/#item.shutdown"],["libc::opendir","","/libc/#item.opendir"],["libc::opendir","","/libc/#item.opendir.1"],["libc::readdir","","/libc/#item.readdir"],["libc::readdir","","/libc/#item.readdir.1"],["libc::closedir","","/libc/#item.closedir"],["libc::readdir64","","/libc/#item.readdir64"],["libc::realpath","","/libc/#item.realpath"],["libc::getcwd","","/libc/#item.getcwd"],["libc::chdir","","/libc/#item.chdir"],["libc::realpath","","/libc/#item.realpath.1"],["libc::mkdir","","/libc/#item.mkdir"],["libc::stat","","/libc/#item.stat"],["libc::stat","","/libc/#item.stat.1"],["libc::stat64","","/libc/#item.stat64"],["libc::fstat","","/libc/#item.fstat"],["libc::fstat","","/libc/#item.fstat.1"],["libc::fstat64","","/libc/#item.fstat64"],["libc::rmdir","","/libc/#item.rmdir"],["libc::unlink","","/libc/#item.unlink"],["libc::pthread_create","","/libc/#item.pthread_create"],["libc::pthread_join","","/libc/#item.pthread_join"],["libc::pthread_exit","","/libc/#item.pthread_exit"],["libc::pthread_kill","","/libc/#item.pthread_kill"],["libc::pthread_self","","/libc/#item.pthread_self"],["libc::pthread_detach","","/libc/#item.pthread_detach"],["libc::pthread_attr_init","","/libc/#item.pthread_attr_init"],["libc::pthread_attr_destroy","","/libc/#item.pthread_attr_destroy"],["libc::pthread_attr_setstacksize","","/libc/#item.pthread_attr_setstacksize"],["libc::pthread_attr_setdetachstate","","/libc/#item.pthread_attr_setdetachstate"],["libc::pthread_mutex_lock","","/libc/#item.pthread_mutex_lock"],["libc::pthread_mutex_trylock","","/libc/#item.pthread_mutex_trylock"],["libc::pthread_mutex_unlock","","/libc/#item.pthread_mutex_unlock"],["libc::pthread_rwlock_rdlock","","/libc/#item.pthread_rwlock_rdlock"],["libc::pthread_rwlock_tryrdlock","","/libc/#item.pthread_rwlock_tryrdlock"],["libc::pthread_rwlock_wrlock","","/libc/#item.pthread_rwlock_wrlock"],["libc::pthread_rwlock_trywrlock","","/libc/#item.pthread_rwlock_trywrlock"],["libc::pthread_rwlock_unlock","","/libc/#item.pthread_rwlock_unlock"],["libc::pthread_cond_wait","","/libc/#item.pthread_cond_wait"],["libc::pthread_cond_timedwait","","/libc/#item.pthread_cond_timedwait"],["libc::pthread_cond_signal","","/libc/#item.pthread_cond_signal"],["libc::pthread_cond_broadcast","","/libc/#item.pthread_cond_broadcast"],["libc::sched_yield","","/libc/#item.sched_yield"],["libc::pthread_mutex_initializer","","/libc/#item.pthread_mutex_initializer"],["libc::pthread_cond_initializer","","/libc/#item.pthread_cond_initializer"],["libc::pthread_rwlock_initializer","","/libc/#item.pthread_rwlock_initializer"],["libc::syscall","","/libc/#item.syscall"],["libc::acos","","/libc/#item.acos"],["libc::acosf","","/libc/#item.acosf"],["libc::acosh","","/libc/#item.acosh"],["libc::acoshf","","/libc/#item.acoshf"],["libc::asin","","/libc/#item.asin"],["libc::asinf","","/libc/#item.asinf"],["libc::asinh","","/libc/#item.asinh"],["libc::asinhf","","/libc/#item.asinhf"],["libc::atan","","/libc/#item.atan"],["libc::atan2","","/libc/#item.atan2"],["libc::atan2f","","/libc/#item.atan2f"],["libc::atanf","","/libc/#item.atanf"],["libc::atanh","","/libc/#item.atanh"],["libc::atanhf","","/libc/#item.atanhf"],["libc::cbrt","","/libc/#item.cbrt"],["libc::cbrtf","","/libc/#item.cbrtf"],["libc::ceil","","/libc/#item.ceil"],["libc::ceilf","","/libc/#item.ceilf"],["libc::copysign","","/libc/#item.copysign"],["libc::copysignf","","/libc/#item.copysignf"],["libc::cos","","/libc/#item.cos"],["libc::cosf","","/libc/#item.cosf"],["libc::cosh","","/libc/#item.cosh"],["libc::coshf","","/libc/#item.coshf"],["libc::erf","","/libc/#item.erf"],["libc::erfc","","/libc/#item.erfc"],["libc::erff","","/libc/#item.erff"],["libc::erfcf","","/libc/#item.erfcf"],["libc::exp","","/libc/#item.exp"],["libc::expf","","/libc/#item.expf"],["libc::expm1","","/libc/#item.expm1"],["libc::expm1f","","/libc/#item.expm1f"],["libc::fabs","","/libc/#item.fabs"],["libc::fabsf","","/libc/#item.fabsf"],["libc::fdim","","/libc/#item.fdim"],["libc::fdimf","","/libc/#item.fdimf"],["libc::floor","","/libc/#item.floor"],["libc::floorf","","/libc/#item.floorf"],["libc::fma","","/libc/#item.fma"],["libc::fmaf","","/libc/#item.fmaf"],["libc::fmax","","/libc/#item.fmax"],["libc::fmaxf","","/libc/#item.fmaxf"],["libc::fmin","","/libc/#item.fmin"],["libc::fminf","","/libc/#item.fminf"],["libc::fmod","","/libc/#item.fmod"],["libc::fmodf","","/libc/#item.fmodf"],["libc::frexp","","/libc/#item.frexp"],["libc::frexpf","","/libc/#item.frexpf"],["libc::hypot","","/libc/#item.hypot"],["libc::hypotf","","/libc/#item.hypotf"],["libc::ilogb","","/libc/#item.ilogb"],["libc::ilogbf","","/libc/#item.ilogbf"],["libc::ldexp","","/libc/#item.ldexp"],["libc::ldexpf","","/libc/#item.ldexpf"],["libc::lgamma","","/libc/#item.lgamma"],["libc::lgammaf","","/libc/#item.lgammaf"],["libc::log","","/libc/#item.log"],["libc::log10","","/libc/#item.log10"],["libc::log10f","","/libc/#item.log10f"],["libc::log1p","","/libc/#item.log1p"],["libc::log1pf","","/libc/#item.log1pf"],["libc::log2","","/libc/#item.log2"],["libc::log2f","","/libc/#item.log2f"],["libc::logf","","/libc/#item.logf"],["libc::modf","","/libc/#item.modf"],["libc::modff","","/libc/#item.modff"],["libc::nextafter","","/libc/#item.nextafter"],["libc::nextafterf","","/libc/#item.nextafterf"],["libc::pow","","/libc/#item.pow"],["libc::powf","","/libc/#item.powf"],["libc::remainder","","/libc/#item.remainder"],["libc::remainderf","","/libc/#item.remainderf"],["libc::remquo","","/libc/#item.remquo"],["libc::remquof","","/libc/#item.remquof"],["libc::round","","/libc/#item.round"],["libc::roundf","","/libc/#item.roundf"],["libc::scalbn","","/libc/#item.scalbn"],["libc::scalbnf","","/libc/#item.scalbnf"],["libc::sin","","/libc/#item.sin"],["libc::sinf","","/libc/#item.sinf"],["libc::sinh","","/libc/#item.sinh"],["libc::sinhf","","/libc/#item.sinhf"],["libc::sqrt","","/libc/#item.sqrt"],["libc::sqrtf","","/libc/#item.sqrtf"],["libc::tan","","/libc/#item.tan"],["libc::tanf","","/libc/#item.tanf"],["libc::tanh","","/libc/#item.tanh"],["libc::tanhf","","/libc/#item.tanhf"],["libc::tgamma","","/libc/#item.tgamma"],["libc::tgammaf","","/libc/#item.tgammaf"],["libc::trunc","","/libc/#item.trunc"],["libc::truncf","","/libc/#item.truncf"],["libc::c_schar","","/libc/#item.c_schar"],["libc::c_uchar","","/libc/#item.c_uchar"],["libc::c_short","","/libc/#item.c_short"],["libc::c_ushort","","/libc/#item.c_ushort"],["libc::c_int","","/libc/#item.c_int"],["libc::c_uint","","/libc/#item.c_uint"],["libc::c_float","","/libc/#item.c_float"],["libc::c_double","","/libc/#item.c_double"],["libc::c_longlong","","/libc/#item.c_longlong"],["libc::c_ulonglong","","/libc/#item.c_ulonglong"],["libc::intmax_t","","/libc/#item.intmax_t"],["libc::uintmax_t","","/libc/#item.uintmax_t"],["libc::size_t","","/libc/#item.size_t"],["libc::ptrdiff_t","","/libc/#item.ptrdiff_t"],["libc::intptr_t","","/libc/#item.intptr_t"],["libc::uintptr_t","","/libc/#item.uintptr_t"],["libc::ssize_t","","/libc/#item.ssize_t"],["libc::pid_t","","/libc/#item.pid_t"],["libc::uid_t","","/libc/#item.uid_t"],["libc::gid_t","","/libc/#item.gid_t"],["libc::in_addr_t","","/libc/#item.in_addr_t"],["libc::in_port_t","","/libc/#item.in_port_t"],["libc::sighandler_t","","/libc/#item.sighandler_t"],["libc::clockid_t","","/libc/#item.clockid_t"],["libc::ino64_t","","/libc/#item.ino64_t"],["libc::off64_t","","/libc/#item.off64_t"],["libc::blkcnt64_t","","/libc/#item.blkcnt64_t"],["libc::c_char","","/libc/#item.c_char"],["libc::wchar_t","","/libc/#item.wchar_t"],["libc::clock_t","","/libc/#item.clock_t"],["libc::time_t","","/libc/#item.time_t"],["libc::mode_t","","/libc/#item.mode_t"],["libc::c_long","","/libc/#item.c_long"],["libc::c_ulong","","/libc/#item.c_ulong"],["libc::clockid_t","","/libc/#item.clockid_t.1"],["libc::off_t","","/libc/#item.off_t"],["libc::nfds_t","","/libc/#item.nfds_t"],["libc::socklen_t","","/libc/#item.socklen_t"],["libc::sa_family_t","","/libc/#item.sa_family_t"],["libc::dev_t","","/libc/#item.dev_t"],["libc::blkcnt_t","","/libc/#item.blkcnt_t"],["libc::nlink_t","","/libc/#item.nlink_t"],["libc::blksize_t","","/libc/#item.blksize_t"],["libc::ino_t","","/libc/#item.ino_t"],["libc::suseconds_t","","/libc/#item.suseconds_t"],["libc::c_char","","/libc/#item.c_char.1"],["libc::wchar_t","","/libc/#item.wchar_t.1"],["libc::c_long","","/libc/#item.c_long.1"],["libc::c_ulong","","/libc/#item.c_ulong.1"],["libc::mode_t","","/libc/#item.mode_t.1"],["libc::clock_t","","/libc/#item.clock_t.1"],["libc::time_t","","/libc/#item.time_t.1"],["libc::off_t","","/libc/#item.off_t.1"],["libc::nfds_t","","/libc/#item.nfds_t.1"],["libc::socklen_t","","/libc/#item.socklen_t.1"],["libc::socklen_t","","/libc/#item.socklen_t.2"],["libc::sa_family_t","","/libc/#item.sa_family_t.1"],["libc::dev_t","","/libc/#item.dev_t.1"],["libc::blkcnt_t","","/libc/#item.blkcnt_t.1"],["libc::blksize_t","","/libc/#item.blksize_t.1"],["libc::nlink_t","","/libc/#item.nlink_t.1"],["libc::ino_t","","/libc/#item.ino_t.1"],["libc::suseconds_t","","/libc/#item.suseconds_t.1"],["libc::off_t","","/libc/#item.off_t.2"],["libc::ino_t","","/libc/#item.ino_t.2"],["libc::suseconds_t","","/libc/#item.suseconds_t.2"],["libc::off_t","","/libc/#item.off_t.3"],["libc::ino_t","","/libc/#item.ino_t.3"],["libc::suseconds_t","","/libc/#item.suseconds_t.3"],["libc::c_long","","/libc/#item.c_long.2"],["libc::c_ulong","","/libc/#item.c_ulong.2"],["libc::c_char","","/libc/#item.c_char.2"],["libc::wchar_t","","/libc/#item.wchar_t.2"],["libc::clock_t","","/libc/#item.clock_t.2"],["libc::time_t","","/libc/#item.time_t.2"],["libc::nlink_t","","/libc/#item.nlink_t.2"],["libc::blkcnt_t","","/libc/#item.blkcnt_t.2"],["libc::blksize_t","","/libc/#item.blksize_t.2"],["libc::c_char","","/libc/#item.c_char.3"],["libc::wchar_t","","/libc/#item.wchar_t.3"],["libc::clock_t","","/libc/#item.clock_t.3"],["libc::time_t","","/libc/#item.time_t.3"],["libc::nlink_t","","/libc/#item.nlink_t.3"],["libc::blkcnt_t","","/libc/#item.blkcnt_t.3"],["libc::blksize_t","","/libc/#item.blksize_t.3"],["libc::c_long","","/libc/#item.c_long.3"],["libc::c_ulong","","/libc/#item.c_ulong.3"],["libc::c_long","","/libc/#item.c_long.4"],["libc::c_ulong","","/libc/#item.c_ulong.4"],["libc::c_char","","/libc/#item.c_char.4"],["libc::wchar_t","","/libc/#item.wchar_t.4"],["libc::c_long","","/libc/#item.c_long.5"],["libc::c_ulong","","/libc/#item.c_ulong.5"],["libc::clock_t","","/libc/#item.clock_t.4"],["libc::time_t","","/libc/#item.time_t.4"],["libc::nlink_t","","/libc/#item.nlink_t.4"],["libc::blkcnt_t","","/libc/#item.blkcnt_t.4"],["libc::blksize_t","","/libc/#item.blksize_t.4"],["libc::c_long","","/libc/#item.c_long.6"],["libc::c_ulong","","/libc/#item.c_ulong.6"],["libc::clock_t","","/libc/#item.clock_t.5"],["libc::time_t","","/libc/#item.time_t.5"],["libc::nlink_t","","/libc/#item.nlink_t.5"],["libc::blkcnt_t","","/libc/#item.blkcnt_t.5"],["libc::blksize_t","","/libc/#item.blksize_t.5"],["libc::mode_t","","/libc/#item.mode_t.2"],["libc::socklen_t","","/libc/#item.socklen_t.3"],["libc::nfds_t","","/libc/#item.nfds_t.2"],["libc::sa_family_t","","/libc/#item.sa_family_t.2"],["libc::dev_t","","/libc/#item.dev_t.2"],["libc::c_char","","/libc/#item.c_char.5"],["libc::c_long","","/libc/#item.c_long.7"],["libc::c_ulong","","/libc/#item.c_ulong.7"],["libc::wchar_t","","/libc/#item.wchar_t.5"],["libc::pthread_t","","/libc/#item.pthread_t"],["libc::pthread_mutexattr_t","","/libc/#item.pthread_mutexattr_t"],["libc::pthread_rwlockattr_t","","/libc/#item.pthread_rwlockattr_t"],["libc::pthread_barrierattr_t","","/libc/#item.pthread_barrierattr_t"],["libc::pthread_condattr_t","","/libc/#item.pthread_condattr_t"],["libc::pthread_t","","/libc/#item.pthread_t.1"],["libc::pthread_t","","/libc/#item.pthread_t.2"],["libc::EXIT_FAILURE","","/libc/#item.EXIT_FAILURE"],["libc::EXIT_SUCCESS","","/libc/#item.EXIT_SUCCESS"],["libc::STDIN_FILENO","","/libc/#item.STDIN_FILENO"],["libc::STDOUT_FILENO","","/libc/#item.STDOUT_FILENO"],["libc::STDERR_FILENO","","/libc/#item.STDERR_FILENO"],["libc::SIGHUP","","/libc/#item.SIGHUP"],["libc::SIGINT","","/libc/#item.SIGINT"],["libc::SIGQUIT","","/libc/#item.SIGQUIT"],["libc::SIGILL","","/libc/#item.SIGILL"],["libc::SIGABRT","","/libc/#item.SIGABRT"],["libc::SIGFPE","","/libc/#item.SIGFPE"],["libc::SIGKILL","","/libc/#item.SIGKILL"],["libc::SIGSEGV","","/libc/#item.SIGSEGV"],["libc::SIGPIPE","","/libc/#item.SIGPIPE"],["libc::SIGALRM","","/libc/#item.SIGALRM"],["libc::SIGTERM","","/libc/#item.SIGTERM"],["libc::SIG_DFL","","/libc/#item.SIG_DFL"],["libc::SIG_IGN","","/libc/#item.SIG_IGN"],["libc::SIG_ERR","","/libc/#item.SIG_ERR"],["libc::SEEK_SET","","/libc/#item.SEEK_SET"],["libc::SEEK_CUR","","/libc/#item.SEEK_CUR"],["libc::SEEK_END","","/libc/#item.SEEK_END"],["libc::O_RDONLY","","/libc/#item.O_RDONLY"],["libc::O_WRONLY","","/libc/#item.O_WRONLY"],["libc::O_RDWR","","/libc/#item.O_RDWR"],["libc::O_ACCMODE","","/libc/#item.O_ACCMODE"],["libc::O_APPEND","","/libc/#item.O_APPEND"],["libc::O_ASYNC","","/libc/#item.O_ASYNC"],["libc::O_CLOEXEC","","/libc/#item.O_CLOEXEC"],["libc::O_CREAT","","/libc/#item.O_CREAT"],["libc::O_DSYNC","","/libc/#item.O_DSYNC"],["libc::O_EXCL","","/libc/#item.O_EXCL"],["libc::O_NDELAY","","/libc/#item.O_NDELAY"],["libc::O_NOCTTY","","/libc/#item.O_NOCTTY"],["libc::O_NONBLOCK","","/libc/#item.O_NONBLOCK"],["libc::O_RSYNC","","/libc/#item.O_RSYNC"],["libc::O_SYNC","","/libc/#item.O_SYNC"],["libc::O_TRUNC","","/libc/#item.O_TRUNC"],["libc::O_ACCMODE","","/libc/#item.O_ACCMODE.1"],["libc::O_APPEND","","/libc/#item.O_APPEND.1"],["libc::O_ASYNC","","/libc/#item.O_ASYNC.1"],["libc::O_CLOEXEC","","/libc/#item.O_CLOEXEC.1"],["libc::O_CREAT","","/libc/#item.O_CREAT.1"],["libc::O_DSYNC","","/libc/#item.O_DSYNC.1"],["libc::O_EXCL","","/libc/#item.O_EXCL.1"],["libc::O_NDELAY","","/libc/#item.O_NDELAY.1"],["libc::O_NOCTTY","","/libc/#item.O_NOCTTY.1"],["libc::O_NONBLOCK","","/libc/#item.O_NONBLOCK.1"],["libc::O_SYNC","","/libc/#item.O_SYNC.1"],["libc::O_TRUNC","","/libc/#item.O_TRUNC.1"],["libc::CLOCK_REALTIME","","/libc/#item.CLOCK_REALTIME"],["libc::CLOCK_MONOTONIC","","/libc/#item.CLOCK_MONOTONIC"],["libc::CLOCK_PROCESS_CPUTIME_ID","","/libc/#item.CLOCK_PROCESS_CPUTIME_ID"],["libc::CLOCK_THREAD_CPUTIME_ID","","/libc/#item.CLOCK_THREAD_CPUTIME_ID"],["libc::CLOCK_MONOTONIC_RAW","","/libc/#item.CLOCK_MONOTONIC_RAW"],["libc::CLOCK_REALTIME_COARSE","","/libc/#item.CLOCK_REALTIME_COARSE"],["libc::CLOCK_MONOTONIC_COARSE","","/libc/#item.CLOCK_MONOTONIC_COARSE"],["libc::CLOCK_BOOTTIME","","/libc/#item.CLOCK_BOOTTIME"],["libc::CLOCK_REALTIME_ALARM","","/libc/#item.CLOCK_REALTIME_ALARM"],["libc::CLOCK_BOOTTIME_ALARM","","/libc/#item.CLOCK_BOOTTIME_ALARM"],["libc::CLOCK_TAI","","/libc/#item.CLOCK_TAI"],["libc::SOCK_STREAM","","/libc/#item.SOCK_STREAM"],["libc::SOCK_DGRAM","","/libc/#item.SOCK_DGRAM"],["libc::EAI_BADFLAGS","","/libc/#item.EAI_BADFLAGS"],["libc::EAI_NONAME","","/libc/#item.EAI_NONAME"],["libc::EAI_AGAIN","","/libc/#item.EAI_AGAIN"],["libc::EAI_FAIL","","/libc/#item.EAI_FAIL"],["libc::EAI_NODATA","","/libc/#item.EAI_NODATA"],["libc::EAI_FAMILY","","/libc/#item.EAI_FAMILY"],["libc::EAI_SOCKTYPE","","/libc/#item.EAI_SOCKTYPE"],["libc::EAI_SERVICE","","/libc/#item.EAI_SERVICE"],["libc::EAI_MEMORY","","/libc/#item.EAI_MEMORY"],["libc::EAI_SYSTEM","","/libc/#item.EAI_SYSTEM"],["libc::EAI_OVERFLOW","","/libc/#item.EAI_OVERFLOW"],["libc::EPERM","","/libc/#item.EPERM"],["libc::ENOENT","","/libc/#item.ENOENT"],["libc::ESRCH","","/libc/#item.ESRCH"],["libc::EINTR","","/libc/#item.EINTR"],["libc::EIO","","/libc/#item.EIO"],["libc::ENXIO","","/libc/#item.ENXIO"],["libc::E2BIG","","/libc/#item.E2BIG"],["libc::ENOEXEC","","/libc/#item.ENOEXEC"],["libc::EBADF","","/libc/#item.EBADF"],["libc::ECHILD","","/libc/#item.ECHILD"],["libc::EAGAIN","","/libc/#item.EAGAIN"],["libc::ENOMEM","","/libc/#item.ENOMEM"],["libc::EACCES","","/libc/#item.EACCES"],["libc::EFAULT","","/libc/#item.EFAULT"],["libc::ENOTBLK","","/libc/#item.ENOTBLK"],["libc::EBUSY","","/libc/#item.EBUSY"],["libc::EEXIST","","/libc/#item.EEXIST"],["libc::EXDEV","","/libc/#item.EXDEV"],["libc::ENODEV","","/libc/#item.ENODEV"],["libc::ENOTDIR","","/libc/#item.ENOTDIR"],["libc::EISDIR","","/libc/#item.EISDIR"],["libc::EINVAL","","/libc/#item.EINVAL"],["libc::ENFILE","","/libc/#item.ENFILE"],["libc::EMFILE","","/libc/#item.EMFILE"],["libc::ENOTTY","","/libc/#item.ENOTTY"],["libc::ETXTBSY","","/libc/#item.ETXTBSY"],["libc::EFBIG","","/libc/#item.EFBIG"],["libc::ENOSPC","","/libc/#item.ENOSPC"],["libc::ESPIPE","","/libc/#item.ESPIPE"],["libc::EROFS","","/libc/#item.EROFS"],["libc::EMLINK","","/libc/#item.EMLINK"],["libc::EPIPE","","/libc/#item.EPIPE"],["libc::EDOM","","/libc/#item.EDOM"],["libc::ERANGE","","/libc/#item.ERANGE"],["libc::EWOULDBLOCK","","/libc/#item.EWOULDBLOCK"],["libc::EWOULDBLOCK","","/libc/#item.EWOULDBLOCK.1"],["libc::ETIMEDOUT","","/libc/#item.ETIMEDOUT"],["libc::ETIMEDOUT","","/libc/#item.ETIMEDOUT.1"],["libc::POLLIN","","/libc/#item.POLLIN"],["libc::POLLPRI","","/libc/#item.POLLPRI"],["libc::POLLOUT","","/libc/#item.POLLOUT"],["libc::POLLERR","","/libc/#item.POLLERR"],["libc::POLLHUP","","/libc/#item.POLLHUP"],["libc::POLLNVAL","","/libc/#item.POLLNVAL"],["libc::POLLRDNORM","","/libc/#item.POLLRDNORM"],["libc::POLLWRNORM","","/libc/#item.POLLWRNORM"],["libc::POLLRDBAND","","/libc/#item.POLLRDBAND"],["libc::POLLWRBAND","","/libc/#item.POLLWRBAND"],["libc::MSG_OOB","","/libc/#item.MSG_OOB"],["libc::MSG_PEEK","","/libc/#item.MSG_PEEK"],["libc::MSG_DONTROUTE","","/libc/#item.MSG_DONTROUTE"],["libc::MSG_CTRUNC","","/libc/#item.MSG_CTRUNC"],["libc::MSG_TRUNC","","/libc/#item.MSG_TRUNC"],["libc::MSG_DONTWAIT","","/libc/#item.MSG_DONTWAIT"],["libc::MSG_EOR","","/libc/#item.MSG_EOR"],["libc::MSG_WAITALL","","/libc/#item.MSG_WAITALL"],["libc::MSG_FIN","","/libc/#item.MSG_FIN"],["libc::MSG_SYN","","/libc/#item.MSG_SYN"],["libc::MSG_CONFIRM","","/libc/#item.MSG_CONFIRM"],["libc::MSG_RST","","/libc/#item.MSG_RST"],["libc::MSG_ERRQUEUE","","/libc/#item.MSG_ERRQUEUE"],["libc::MSG_NOSIGNAL","","/libc/#item.MSG_NOSIGNAL"],["libc::MSG_MORE","","/libc/#item.MSG_MORE"],["libc::MSG_WAITFORONE","","/libc/#item.MSG_WAITFORONE"],["libc::MSG_FASTOPEN","","/libc/#item.MSG_FASTOPEN"],["libc::MSG_CMSG_CLOEXEC","","/libc/#item.MSG_CMSG_CLOEXEC"],["libc::F_DUPFD","","/libc/#item.F_DUPFD"],["libc::F_GETFD","","/libc/#item.F_GETFD"],["libc::F_SETFD","","/libc/#item.F_SETFD"],["libc::F_GETFL","","/libc/#item.F_GETFL"],["libc::F_SETFL","","/libc/#item.F_SETFL"],["libc::FD_CLOEXEC","","/libc/#item.FD_CLOEXEC"],["libc::FIONBIO","","/libc/#item.FIONBIO"],["libc::FIOCLEX","","/libc/#item.FIOCLEX"],["libc::FIONBIO","","/libc/#item.FIONBIO.1"],["libc::FIOCLEX","","/libc/#item.FIOCLEX.1"],["libc::FIONBIO","","/libc/#item.FIONBIO.2"],["libc::FIOCLEX","","/libc/#item.FIOCLEX.2"],["libc::AF_UNSPEC","","/libc/#item.AF_UNSPEC"],["libc::AF_UNIX","","/libc/#item.AF_UNIX"],["libc::AF_LOCAL","","/libc/#item.AF_LOCAL"],["libc::AF_INET","","/libc/#item.AF_INET"],["libc::AF_AX25","","/libc/#item.AF_AX25"],["libc::AF_IPX","","/libc/#item.AF_IPX"],["libc::AF_APPLETALK","","/libc/#item.AF_APPLETALK"],["libc::AF_NETROM","","/libc/#item.AF_NETROM"],["libc::AF_BRIDGE","","/libc/#item.AF_BRIDGE"],["libc::AF_ATMPVC","","/libc/#item.AF_ATMPVC"],["libc::AF_X25","","/libc/#item.AF_X25"],["libc::AF_INET6","","/libc/#item.AF_INET6"],["libc::AF_ROSE","","/libc/#item.AF_ROSE"],["libc::AF_DECnet","","/libc/#item.AF_DECnet"],["libc::AF_NETBEUI","","/libc/#item.AF_NETBEUI"],["libc::AF_SECURITY","","/libc/#item.AF_SECURITY"],["libc::AF_KEY","","/libc/#item.AF_KEY"],["libc::AF_NETLINK","","/libc/#item.AF_NETLINK"],["libc::AF_ROUTE","","/libc/#item.AF_ROUTE"],["libc::AF_PACKET","","/libc/#item.AF_PACKET"],["libc::AF_ASH","","/libc/#item.AF_ASH"],["libc::AF_ECONET","","/libc/#item.AF_ECONET"],["libc::AF_ATMSVC","","/libc/#item.AF_ATMSVC"],["libc::AF_RDS","","/libc/#item.AF_RDS"],["libc::AF_SNA","","/libc/#item.AF_SNA"],["libc::AF_IRDA","","/libc/#item.AF_IRDA"],["libc::AF_PPPOX","","/libc/#item.AF_PPPOX"],["libc::AF_WANPIPE","","/libc/#item.AF_WANPIPE"],["libc::AF_LLC","","/libc/#item.AF_LLC"],["libc::AF_CAN","","/libc/#item.AF_CAN"],["libc::AF_TIPC","","/libc/#item.AF_TIPC"],["libc::AF_BLUETOOTH","","/libc/#item.AF_BLUETOOTH"],["libc::AF_IUCV","","/libc/#item.AF_IUCV"],["libc::AF_RXRPC","","/libc/#item.AF_RXRPC"],["libc::AF_ISDN","","/libc/#item.AF_ISDN"],["libc::AF_PHONET","","/libc/#item.AF_PHONET"],["libc::AF_IEEE802154","","/libc/#item.AF_IEEE802154"],["libc::AF_CAIF","","/libc/#item.AF_CAIF"],["libc::AF_ALG","","/libc/#item.AF_ALG"],["libc::AF_UNSPEC","","/libc/#item.AF_UNSPEC.1"],["libc::AF_LOCAL","","/libc/#item.AF_LOCAL.1"],["libc::AF_UNIX","","/libc/#item.AF_UNIX.1"],["libc::AF_INET","","/libc/#item.AF_INET.1"],["libc::AF_IMPLINK","","/libc/#item.AF_IMPLINK"],["libc::AF_PUP","","/libc/#item.AF_PUP"],["libc::AF_CHAOS","","/libc/#item.AF_CHAOS"],["libc::AF_NS","","/libc/#item.AF_NS"],["libc::AF_ISO","","/libc/#item.AF_ISO"],["libc::AF_OSI","","/libc/#item.AF_OSI"],["libc::AF_ECMA","","/libc/#item.AF_ECMA"],["libc::AF_DATAKIT","","/libc/#item.AF_DATAKIT"],["libc::AF_CCITT","","/libc/#item.AF_CCITT"],["libc::AF_SNA","","/libc/#item.AF_SNA.1"],["libc::AF_DECnet","","/libc/#item.AF_DECnet.1"],["libc::AF_DLI","","/libc/#item.AF_DLI"],["libc::AF_LAT","","/libc/#item.AF_LAT"],["libc::AF_HYLINK","","/libc/#item.AF_HYLINK"],["libc::AF_APPLETALK","","/libc/#item.AF_APPLETALK.1"],["libc::AF_ROUTE","","/libc/#item.AF_ROUTE.1"],["libc::AF_LINK","","/libc/#item.AF_LINK"],["libc::pseudo_AF_XTP","","/libc/#item.pseudo_AF_XTP"],["libc::AF_COIP","","/libc/#item.AF_COIP"],["libc::AF_CNT","","/libc/#item.AF_CNT"],["libc::pseudo_AF_RTIP","","/libc/#item.pseudo_AF_RTIP"],["libc::AF_IPX","","/libc/#item.AF_IPX.1"],["libc::AF_SIP","","/libc/#item.AF_SIP"],["libc::pseudo_AF_PIP","","/libc/#item.pseudo_AF_PIP"],["libc::AF_ISDN","","/libc/#item.AF_ISDN.1"],["libc::AF_E164","","/libc/#item.AF_E164"],["libc::pseudo_AF_KEY","","/libc/#item.pseudo_AF_KEY"],["libc::AF_INET6","","/libc/#item.AF_INET6.1"],["libc::AF_NATM","","/libc/#item.AF_NATM"],["libc::AF_SYSTEM","","/libc/#item.AF_SYSTEM"],["libc::AF_NETBIOS","","/libc/#item.AF_NETBIOS"],["libc::AF_PPP","","/libc/#item.AF_PPP"],["libc::pseudo_AF_HDRCMPLT","","/libc/#item.pseudo_AF_HDRCMPLT"],["libc::AF_SYS_CONTROL","","/libc/#item.AF_SYS_CONTROL"],["libc::SHUT_RD","","/libc/#item.SHUT_RD"],["libc::SHUT_WR","","/libc/#item.SHUT_WR"],["libc::SHUT_RDWR","","/libc/#item.SHUT_RDWR"],["libc::DT_UNKNOWN","","/libc/#item.DT_UNKNOWN"],["libc::DT_FIFO","","/libc/#item.DT_FIFO"],["libc::DT_CHR","","/libc/#item.DT_CHR"],["libc::DT_DIR","","/libc/#item.DT_DIR"],["libc::DT_BLK","","/libc/#item.DT_BLK"],["libc::DT_REG","","/libc/#item.DT_REG"],["libc::DT_LNK","","/libc/#item.DT_LNK"],["libc::DT_SOCK","","/libc/#item.DT_SOCK"],["libc::S_IFIFO","","/libc/#item.S_IFIFO"],["libc::S_IFCHR","","/libc/#item.S_IFCHR"],["libc::S_IFBLK","","/libc/#item.S_IFBLK"],["libc::S_IFDIR","","/libc/#item.S_IFDIR"],["libc::S_IFREG","","/libc/#item.S_IFREG"],["libc::S_IFLNK","","/libc/#item.S_IFLNK"],["libc::S_IFSOCK","","/libc/#item.S_IFSOCK"],["libc::S_IFMT","","/libc/#item.S_IFMT"],["libc::PTHREAD_RWLOCKATTR_T_SIZE","","/libc/#item.PTHREAD_RWLOCKATTR_T_SIZE"],["libc::PTHREAD_COND_T_SIZE","","/libc/#item.PTHREAD_COND_T_SIZE"],["libc::PTHREAD_CONDATTR_T_SIZE","","/libc/#item.PTHREAD_CONDATTR_T_SIZE"],["libc::PTHREAD_MUTEXATTR_T_SIZE","","/libc/#item.PTHREAD_MUTEXATTR_T_SIZE"],["libc::PTHREAD_MUTEX_T_SIZE","","/libc/#item.PTHREAD_MUTEX_T_SIZE"],["libc::PTHREAD_RWLOCK_T_SIZE","","/libc/#item.PTHREAD_RWLOCK_T_SIZE"],["libc::PTHREAD_CONDATTR_T_SIZE","","/libc/#item.PTHREAD_CONDATTR_T_SIZE.1"],["libc::PTHREAD_MUTEXATTR_T_SIZE","","/libc/#item.PTHREAD_MUTEXATTR_T_SIZE.1"],["libc::PTHREAD_MUTEX_T_SIZE","","/libc/#item.PTHREAD_MUTEX_T_SIZE.1"],["libc::PTHREAD_RWLOCK_T_SIZE","","/libc/#item.PTHREAD_RWLOCK_T_SIZE.1"],["libc::PTHREAD_CONDATTR_T_SIZE","","/libc/#item.PTHREAD_CONDATTR_T_SIZE.2"],["libc::PTHREAD_MUTEXATTR_T_SIZE","","/libc/#item.PTHREAD_MUTEXATTR_T_SIZE.2"],["libc::PTHREAD_MUTEX_T_SIZE","","/libc/#item.PTHREAD_MUTEX_T_SIZE.2"],["libc::PTHREAD_RWLOCK_T_SIZE","","/libc/#item.PTHREAD_RWLOCK_T_SIZE.2"],["libc::PTHREAD_CONDATTR_T_SIZE","","/libc/#item.PTHREAD_CONDATTR_T_SIZE.3"],["libc::PTHREAD_MUTEXATTR_T_SIZE","","/libc/#item.PTHREAD_MUTEXATTR_T_SIZE.3"],["libc::PTHREAD_MUTEX_T_SIZE","","/libc/#item.PTHREAD_MUTEX_T_SIZE.3"],["libc::PTHREAD_RWLOCK_T_SIZE","","/libc/#item.PTHREAD_RWLOCK_T_SIZE.3"],["libc::PTHREAD_CREATE_JOINABLE","","/libc/#item.PTHREAD_CREATE_JOINABLE"],["libc::PTHREAD_CREATE_DETACHED","","/libc/#item.PTHREAD_CREATE_DETACHED"],["libc::PTHREAD_CREATE_JOINABLE","","/libc/#item.PTHREAD_CREATE_JOINABLE.1"],["libc::PTHREAD_CREATE_DETACHED","","/libc/#item.PTHREAD_CREATE_DETACHED.1"],["libc::FUTEX_WAIT","","/libc/#item.FUTEX_WAIT"],["libc::FUTEX_WAKE","","/libc/#item.FUTEX_WAKE"],["libc::FUTEX_FD","","/libc/#item.FUTEX_FD"],["libc::FUTEX_REQUEUE","","/libc/#item.FUTEX_REQUEUE"],["libc::FUTEX_CMP_REQUEUE","","/libc/#item.FUTEX_CMP_REQUEUE"],["libc::FUTEX_WAKE_OP","","/libc/#item.FUTEX_WAKE_OP"],["libc::FUTEX_LOCK_PI","","/libc/#item.FUTEX_LOCK_PI"],["libc::FUTEX_UNLOCK_PI","","/libc/#item.FUTEX_UNLOCK_PI"],["libc::FUTEX_TRYLOCK_PI","","/libc/#item.FUTEX_TRYLOCK_PI"],["libc::FUTEX_WAIT_BITSET","","/libc/#item.FUTEX_WAIT_BITSET"],["libc::FUTEX_WAKE_BITSET","","/libc/#item.FUTEX_WAKE_BITSET"],["libc::FUTEX_WAIT_REQUEUE_PI","","/libc/#item.FUTEX_WAIT_REQUEUE_PI"],["libc::FUTEX_CMP_REQUEUE_PI","","/libc/#item.FUTEX_CMP_REQUEUE_PI"],["libc::FUTEX_PRIVATE_FLAG","","/libc/#item.FUTEX_PRIVATE_FLAG"],["libc::FUTEX_CLOCK_REALTIME","","/libc/#item.FUTEX_CLOCK_REALTIME"],["libc::FUTEX_CMD_MASK","","/libc/#item.FUTEX_CMD_MASK"],["libc::SYS_futex","","/libc/#item.SYS_futex"],["libc::SYS_futex","","/libc/#item.SYS_futex.1"],["libc::SYS_futex","","/libc/#item.SYS_futex.2"],["std::builtins"," Builtin types and their method implementations.","/std/builtins/"],["std::cmp"," Equality and comparison","/std/cmp/"],["std::collections"," Heap-allocating collections.","/std/collections/"],["std::ffi"," Utilities related to FFI bindings.","/std/ffi/"],["std::fmt"," String formatting","/std/fmt/"],["std::fs"," Working with files and directories","/std/fs/"],["std::hash"," Generic (non-cryptographic) hashing support","/std/hash/"],["std::intrinsics"," Functions implemented directly in the compiler.","/std/intrinsics/"],["std::io"," Streams and other byte I/O functionality","/std/io/"],["std::iter"," Iterators.","/std/iter/"],["std::math"," Math functions","/std/math/"],["std::mem"," Working with memory (allocation, slices, copying, ...)","/std/mem/"],["std::net"," Network sockets","/std/net/"],["std::option"," Optional values","/std/option/"],["std::panicking"," Panic support macros and functions","/std/panicking/"],["std::prelude"," Items available everywhere without having to `use` them","/std/prelude/"],["std::process"," A module for working with processes.","/std/process/"],["std::random"," Random number generation","/std/random/"],["std::range"," Integer ranges","/std/range/"],["std::result"," Type for operations that can fail.","/std/result/"],["std::runtime"," Run time glue code (program entrypoint, tests, ...)","/std/runtime/"],["std::string"," String functions","/std/string/"],["std::sync"," Thread synchronization primitives","/std/sync/"],["std::thread"," Multi-threading support","/std/thread/"],["std::time"," Time and duration functions","/std/time/"],["std::typing"," Type reflection and `dyn` objects","/std/typing/"],["std::util"," Various utility functions useful in the generic context.","/std/util/"],["std::internal","","/std/internal/"],["std::tests","","/std/tests/"],["std::compile_fail"," Causes the compilation to fail if reached.","/std/compile_fail.html"],["std::compile_warn"," Emits a compile-time warning.","/std/compile_warn.html"],["std::compile_note"," Emits a note during compilation.","/std/compile_note.html"],["std::assert"," Panics if `cond` evaluates to false.","/std/assert.html"],["std::assert_eq"," Panics if `lhs` and `rhs` are not equal.","/std/assert_eq.html"],["std::assert_ne"," Panics if `lhs` and `rhs` are equal.","/std/assert_ne.html"],["std::debug_assert"," Panics if `cond` evaluates to false when compiled in debug mode. Otherwise, does nothing.","/std/debug_assert.html"],["std::debug_assert_eq"," Panics if `lhs` and `rhs` are not equal when compiled in debug mode. Otherwise, does nothing.","/std/debug_assert_eq.html"],["std::debug_assert_ne"," Panics if `lhs` and `rhs` are equal when compiled in debug mode. Otherwise, does nothing.","/std/debug_assert_ne.html"],["std::unreachable"," Treats the location as unreachable during program flow.","/std/unreachable.html"],["std::assume"," Assume that the condition is true.","/std/assume.html"],["std::likely"," Hint to the compiler that a particular boolean expression is likely true.","/std/likely.html"],["std::unlikely"," Hint to the compiler that a particular boolean expression is unlikely to be true.","/std/unlikely.html"],["std::line"," Returns the line in the source code at which the macro was invoked.","/std/line.html"],["std::column"," Returns the column in the source code at which the macro was invoked.","/std/column.html"],["std::file"," Returns the file in the source code at which the macro was invoked.","/std/file.html"],["std::env"," Returns the value of an environment variable during compilation.","/std/env.html"],["std::include_bytes"," Reads a file during compilation and returns its contents as a string slice.","/std/include_bytes.html"],["std::concat"," Concatenates strings at compile time.","/std/concat.html"],["std::dbg"," A helper for printing a value of a subexpression for debugging purposes.","/std/dbg.html"],["std::builtins::tuples"," Method implementations for tuple types","/std/builtins/tuples/"],["std::builtins::internal","","/std/builtins/internal/"],["std::builtins::tests","","/std/builtins/tests/"],["std::builtins::void"," Unit type (`()`)","/std/builtins/void.html"],["std::builtins::bool"," Boolean type","/std/builtins/bool.html"],["std::builtins::never"," Never type (`!`)","/std/builtins/never.html"],["std::builtins::u8"," 8-bit unsigned integer (byte)","/std/builtins/u8.html"],["std::builtins::u16"," 16-bit unsigned integer","/std/builtins/u16.html"],["std::builtins::u32"," 32-bit unsigned integer","/std/builtins/u32.html"],["std::builtins::u64"," 64-bit unsigned integer","/std/builtins/u64.html"],["std::builtins::u128"," 128-bit unsigned integer","/std/builtins/u128.html"],["std::builtins::usize"," Native unsigned integer (machine word)","/std/builtins/usize.html"],["std::builtins::i8"," Signed 8-bit integer","/std/builtins/i8.html"],["std::builtins::i16"," Signed 16-bit integer","/std/builtins/i16.html"],["std::builtins::i32"," Signed 32-bit integer","/std/builtins/i32.html"],["std::builtins::i64"," Signed 64-bit integer","/std/builtins/i64.html"],["std::builtins::i128"," Signed 128-bit integer","/std/builtins/i128.html"],["std::builtins::isize"," Native signed integer (machine word)","/std/builtins/isize.html"],["std::builtins::f32"," Single precision floating point type","/std/builtins/f32.html"],["std::builtins::f64"," Double precision floating point type","/std/builtins/f64.html"],["std::builtins::array"," Fixed size arrays","/std/builtins/array.html"],["std::builtins::ZeroSized"," Matches zero-sized types (void, named function types, empty structs, empty arrays, ...)","/std/builtins/ZeroSized.html"],["std::builtins::Primitive"," Matches all primitive types","/std/builtins/Primitive.html"],["std::builtins::Numeric"," Integer and floating point types","/std/builtins/Numeric.html"],["std::builtins::Integer"," Integer types","/std/builtins/Integer.html"],["std::builtins::FloatingPoint"," Floating point types","/std/builtins/FloatingPoint.html"],["std::builtins::Signed"," Signed integer types (`i8`, `i16`, `i32`, ...)","/std/builtins/Signed.html"],["std::builtins::Unsigned"," Unsigned integer types (`u8`, `u16`, `u32`, ...)","/std/builtins/Unsigned.html"],["std::builtins::Pointer"," All pointers","/std/builtins/Pointer.html"],["std::builtins::Array"," All (fixed-size) arrays","/std/builtins/Array.html"],["std::builtins::Tuple"," All tuples","/std/builtins/Tuple.html"],["std::builtins::Struct"," All structs","/std/builtins/Struct.html"],["std::builtins::Union"," All unions","/std/builtins/Union.html"],["std::builtins::Enum"," All enums","/std/builtins/Enum.html"],["std::builtins::Range"," All ranges (`a..b`, `a..=b`, `..b`, `..=b`, ...)","/std/builtins/Range.html"],["std::builtins::NamedFunction"," All named functions (including lambdas, but excluding closures)","/std/builtins/NamedFunction.html"],["std::builtins::FunctionPointer"," Function pointers","/std/builtins/FunctionPointer.html"],["std::builtins::Callable"," All callable objects (named functions, closures, and function pointers)","/std/builtins/Callable.html"],["std::builtins::ArrayOf"," Arrays with element type `T`","/std/builtins/ArrayOf.html"],["std::builtins::PointerOf"," Pointers to `T` (regardless of mutability)","/std/builtins/PointerOf.html"],["std::builtins::RangeOf"," Range over `T`","/std/builtins/RangeOf.html"],["std::builtins::Protocol"," All protocols","/std/builtins/Protocol.html"],["std::builtins::unsigned_of"," Unsigned integer type of the same size as the original type.","/std/builtins/#item.unsigned_of"],["std::builtins::signed_of"," Signed integer type of the same size as the original type.","/std/builtins/#item.signed_of"],["std::builtins::element_of"," Element type of the provided array","/std/builtins/#item.element_of"],["std::builtins::deref_of"," Type of the pointed-to value","/std/builtins/#item.deref_of"],["std::builtins::tuple_head_of"," Type of the first element of the provided tuple","/std/builtins/#item.tuple_head_of"],["std::builtins::tuple_tail_of"," Tuple type equivalent to the provided one without the first element.","/std/builtins/#item.tuple_tail_of"],["std::builtins::return_type_of"," Return type of the provided function","/std/builtins/#item.return_type_of"],["std::builtins::arguments_of"," Tuple of argument types of the provided function","/std/builtins/#item.arguments_of"],["std::builtins::generic_args_of"," Tuple of the generic arguments of a given type","/std/builtins/#item.generic_args_of"],["std::builtins::pointer_with_mut_of"," Pointer to `T` with same constness as `Ptr`.","/std/builtins/#item.pointer_with_mut_of"],["std::builtins::array_with_length_of"," Array of `T` with same length as `Arr`.","/std/builtins/#item.array_with_length_of"],["std::builtins::enum_type_of"," Backing type of an `enum`.","/std/builtins/#item.enum_type_of"],["std::builtins::array::as_slice"," Returns a slice covering the entire array.","/std/builtins/array.html#item.as_slice"],["std::builtins::array::as_slice_mut"," Returns a mutable slice covering the entire array.","/std/builtins/array.html#item.as_slice_mut"],["std::builtins::array::as_ptr"," Returns a pointer to the first element.","/std/builtins/array.html#item.as_ptr"],["std::builtins::array::as_ptr_mut"," Returns a mutable pointer to the first element.","/std/builtins/array.html#item.as_ptr_mut"],["std::builtins::array::len"," Returns the number of elements in the array.","/std/builtins/array.html#item.len"],["std::builtins::array::iter"," Returns an iterator over the elements of this iterable.","/std/builtins/array.html#item.iter"],["std::builtins::bool::max_value"," Returns `true`.","/std/builtins/bool.html#item.max_value"],["std::builtins::bool::min_value"," Returns `false`.","/std/builtins/bool.html#item.min_value"],["std::builtins::bool::then_some"," Convert boolean into an [Option] with a given value.","/std/builtins/bool.html#item.then_some"],["std::builtins::bool::then"," Convert boolean into an [Option] with a value provided by a closure.","/std/builtins/bool.html#item.then"],["std::builtins::bool::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/builtins/bool.html#item.equals"],["std::builtins::bool::compare"," Compare the value","/std/builtins/bool.html#item.compare"],["std::builtins::bool::hash"," Update hasher state with the contents of this object.","/std/builtins/bool.html#item.hash"],["std::builtins::bool::fmt"," Write the object into a given formatter.","/std/builtins/bool.html#item.fmt"],["std::builtins::f32::is_sign_negative"," Returns `true` if the number has a negative sign, `false` otherwise.","/std/builtins/f32.html#item.is_sign_negative"],["std::builtins::f32::max_value"," Returns the maximum value of `f32`.","/std/builtins/f32.html#item.max_value"],["std::builtins::f32::min_value"," Returns the minimum value of `f32`.","/std/builtins/f32.html#item.min_value"],["std::builtins::f32::min_positive"," Returns the smallest positive value of `f32`.","/std/builtins/f32.html#item.min_positive"],["std::builtins::f32::epsilon"," Returns the machine epsilon for `f32`.","/std/builtins/f32.html#item.epsilon"],["std::builtins::f32::acos"," Inverse cosine","/std/builtins/f32.html#item.acos"],["std::builtins::f32::asin"," Inverse sine","/std/builtins/f32.html#item.asin"],["std::builtins::f32::atan"," Inverse tangent","/std/builtins/f32.html#item.atan"],["std::builtins::f32::atan2"," Four-quadrant inverse tangent","/std/builtins/f32.html#item.atan2"],["std::builtins::f32::atanh"," Inverse hyperbolic cosine","/std/builtins/f32.html#item.atanh"],["std::builtins::f32::cbrt"," Cube root","/std/builtins/f32.html#item.cbrt"],["std::builtins::f32::ceil"," Ceiling of number","/std/builtins/f32.html#item.ceil"],["std::builtins::f32::cos"," Cosine","/std/builtins/f32.html#item.cos"],["std::builtins::f32::cosh"," Hyperbolic cosine","/std/builtins/f32.html#item.cosh"],["std::builtins::f32::erf"," Gauss error function","/std/builtins/f32.html#item.erf"],["std::builtins::f32::erfc"," Complementary error function (1 - [erf(self)](erf))","/std/builtins/f32.html#item.erfc"],["std::builtins::f32::exp"," Exponential function (e^`self`)","/std/builtins/f32.html#item.exp"],["std::builtins::f32::floor"," Floor of number","/std/builtins/f32.html#item.floor"],["std::builtins::f32::frexp"," Decomposes `self` into a normalized fractional part and an integral power of two.","/std/builtins/f32.html#item.frexp"],["std::builtins::f32::ldexp"," Multiplies `self` by 2 raised to the power of `exp`.","/std/builtins/f32.html#item.ldexp"],["std::builtins::f32::log"," Natural logarithm","/std/builtins/f32.html#item.log"],["std::builtins::f32::log2"," Base 2 logarithm","/std/builtins/f32.html#item.log2"],["std::builtins::f32::log10"," Base 10 logarithm","/std/builtins/f32.html#item.log10"],["std::builtins::f32::modf"," Decompose `self` into a whole and fractional part","/std/builtins/f32.html#item.modf"],["std::builtins::f32::pow"," Power function","/std/builtins/f32.html#item.pow"],["std::builtins::f32::round"," Rounds `self` to the closest integer.","/std/builtins/f32.html#item.round"],["std::builtins::f32::sin"," Sine function","/std/builtins/f32.html#item.sin"],["std::builtins::f32::sinh"," Hyperbolic sine function","/std/builtins/f32.html#item.sinh"],["std::builtins::f32::sqrt"," Square root","/std/builtins/f32.html#item.sqrt"],["std::builtins::f32::tan"," Tangent function","/std/builtins/f32.html#item.tan"],["std::builtins::f32::tanh"," Hyperbolic tangent function","/std/builtins/f32.html#item.tanh"],["std::builtins::f32::trunc"," Returns the integer part of `self` (round towards zero).","/std/builtins/f32.html#item.trunc"],["std::builtins::f64::is_sign_negative"," Returns `true` if the number has a negative sign, `false` otherwise.","/std/builtins/f64.html#item.is_sign_negative"],["std::builtins::f64::max_value"," Returns the maximum value of `f64`","/std/builtins/f64.html#item.max_value"],["std::builtins::f64::min_value"," Returns the minimum value of `f64`","/std/builtins/f64.html#item.min_value"],["std::builtins::f64::min_positive"," Returns the smallest positive value of `f64`.","/std/builtins/f64.html#item.min_positive"],["std::builtins::f64::epsilon"," Returns the machine epsilon for `f64`.","/std/builtins/f64.html#item.epsilon"],["std::builtins::f64::acos"," Inverse cosine","/std/builtins/f64.html#item.acos"],["std::builtins::f64::asin"," Inverse sine","/std/builtins/f64.html#item.asin"],["std::builtins::f64::atan"," Inverse tangent","/std/builtins/f64.html#item.atan"],["std::builtins::f64::atan2"," Four-quadrant inverse tangent","/std/builtins/f64.html#item.atan2"],["std::builtins::f64::atanh"," Inverse hyperbolic cosine","/std/builtins/f64.html#item.atanh"],["std::builtins::f64::cbrt"," Cube root","/std/builtins/f64.html#item.cbrt"],["std::builtins::f64::ceil"," Ceiling of number","/std/builtins/f64.html#item.ceil"],["std::builtins::f64::cos"," Cosine","/std/builtins/f64.html#item.cos"],["std::builtins::f64::cosh"," Hyperbolic cosine","/std/builtins/f64.html#item.cosh"],["std::builtins::f64::erf"," Gauss error function","/std/builtins/f64.html#item.erf"],["std::builtins::f64::erfc"," Complementary error function (1 - [erf(self)](erf))","/std/builtins/f64.html#item.erfc"],["std::builtins::f64::exp"," Exponential function (e^`self`)","/std/builtins/f64.html#item.exp"],["std::builtins::f64::floor"," Floor of number","/std/builtins/f64.html#item.floor"],["std::builtins::f64::frexp"," Decomposes `self` into a normalized fractional part and an integral power of two.","/std/builtins/f64.html#item.frexp"],["std::builtins::f64::ldexp"," Multiplies `self` by 2 raised to the power of `exp`.","/std/builtins/f64.html#item.ldexp"],["std::builtins::f64::log"," Natural logarithm","/std/builtins/f64.html#item.log"],["std::builtins::f64::log2"," Base 2 logarithm","/std/builtins/f64.html#item.log2"],["std::builtins::f64::log10"," Base 10 logarithm","/std/builtins/f64.html#item.log10"],["std::builtins::f64::modf"," Decompose `self` into a whole and fractional part","/std/builtins/f64.html#item.modf"],["std::builtins::f64::pow"," Power function","/std/builtins/f64.html#item.pow"],["std::builtins::f64::round"," Rounds `self` to the closest integer.","/std/builtins/f64.html#item.round"],["std::builtins::f64::sin"," Sine function","/std/builtins/f64.html#item.sin"],["std::builtins::f64::sinh"," Hyperbolic sine function","/std/builtins/f64.html#item.sinh"],["std::builtins::f64::sqrt"," Square root","/std/builtins/f64.html#item.sqrt"],["std::builtins::f64::tan"," Tangent function","/std/builtins/f64.html#item.tan"],["std::builtins::f64::tanh"," Hyperbolic tangent function","/std/builtins/f64.html#item.tanh"],["std::builtins::f64::trunc"," Returns the integer part of `self` (round towards zero).","/std/builtins/f64.html#item.trunc"],["std::builtins::i128::max_value"," Returns the maximum value of `i128`.","/std/builtins/i128.html#item.max_value"],["std::builtins::i128::min_value"," Returns the minimum value of `i128`.","/std/builtins/i128.html#item.min_value"],["std::builtins::i16::max_value"," Returns the maximum value of `i16`.","/std/builtins/i16.html#item.max_value"],["std::builtins::i16::min_value"," Returns the minimum value of `i16`.","/std/builtins/i16.html#item.min_value"],["std::builtins::i32::max_value"," Returns the maximum value of `i32`.","/std/builtins/i32.html#item.max_value"],["std::builtins::i32::min_value"," Returns the minimum value of `i32`.","/std/builtins/i32.html#item.min_value"],["std::builtins::i64::max_value"," Returns the maximum value of `i64`.","/std/builtins/i64.html#item.max_value"],["std::builtins::i64::min_value"," Returns the minimum value of `i64`.","/std/builtins/i64.html#item.min_value"],["std::builtins::i8::max_value"," Returns the maximum value of `i8`.","/std/builtins/i8.html#item.max_value"],["std::builtins::i8::min_value"," Returns the minimum value of `i8`.","/std/builtins/i8.html#item.min_value"],["std::builtins::internal::BuiltinComparable"," This mixin implements Equatable and Comparable for types that have natively implemented","/std/builtins/internal/BuiltinComparable.html"],["std::builtins::internal::IntegerParsable"," Mixin for parsing integers from strings.","/std/builtins/internal/IntegerParsable.html"],["std::builtins::internal::IntegerFormattable"," String formatting mixin for integers.","/std/builtins/internal/IntegerFormattable.html"],["std::builtins::internal::FloatFormattable"," String formatting mixin for floating-point types.","/std/builtins/internal/FloatFormattable.html"],["std::builtins::internal::BitOps"," Bitwise operations on unsigned integers","/std/builtins/internal/BitOps.html"],["std::builtins::internal::FloatOps"," Mixin for common floating point functions","/std/builtins/internal/FloatOps.html"],["std::builtins::internal::BitOps::swap_bytes"," Swaps the byte order (endianness) of the number.","/std/builtins/internal/BitOps.html#item.swap_bytes"],["std::builtins::internal::BitOps::to_be"," Converts the number into a big-endian representation.","/std/builtins/internal/BitOps.html#item.to_be"],["std::builtins::internal::BitOps::from_be"," Converts the number from a big-endian representation.","/std/builtins/internal/BitOps.html#item.from_be"],["std::builtins::internal::BitOps::to_le"," Converts the number into a little-endian representation.","/std/builtins/internal/BitOps.html#item.to_le"],["std::builtins::internal::BitOps::from_le"," Converts the number from a little-endian representation.","/std/builtins/internal/BitOps.html#item.from_le"],["std::builtins::internal::BitOps::count_ones"," Returns the number of ones in the binary representation of the number.","/std/builtins/internal/BitOps.html#item.count_ones"],["std::builtins::internal::BitOps::count_zeros"," Returns the number of zeros in the binary representation of the number.","/std/builtins/internal/BitOps.html#item.count_zeros"],["std::builtins::internal::BitOps::leading_zeros"," Returns the number of leading zeros in the binary representation of the number.","/std/builtins/internal/BitOps.html#item.leading_zeros"],["std::builtins::internal::BitOps::trailing_zeros"," Returns the number of trailing zeros in the binary representation of the number.","/std/builtins/internal/BitOps.html#item.trailing_zeros"],["std::builtins::internal::BitOps::leading_ones"," Returns the number of leading ones in the binary representation of the number.","/std/builtins/internal/BitOps.html#item.leading_ones"],["std::builtins::internal::BitOps::trailing_ones"," Returns the number of trailing ones in the binary representation of the number.","/std/builtins/internal/BitOps.html#item.trailing_ones"],["std::builtins::internal::BitOps::rotate_left"," Rotates the bits to the left by `n` bits.","/std/builtins/internal/BitOps.html#item.rotate_left"],["std::builtins::internal::BitOps::rotate_right"," Rotates the bits to the right by `n` bits.","/std/builtins/internal/BitOps.html#item.rotate_right"],["std::builtins::internal::BuiltinComparable::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/builtins/internal/BuiltinComparable.html#item.equals"],["std::builtins::internal::BuiltinComparable::not_equals"," Returns `false` if arguments are equal, `true` otherwise","/std/builtins/internal/BuiltinComparable.html#item.not_equals"],["std::builtins::internal::BuiltinComparable::compare"," Compare the value","/std/builtins/internal/BuiltinComparable.html#item.compare"],["std::builtins::internal::BuiltinComparable::less_than"," Returns `true` if `lhs` is strictly less than `rhs`, `false` otherwise","/std/builtins/internal/BuiltinComparable.html#item.less_than"],["std::builtins::internal::BuiltinComparable::less_than_or_equal"," Returns `true` if `lhs` is less or equal to `rhs`, `false` otherwise","/std/builtins/internal/BuiltinComparable.html#item.less_than_or_equal"],["std::builtins::internal::BuiltinComparable::greater_than"," Returns `true` if `lhs` strictly greater than `rhs`, `false` otherwise","/std/builtins/internal/BuiltinComparable.html#item.greater_than"],["std::builtins::internal::BuiltinComparable::greater_than_or_equal"," Returns `true` if `lhs` greater than or equal `rhs`, `false` otherwise","/std/builtins/internal/BuiltinComparable.html#item.greater_than_or_equal"],["std::builtins::internal::FloatFormattable::fmt"," Write the object into a given formatter.","/std/builtins/internal/FloatFormattable.html#item.fmt"],["std::builtins::internal::FloatOps::nan"," Returns `NaN`.","/std/builtins/internal/FloatOps.html#item.nan"],["std::builtins::internal::FloatOps::infinity"," Returns a positive infinity.","/std/builtins/internal/FloatOps.html#item.infinity"],["std::builtins::internal::FloatOps::neg_infinity"," Returns a negative infinity.","/std/builtins/internal/FloatOps.html#item.neg_infinity"],["std::builtins::internal::FloatOps::is_nan"," Returns `true` if the number is NaN, `false` otherwise.","/std/builtins/internal/FloatOps.html#item.is_nan"],["std::builtins::internal::FloatOps::is_infinite"," Returns `true` if the number is infinite, `false` otherwise.","/std/builtins/internal/FloatOps.html#item.is_infinite"],["std::builtins::internal::FloatOps::is_finite"," Returns `true` if the number is neither infinite nor NaN, `false` otherwise.","/std/builtins/internal/FloatOps.html#item.is_finite"],["std::builtins::internal::IntegerFormattable::fmt"," Write the object into a given formatter.","/std/builtins/internal/IntegerFormattable.html#item.fmt"],["std::builtins::internal::IntegerParsable::parse"," Parses the integer from a base-10 string.","/std/builtins/internal/IntegerParsable.html#item.parse"],["std::builtins::internal::IntegerParsable::parse_with_radix"," Parses the integer from a string in a given base.","/std/builtins/internal/IntegerParsable.html#item.parse_with_radix"],["std::builtins::isize::max_value"," Returns the maximum value of `isize`.","/std/builtins/isize.html#item.max_value"],["std::builtins::isize::min_value"," Returns the minimum value of `isize`.","/std/builtins/isize.html#item.min_value"],["std::builtins::never::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/builtins/never.html#item.equals"],["std::builtins::never::compare"," Compare the value","/std/builtins/never.html#item.compare"],["std::builtins::never::hash"," Update hasher state with the contents of this object.","/std/builtins/never.html#item.hash"],["std::builtins::never::fmt"," Write the object into a given formatter.","/std/builtins/never.html#item.fmt"],["std::builtins::tests::unsigned_num_limits","","/std/builtins/tests/#item.unsigned_num_limits"],["std::builtins::tests::signed_num_limits","","/std/builtins/tests/#item.signed_num_limits"],["std::builtins::tests::test_signed_of","","/std/builtins/tests/#item.test_signed_of"],["std::builtins::tests::test_unsigned_of","","/std/builtins/tests/#item.test_unsigned_of"],["std::builtins::tests::test_generic_args_of","","/std/builtins/tests/#item.test_generic_args_of"],["std::builtins::tests::test_swap_bytes","","/std/builtins/tests/#item.test_swap_bytes"],["std::builtins::tests::test_deref_of","","/std/builtins/tests/#item.test_deref_of"],["std::builtins::tests::test_trailing_bits","","/std/builtins/tests/#item.test_trailing_bits"],["std::builtins::tests::test_leading_bits","","/std/builtins/tests/#item.test_leading_bits"],["std::builtins::tests::test_popcount","","/std/builtins/tests/#item.test_popcount"],["std::builtins::tests::test_array_length","","/std/builtins/tests/#item.test_array_length"],["std::builtins::tests::test_f64_ops","","/std/builtins/tests/#item.test_f64_ops"],["std::builtins::tests::test_f32_ops","","/std/builtins/tests/#item.test_f32_ops"],["std::builtins::tests::test_array_size_constexpr","","/std/builtins/tests/#item.test_array_size_constexpr"],["std::builtins::tuples::tuple_1","","/std/builtins/tuples/tuple_1.html"],["std::builtins::tuples::tuple_2","","/std/builtins/tuples/tuple_2.html"],["std::builtins::tuples::tuple_3","","/std/builtins/tuples/tuple_3.html"],["std::builtins::tuples::tuple_4","","/std/builtins/tuples/tuple_4.html"],["std::builtins::tuples::tuple_5","","/std/builtins/tuples/tuple_5.html"],["std::builtins::tuples::tuple_6","","/std/builtins/tuples/tuple_6.html"],["std::builtins::tuples::tuple_7","","/std/builtins/tuples/tuple_7.html"],["std::builtins::tuples::tuple_8","","/std/builtins/tuples/tuple_8.html"],["std::builtins::tuples::tuple_1::equals","","/std/builtins/tuples/tuple_1.html#item.equals"],["std::builtins::tuples::tuple_1::compare","","/std/builtins/tuples/tuple_1.html#item.compare"],["std::builtins::tuples::tuple_1::hash","","/std/builtins/tuples/tuple_1.html#item.hash"],["std::builtins::tuples::tuple_2::equals","","/std/builtins/tuples/tuple_2.html#item.equals"],["std::builtins::tuples::tuple_2::compare","","/std/builtins/tuples/tuple_2.html#item.compare"],["std::builtins::tuples::tuple_2::hash","","/std/builtins/tuples/tuple_2.html#item.hash"],["std::builtins::tuples::tuple_3::equals","","/std/builtins/tuples/tuple_3.html#item.equals"],["std::builtins::tuples::tuple_3::compare","","/std/builtins/tuples/tuple_3.html#item.compare"],["std::builtins::tuples::tuple_3::hash","","/std/builtins/tuples/tuple_3.html#item.hash"],["std::builtins::tuples::tuple_4::equals","","/std/builtins/tuples/tuple_4.html#item.equals"],["std::builtins::tuples::tuple_4::compare","","/std/builtins/tuples/tuple_4.html#item.compare"],["std::builtins::tuples::tuple_4::hash","","/std/builtins/tuples/tuple_4.html#item.hash"],["std::builtins::tuples::tuple_5::equals","","/std/builtins/tuples/tuple_5.html#item.equals"],["std::builtins::tuples::tuple_5::compare","","/std/builtins/tuples/tuple_5.html#item.compare"],["std::builtins::tuples::tuple_5::hash","","/std/builtins/tuples/tuple_5.html#item.hash"],["std::builtins::tuples::tuple_6::equals","","/std/builtins/tuples/tuple_6.html#item.equals"],["std::builtins::tuples::tuple_6::compare","","/std/builtins/tuples/tuple_6.html#item.compare"],["std::builtins::tuples::tuple_6::hash","","/std/builtins/tuples/tuple_6.html#item.hash"],["std::builtins::tuples::tuple_7::equals","","/std/builtins/tuples/tuple_7.html#item.equals"],["std::builtins::tuples::tuple_7::compare","","/std/builtins/tuples/tuple_7.html#item.compare"],["std::builtins::tuples::tuple_7::hash","","/std/builtins/tuples/tuple_7.html#item.hash"],["std::builtins::tuples::tuple_8::equals","","/std/builtins/tuples/tuple_8.html#item.equals"],["std::builtins::tuples::tuple_8::compare","","/std/builtins/tuples/tuple_8.html#item.compare"],["std::builtins::tuples::tuple_8::hash","","/std/builtins/tuples/tuple_8.html#item.hash"],["std::builtins::u128::max_value"," Returns the maximum value of `u128`.","/std/builtins/u128.html#item.max_value"],["std::builtins::u128::min_value"," Returns the minimum value of `u128`.","/std/builtins/u128.html#item.min_value"],["std::builtins::u16::max_value"," Returns the maximum value of `u16`.","/std/builtins/u16.html#item.max_value"],["std::builtins::u16::min_value"," Returns the minimum value of `u16`.","/std/builtins/u16.html#item.min_value"],["std::builtins::u32::max_value"," Returns the maximum value of `u32`.","/std/builtins/u32.html#item.max_value"],["std::builtins::u32::min_value"," Returns the minimum value of `u32`.","/std/builtins/u32.html#item.min_value"],["std::builtins::u64::max_value"," Returns the maximum value of `u64`.","/std/builtins/u64.html#item.max_value"],["std::builtins::u64::min_value"," Returns the minimum value of `u64`.","/std/builtins/u64.html#item.min_value"],["std::builtins::u8::max_value"," Returns the maximum value of `u8`.","/std/builtins/u8.html#item.max_value"],["std::builtins::u8::min_value"," Returns the minimum value of `u8`.","/std/builtins/u8.html#item.min_value"],["std::builtins::usize::max_value"," Returns the maximum value of `usize`.","/std/builtins/usize.html#item.max_value"],["std::builtins::usize::min_value"," Returns the minimum value of `usize`.","/std/builtins/usize.html#item.min_value"],["std::builtins::void::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/builtins/void.html#item.equals"],["std::builtins::void::compare"," Compare the value","/std/builtins/void.html#item.compare"],["std::builtins::void::hash"," Update hasher state with the contents of this object.","/std/builtins/void.html#item.hash"],["std::cmp::internal","","/std/cmp/internal/"],["std::cmp::tests","","/std/cmp/tests/"],["std::cmp::Equatable"," Types that can be compared for equality.","/std/cmp/Equatable.html"],["std::cmp::Comparable"," Types that have a total order.","/std/cmp/Comparable.html"],["std::cmp::Reversed"," A wrapper that can be used to reverse the ordering of a Comparable.","/std/cmp/Reversed.html"],["std::cmp::reversed"," Reverses the ordering of a Comparable.","/std/cmp/#item.reversed"],["std::cmp::max"," Returns the greater of the two arguments.","/std/cmp/#item.max"],["std::cmp::min"," Returns the least of the two arguments.","/std/cmp/#item.min"],["std::cmp::sort_by"," Sorts a slice using a key extraction function.","/std/cmp/#item.sort_by"],["std::cmp::sort"," Sorts a slice.","/std/cmp/#item.sort"],["std::cmp::Ordering"," Result of comparing two values.","/std/cmp/Ordering.html"],["std::cmp::lex_compare"," Helper macro for implementing a lexicographic order.","/std/cmp/lex_compare.html"],["std::cmp::Comparable::compare"," Compare the value","/std/cmp/Comparable.html#item.compare"],["std::cmp::Comparable::equals"," Returns `true` if `lhs` is equal to `rhs`, `false` otherwise","/std/cmp/Comparable.html#item.equals"],["std::cmp::Comparable::not_equals"," Returns `true` if `lhs` not equal to `rhs`, `false` otherwise","/std/cmp/Comparable.html#item.not_equals"],["std::cmp::Comparable::less_than"," Returns `true` if `lhs` is strictly less than `rhs`, `false` otherwise","/std/cmp/Comparable.html#item.less_than"],["std::cmp::Comparable::less_than_or_equal"," Returns `true` if `lhs` is less or equal to `rhs`, `false` otherwise","/std/cmp/Comparable.html#item.less_than_or_equal"],["std::cmp::Comparable::greater_than"," Returns `true` if `lhs` strictly greater than `rhs`, `false` otherwise","/std/cmp/Comparable.html#item.greater_than"],["std::cmp::Comparable::greater_than_or_equal"," Returns `true` if `lhs` greater than or equal `rhs`, `false` otherwise","/std/cmp/Comparable.html#item.greater_than_or_equal"],["std::cmp::Equatable::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/cmp/Equatable.html#item.equals"],["std::cmp::Equatable::not_equals"," Returns `false` if arguments are equal, `true` otherwise","/std/cmp/Equatable.html#item.not_equals"],["std::cmp::Ordering::Less","","/std/cmp/Ordering.html#item.Less"],["std::cmp::Ordering::Equal","","/std/cmp/Ordering.html#item.Equal"],["std::cmp::Ordering::Greater","","/std/cmp/Ordering.html#item.Greater"],["std::cmp::Reversed::compare"," Compare the value","/std/cmp/Reversed.html#item.compare"],["std::cmp::Reversed::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/cmp/Reversed.html#item.equals"],["std::cmp::internal::operator_eq","","/std/cmp/internal/#item.operator_eq"],["std::cmp::internal::operator_neq","","/std/cmp/internal/#item.operator_neq"],["std::cmp::internal::operator_lt","","/std/cmp/internal/#item.operator_lt"],["std::cmp::internal::operator_lte","","/std/cmp/internal/#item.operator_lte"],["std::cmp::internal::operator_gt","","/std/cmp/internal/#item.operator_gt"],["std::cmp::internal::operator_gte","","/std/cmp/internal/#item.operator_gte"],["std::cmp::internal::partition_by","","/std/cmp/internal/#item.partition_by"],["std::cmp::tests::test_sort","","/std/cmp/tests/#item.test_sort"],["std::cmp::tests::test_sort_by","","/std/cmp/tests/#item.test_sort_by"],["std::collections::deque","","/std/collections/deque/"],["std::collections::hashmap","","/std/collections/hashmap/"],["std::collections::hashset","","/std/collections/hashset/"],["std::collections::vector","","/std/collections/vector/"],["std::collections::tests","","/std/collections/tests/"],["std::collections::Vector"," Growable heap-allocated array.","/std/collections/Vector.html"],["std::collections::HashSet"," A hash-based set collection.","/std/collections/HashSet.html"],["std::collections::Deque"," A double-ended queue (growable ring buffer).","/std/collections/Deque.html"],["std::collections::HashMap"," A simple linear probing hash table.","/std/collections/HashMap.html"],["std::collections::free_all"," Helper for collections that own heap-allocated objects. This is used to","/std/collections/#item.free_all"],["std::collections::Deque::new"," Create an empty deque","/std/collections/Deque.html#item.new"],["std::collections::Deque::with_capacity"," Create a deque that can hold up to `capacity` elements without reallocating.","/std/collections/Deque.html#item.with_capacity"],["std::collections::Deque::from_slice"," Create a deque from a slice, copying the elements.","/std/collections/Deque.html#item.from_slice"],["std::collections::Deque::from_iter"," Create a deque from an iterator of elements.","/std/collections/Deque.html#item.from_iter"],["std::collections::Deque::reserve"," Reserve capacity for at least `additional` elements.","/std/collections/Deque.html#item.reserve"],["std::collections::Deque::shrink_to_fit"," Shrink the size of the underlying buffer to the minimum size","/std/collections/Deque.html#item.shrink_to_fit"],["std::collections::Deque::len"," Returns the number of elements in the deque.","/std/collections/Deque.html#item.len"],["std::collections::Deque::capacity"," Returns the total number of elements that the deque can hold without reallocating.","/std/collections/Deque.html#item.capacity"],["std::collections::Deque::is_empty"," Returns `true` if the deque is empty, `false` otherwise.","/std/collections/Deque.html#item.is_empty"],["std::collections::Deque::clear"," Clears the deque, removing all values.","/std/collections/Deque.html#item.clear"],["std::collections::Deque::as_slices"," Returns a pair of slices that represent the deque's contents in order.","/std/collections/Deque.html#item.as_slices"],["std::collections::Deque::as_slices_mut"," Returns a pair of mutable slices that represent the deque's contents in order.","/std/collections/Deque.html#item.as_slices_mut"],["std::collections::Deque::push"," Pushes an element to the back of the deque.","/std/collections/Deque.html#item.push"],["std::collections::Deque::pop"," Pops an element from the back of the deque.","/std/collections/Deque.html#item.pop"],["std::collections::Deque::push_front"," Pushes an element to the front of the deque.","/std/collections/Deque.html#item.push_front"],["std::collections::Deque::pop_front"," Pops an element from the front of the deque.","/std/collections/Deque.html#item.pop_front"],["std::collections::Deque::iter"," Returns an iterator over the elements of the deque.","/std/collections/Deque.html#item.iter"],["std::collections::Deque::iter_ref"," Returns a iterator over the pointers to the elements of the deque.","/std/collections/Deque.html#item.iter_ref"],["std::collections::Deque::iter_mut"," Returns a iterator over the mutable pointers to the elements of the deque.","/std/collections/Deque.html#item.iter_mut"],["std::collections::Deque::extend"," Extends the deque on the back end with the contents of an iterator.","/std/collections/Deque.html#item.extend"],["std::collections::Deque::extend_front"," Extends the deque on the front end with the contents of an iterator.","/std/collections/Deque.html#item.extend_front"],["std::collections::Deque::extend_from_slice"," Extends the deque on the back end with the contents of a slice.","/std/collections/Deque.html#item.extend_from_slice"],["std::collections::Deque::retain"," Removes the elements not mathing the given predicate.","/std/collections/Deque.html#item.retain"],["std::collections::Deque::move"," Creates a copy of the object, leaving an inert object behind.","/std/collections/Deque.html#item.move"],["std::collections::Deque::free"," Frees the memory backing the object.","/std/collections/Deque.html#item.free"],["std::collections::Deque::clone"," Returns a copy of the object.","/std/collections/Deque.html#item.clone"],["std::collections::HashMap::new"," Creates an empty hash map","/std/collections/HashMap.html#item.new"],["std::collections::HashMap::with_capacity"," Creates an empty hash map that can store up to `capacity` items without","/std/collections/HashMap.html#item.with_capacity"],["std::collections::HashMap::with_size"," Creates a hashmap with a specific number of buckets.","/std/collections/HashMap.html#item.with_size"],["std::collections::HashMap::reserve"," Reserves space for at least `additional` more elements to be inserted without","/std/collections/HashMap.html#item.reserve"],["std::collections::HashMap::rehash"," Resizes the underlying array to exactly the given `new_capacity`.","/std/collections/HashMap.html#item.rehash"],["std::collections::HashMap::shrink_to_fit"," Reduces the size of underlying storage to fit the contained elements if needed.","/std/collections/HashMap.html#item.shrink_to_fit"],["std::collections::HashMap::insert"," Inserts a value into the map under a given key.","/std/collections/HashMap.html#item.insert"],["std::collections::HashMap::get"," Retreives the value by given key.","/std/collections/HashMap.html#item.get"],["std::collections::HashMap::get_ref"," Retreives a pointer to the value by given key.","/std/collections/HashMap.html#item.get_ref"],["std::collections::HashMap::get_mut"," Retreives a mutable pointer to the value by given key.","/std/collections/HashMap.html#item.get_mut"],["std::collections::HashMap::remove"," Removes the element from the map.","/std/collections/HashMap.html#item.remove"],["std::collections::HashMap::len"," Returns the number of elements in the map.","/std/collections/HashMap.html#item.len"],["std::collections::HashMap::is_empty"," Returns `true` if the map is empty, `false` otherwise.","/std/collections/HashMap.html#item.is_empty"],["std::collections::HashMap::clear"," Removes all elements from the array.","/std/collections/HashMap.html#item.clear"],["std::collections::HashMap::iter"," Returns an iterator over the elements of the array.","/std/collections/HashMap.html#item.iter"],["std::collections::HashMap::iter_ref"," Returns an iterator of pointers to elements of the array.","/std/collections/HashMap.html#item.iter_ref"],["std::collections::HashMap::iter_mut"," Returns an iterator of mutable pointers to elements of the array.","/std/collections/HashMap.html#item.iter_mut"],["std::collections::HashMap::retain"," Removes the elements not mathing the given predicate.","/std/collections/HashMap.html#item.retain"],["std::collections::HashMap::free"," Frees the memory backing the object.","/std/collections/HashMap.html#item.free"],["std::collections::HashMap::move"," Creates a copy of the object, leaving an inert object behind.","/std/collections/HashMap.html#item.move"],["std::collections::HashMap::clone"," Returns a copy of the object.","/std/collections/HashMap.html#item.clone"],["std::collections::HashMap::from_iter"," Creates a hash map from an iterator of key-value pairs","/std/collections/HashMap.html#item.from_iter"],["std::collections::HashMap::extend"," Inserts additional elements into the map from an iterator","/std/collections/HashMap.html#item.extend"],["std::collections::HashSet::new"," Creates an empty set","/std/collections/HashSet.html#item.new"],["std::collections::HashSet::with_capacity"," Creates an empty set that can store up to `capacity` items without","/std/collections/HashSet.html#item.with_capacity"],["std::collections::HashSet::with_size"," Creates a set with a specific number of buckets.","/std/collections/HashSet.html#item.with_size"],["std::collections::HashSet::reserve"," Reserves space for at least `additional` more elements to be inserted without","/std/collections/HashSet.html#item.reserve"],["std::collections::HashSet::rehash"," Resizes the underlying array to exactly the given `new_capacity`.","/std/collections/HashSet.html#item.rehash"],["std::collections::HashSet::shrink_to_fit"," Reduces the size of underlying storage to fit the contained elements if needed.","/std/collections/HashSet.html#item.shrink_to_fit"],["std::collections::HashSet::insert"," Inserts a value into the set.","/std/collections/HashSet.html#item.insert"],["std::collections::HashSet::remove"," Removes a value from the set.","/std/collections/HashSet.html#item.remove"],["std::collections::HashSet::contains"," Retreives `true` if the set contains the given value, `false` otherwise.","/std/collections/HashSet.html#item.contains"],["std::collections::HashSet::len"," Retreives the number of elements in the set.","/std/collections/HashSet.html#item.len"],["std::collections::HashSet::is_empty"," Returns `true` if the set is empty, `false` otherwise.","/std/collections/HashSet.html#item.is_empty"],["std::collections::HashSet::clear"," Clears the set, removing all values.","/std/collections/HashSet.html#item.clear"],["std::collections::HashSet::iter"," Returns an iterator over the elements of this iterable.","/std/collections/HashSet.html#item.iter"],["std::collections::HashSet::iter_ref"," Returns an iterator over the pointers of the items of the collection.","/std/collections/HashSet.html#item.iter_ref"],["std::collections::HashSet::retain"," Removes the elements not mathing the given predicate.","/std/collections/HashSet.html#item.retain"],["std::collections::HashSet::free"," Frees the memory backing the object.","/std/collections/HashSet.html#item.free"],["std::collections::HashSet::move"," Creates a copy of the object, leaving an inert object behind.","/std/collections/HashSet.html#item.move"],["std::collections::HashSet::clone"," Returns a copy of the object.","/std/collections/HashSet.html#item.clone"],["std::collections::HashSet::from_iter"," Creates a hash map from an iterator of key-value pairs","/std/collections/HashSet.html#item.from_iter"],["std::collections::HashSet::extend"," Inserts additional elements into the set from an iterator","/std/collections/HashSet.html#item.extend"],["std::collections::Vector::new"," Create an empty vector","/std/collections/Vector.html#item.new"],["std::collections::Vector::from_raw"," Create a vector from a raw slice and a length.","/std/collections/Vector.html#item.from_raw"],["std::collections::Vector::with_capacity"," Create a vector that can hold up to `capacity` elements without reallocating.","/std/collections/Vector.html#item.with_capacity"],["std::collections::Vector::from_slice"," Create a vector from a slice, copying the elements.","/std/collections/Vector.html#item.from_slice"],["std::collections::Vector::from_iter"," Create a vector from an iterator.","/std/collections/Vector.html#item.from_iter"],["std::collections::Vector::reserve"," Reserve capacity for at least `additional` elements.","/std/collections/Vector.html#item.reserve"],["std::collections::Vector::extend_from_slice"," Extend the vector with the elements from a slice.","/std/collections/Vector.html#item.extend_from_slice"],["std::collections::Vector::extend"," Extend the vector with the elements from an iterator.","/std/collections/Vector.html#item.extend"],["std::collections::Vector::insert"," Insert an element at the given index, shifting all elements after it.","/std/collections/Vector.html#item.insert"],["std::collections::Vector::get"," Get the element at the given index.","/std/collections/Vector.html#item.get"],["std::collections::Vector::as_slice"," View the vector as a slice.","/std/collections/Vector.html#item.as_slice"],["std::collections::Vector::as_slice_mut"," View the vector as a mutable slice.","/std/collections/Vector.html#item.as_slice_mut"],["std::collections::Vector::push"," Push an element to the end of the vector.","/std/collections/Vector.html#item.push"],["std::collections::Vector::pop"," Pop an element from the end of the vector.","/std/collections/Vector.html#item.pop"],["std::collections::Vector::remove"," Remove an element at the given index, shifting all elements after it.","/std/collections/Vector.html#item.remove"],["std::collections::Vector::len"," Return the length of the vector.","/std/collections/Vector.html#item.len"],["std::collections::Vector::capacity"," Return the size of the underlying buffer.","/std/collections/Vector.html#item.capacity"],["std::collections::Vector::spare_capacity"," Returns a region of memory \"after the last element\".","/std/collections/Vector.html#item.spare_capacity"],["std::collections::Vector::is_empty"," Returns `true` if the vector is empty, `false` otherwise.","/std/collections/Vector.html#item.is_empty"],["std::collections::Vector::clear"," Clear the vector, removing all elements.","/std/collections/Vector.html#item.clear"],["std::collections::Vector::truncate"," Truncate the vector, removing all but the first `new_size` elements.","/std/collections/Vector.html#item.truncate"],["std::collections::Vector::retain"," Removes the elements not mathing the given predicate.","/std/collections/Vector.html#item.retain"],["std::collections::Vector::iter"," Returns an iterator over the vector.","/std/collections/Vector.html#item.iter"],["std::collections::Vector::iter_ref"," Returns an iterator over the pointers to the elements.","/std/collections/Vector.html#item.iter_ref"],["std::collections::Vector::iter_mut"," Returns an iterator over the mutable pointers to the elements.","/std/collections/Vector.html#item.iter_mut"],["std::collections::Vector::shrink_to_fit"," Shrink the underlying buffer to the length of the vector.","/std/collections/Vector.html#item.shrink_to_fit"],["std::collections::Vector::free"," Frees the memory backing the object.","/std/collections/Vector.html#item.free"],["std::collections::Vector::move"," Creates a copy of the object, leaving an inert object behind.","/std/collections/Vector.html#item.move"],["std::collections::Vector::clone"," Create a shallow copy of the vector.","/std/collections/Vector.html#item.clone"],["std::collections::Vector::write_str"," Write a string","/std/collections/Vector.html#item.write_str"],["std::collections::Vector::write_char"," Write a single character","/std/collections/Vector.html#item.write_char"],["std::collections::Vector::fmt"," Write the object into a given formatter.","/std/collections/Vector.html#item.fmt"],["std::collections::deque::tests","","/std/collections/deque/tests/"],["std::collections::deque::Deque"," A double-ended queue (growable ring buffer).","/std/collections/deque/Deque.html"],["std::collections::deque::DequeIterator"," Iterator over the elements of a deque.","/std/collections/deque/DequeIterator.html"],["std::collections::deque::DequeRefIterator"," Iterator over the pointers to the elements of a deque.","/std/collections/deque/DequeRefIterator.html"],["std::collections::deque::Deque::new"," Create an empty deque","/std/collections/deque/Deque.html#item.new"],["std::collections::deque::Deque::with_capacity"," Create a deque that can hold up to `capacity` elements without reallocating.","/std/collections/deque/Deque.html#item.with_capacity"],["std::collections::deque::Deque::from_slice"," Create a deque from a slice, copying the elements.","/std/collections/deque/Deque.html#item.from_slice"],["std::collections::deque::Deque::from_iter"," Create a deque from an iterator of elements.","/std/collections/deque/Deque.html#item.from_iter"],["std::collections::deque::Deque::reserve"," Reserve capacity for at least `additional` elements.","/std/collections/deque/Deque.html#item.reserve"],["std::collections::deque::Deque::shrink_to_fit"," Shrink the size of the underlying buffer to the minimum size","/std/collections/deque/Deque.html#item.shrink_to_fit"],["std::collections::deque::Deque::len"," Returns the number of elements in the deque.","/std/collections/deque/Deque.html#item.len"],["std::collections::deque::Deque::capacity"," Returns the total number of elements that the deque can hold without reallocating.","/std/collections/deque/Deque.html#item.capacity"],["std::collections::deque::Deque::is_empty"," Returns `true` if the deque is empty, `false` otherwise.","/std/collections/deque/Deque.html#item.is_empty"],["std::collections::deque::Deque::clear"," Clears the deque, removing all values.","/std/collections/deque/Deque.html#item.clear"],["std::collections::deque::Deque::as_slices"," Returns a pair of slices that represent the deque's contents in order.","/std/collections/deque/Deque.html#item.as_slices"],["std::collections::deque::Deque::as_slices_mut"," Returns a pair of mutable slices that represent the deque's contents in order.","/std/collections/deque/Deque.html#item.as_slices_mut"],["std::collections::deque::Deque::push"," Pushes an element to the back of the deque.","/std/collections/deque/Deque.html#item.push"],["std::collections::deque::Deque::pop"," Pops an element from the back of the deque.","/std/collections/deque/Deque.html#item.pop"],["std::collections::deque::Deque::push_front"," Pushes an element to the front of the deque.","/std/collections/deque/Deque.html#item.push_front"],["std::collections::deque::Deque::pop_front"," Pops an element from the front of the deque.","/std/collections/deque/Deque.html#item.pop_front"],["std::collections::deque::Deque::iter"," Returns an iterator over the elements of the deque.","/std/collections/deque/Deque.html#item.iter"],["std::collections::deque::Deque::iter_ref"," Returns a iterator over the pointers to the elements of the deque.","/std/collections/deque/Deque.html#item.iter_ref"],["std::collections::deque::Deque::iter_mut"," Returns a iterator over the mutable pointers to the elements of the deque.","/std/collections/deque/Deque.html#item.iter_mut"],["std::collections::deque::Deque::extend"," Extends the deque on the back end with the contents of an iterator.","/std/collections/deque/Deque.html#item.extend"],["std::collections::deque::Deque::extend_front"," Extends the deque on the front end with the contents of an iterator.","/std/collections/deque/Deque.html#item.extend_front"],["std::collections::deque::Deque::extend_from_slice"," Extends the deque on the back end with the contents of a slice.","/std/collections/deque/Deque.html#item.extend_from_slice"],["std::collections::deque::Deque::retain"," Removes the elements not mathing the given predicate.","/std/collections/deque/Deque.html#item.retain"],["std::collections::deque::Deque::move"," Creates a copy of the object, leaving an inert object behind.","/std/collections/deque/Deque.html#item.move"],["std::collections::deque::Deque::free"," Frees the memory backing the object.","/std/collections/deque/Deque.html#item.free"],["std::collections::deque::Deque::clone"," Returns a copy of the object.","/std/collections/deque/Deque.html#item.clone"],["std::collections::deque::DequeIterator::next"," Returns the next item, if any.","/std/collections/deque/DequeIterator.html#item.next"],["std::collections::deque::DequeIterator::next_back"," Returns the next item from the back, if any.","/std/collections/deque/DequeIterator.html#item.next_back"],["std::collections::deque::DequeIterator::size_hint"," Returns the number of remaining elements, if available.","/std/collections/deque/DequeIterator.html#item.size_hint"],["std::collections::deque::DequeRefIterator::next"," Returns the next item, if any.","/std/collections/deque/DequeRefIterator.html#item.next"],["std::collections::deque::DequeRefIterator::next_back"," Returns the next item from the back, if any.","/std/collections/deque/DequeRefIterator.html#item.next_back"],["std::collections::deque::DequeRefIterator::size_hint"," Returns the number of remaining elements, if available.","/std/collections/deque/DequeRefIterator.html#item.size_hint"],["std::collections::deque::tests::test_basic","","/std/collections/deque/tests/#item.test_basic"],["std::collections::deque::tests::test_push_pop","","/std/collections/deque/tests/#item.test_push_pop"],["std::collections::deque::tests::test_push_front_pop_front","","/std/collections/deque/tests/#item.test_push_front_pop_front"],["std::collections::deque::tests::test_push_pop_front","","/std/collections/deque/tests/#item.test_push_pop_front"],["std::collections::deque::tests::test_push_front_pop","","/std/collections/deque/tests/#item.test_push_front_pop"],["std::collections::deque::tests::test_as_slices_contiguous","","/std/collections/deque/tests/#item.test_as_slices_contiguous"],["std::collections::deque::tests::test_as_slices_non_contiguous","","/std/collections/deque/tests/#item.test_as_slices_non_contiguous"],["std::collections::deque::tests::test_iter","","/std/collections/deque/tests/#item.test_iter"],["std::collections::deque::tests::test_iter_rev","","/std/collections/deque/tests/#item.test_iter_rev"],["std::collections::deque::tests::test_iter_ref","","/std/collections/deque/tests/#item.test_iter_ref"],["std::collections::deque::tests::test_iter_ref_rev","","/std/collections/deque/tests/#item.test_iter_ref_rev"],["std::collections::deque::tests::test_iter_mut","","/std/collections/deque/tests/#item.test_iter_mut"],["std::collections::deque::tests::test_extend","","/std/collections/deque/tests/#item.test_extend"],["std::collections::deque::tests::test_extend_front","","/std/collections/deque/tests/#item.test_extend_front"],["std::collections::deque::tests::test_extend_1","","/std/collections/deque/tests/#item.test_extend_1"],["std::collections::deque::tests::test_extend_front_1","","/std/collections/deque/tests/#item.test_extend_front_1"],["std::collections::deque::tests::test_extend_from_slice","","/std/collections/deque/tests/#item.test_extend_from_slice"],["std::collections::deque::tests::test_extend_from_slice_1","","/std/collections/deque/tests/#item.test_extend_from_slice_1"],["std::collections::deque::tests::test_clone","","/std/collections/deque/tests/#item.test_clone"],["std::collections::deque::tests::test_retain","","/std/collections/deque/tests/#item.test_retain"],["std::collections::deque::tests::assert_deque_eq","","/std/collections/deque/tests/assert_deque_eq.html"],["std::collections::hashmap::tests","","/std/collections/hashmap/tests/"],["std::collections::hashmap::HashMap"," A simple linear probing hash table.","/std/collections/hashmap/HashMap.html"],["std::collections::hashmap::HashItem","","/std/collections/hashmap/HashItem.html"],["std::collections::hashmap::HashMapRefIterator","","/std/collections/hashmap/HashMapRefIterator.html"],["std::collections::hashmap::HashMapMutIterator","","/std/collections/hashmap/HashMapMutIterator.html"],["std::collections::hashmap::HashMapIterator","","/std/collections/hashmap/HashMapIterator.html"],["std::collections::hashmap::State","","/std/collections/hashmap/State.html"],["std::collections::hashmap::INITIAL_SIZE","","/std/collections/hashmap/#item.INITIAL_SIZE"],["std::collections::hashmap::HashMap::new"," Creates an empty hash map","/std/collections/hashmap/HashMap.html#item.new"],["std::collections::hashmap::HashMap::with_capacity"," Creates an empty hash map that can store up to `capacity` items without","/std/collections/hashmap/HashMap.html#item.with_capacity"],["std::collections::hashmap::HashMap::with_size"," Creates a hashmap with a specific number of buckets.","/std/collections/hashmap/HashMap.html#item.with_size"],["std::collections::hashmap::HashMap::reserve"," Reserves space for at least `additional` more elements to be inserted without","/std/collections/hashmap/HashMap.html#item.reserve"],["std::collections::hashmap::HashMap::rehash"," Resizes the underlying array to exactly the given `new_capacity`.","/std/collections/hashmap/HashMap.html#item.rehash"],["std::collections::hashmap::HashMap::shrink_to_fit"," Reduces the size of underlying storage to fit the contained elements if needed.","/std/collections/hashmap/HashMap.html#item.shrink_to_fit"],["std::collections::hashmap::HashMap::insert"," Inserts a value into the map under a given key.","/std/collections/hashmap/HashMap.html#item.insert"],["std::collections::hashmap::HashMap::get"," Retreives the value by given key.","/std/collections/hashmap/HashMap.html#item.get"],["std::collections::hashmap::HashMap::get_ref"," Retreives a pointer to the value by given key.","/std/collections/hashmap/HashMap.html#item.get_ref"],["std::collections::hashmap::HashMap::get_mut"," Retreives a mutable pointer to the value by given key.","/std/collections/hashmap/HashMap.html#item.get_mut"],["std::collections::hashmap::HashMap::remove"," Removes the element from the map.","/std/collections/hashmap/HashMap.html#item.remove"],["std::collections::hashmap::HashMap::len"," Returns the number of elements in the map.","/std/collections/hashmap/HashMap.html#item.len"],["std::collections::hashmap::HashMap::is_empty"," Returns `true` if the map is empty, `false` otherwise.","/std/collections/hashmap/HashMap.html#item.is_empty"],["std::collections::hashmap::HashMap::clear"," Removes all elements from the array.","/std/collections/hashmap/HashMap.html#item.clear"],["std::collections::hashmap::HashMap::iter"," Returns an iterator over the elements of the array.","/std/collections/hashmap/HashMap.html#item.iter"],["std::collections::hashmap::HashMap::iter_ref"," Returns an iterator of pointers to elements of the array.","/std/collections/hashmap/HashMap.html#item.iter_ref"],["std::collections::hashmap::HashMap::iter_mut"," Returns an iterator of mutable pointers to elements of the array.","/std/collections/hashmap/HashMap.html#item.iter_mut"],["std::collections::hashmap::HashMap::retain"," Removes the elements not mathing the given predicate.","/std/collections/hashmap/HashMap.html#item.retain"],["std::collections::hashmap::HashMap::free"," Frees the memory backing the object.","/std/collections/hashmap/HashMap.html#item.free"],["std::collections::hashmap::HashMap::move"," Creates a copy of the object, leaving an inert object behind.","/std/collections/hashmap/HashMap.html#item.move"],["std::collections::hashmap::HashMap::clone"," Returns a copy of the object.","/std/collections/hashmap/HashMap.html#item.clone"],["std::collections::hashmap::HashMap::from_iter"," Creates a hash map from an iterator of key-value pairs","/std/collections/hashmap/HashMap.html#item.from_iter"],["std::collections::hashmap::HashMap::extend"," Inserts additional elements into the map from an iterator","/std/collections/hashmap/HashMap.html#item.extend"],["std::collections::hashmap::HashMapIterator::next"," Returns the next item, if any.","/std/collections/hashmap/HashMapIterator.html#item.next"],["std::collections::hashmap::HashMapIterator::next_back"," Returns the next item from the back, if any.","/std/collections/hashmap/HashMapIterator.html#item.next_back"],["std::collections::hashmap::HashMapIterator::size_hint"," Returns the number of remaining elements, if available.","/std/collections/hashmap/HashMapIterator.html#item.size_hint"],["std::collections::hashmap::HashMapMutIterator::next"," Returns the next item, if any.","/std/collections/hashmap/HashMapMutIterator.html#item.next"],["std::collections::hashmap::HashMapMutIterator::next_back"," Returns the next item from the back, if any.","/std/collections/hashmap/HashMapMutIterator.html#item.next_back"],["std::collections::hashmap::HashMapMutIterator::size_hint"," Returns the number of remaining elements, if available.","/std/collections/hashmap/HashMapMutIterator.html#item.size_hint"],["std::collections::hashmap::HashMapRefIterator::next"," Returns the next item, if any.","/std/collections/hashmap/HashMapRefIterator.html#item.next"],["std::collections::hashmap::HashMapRefIterator::next_back"," Returns the next item from the back, if any.","/std/collections/hashmap/HashMapRefIterator.html#item.next_back"],["std::collections::hashmap::HashMapRefIterator::size_hint"," Returns the number of remaining elements, if available.","/std/collections/hashmap/HashMapRefIterator.html#item.size_hint"],["std::collections::hashmap::State::Vacant","","/std/collections/hashmap/State.html#item.Vacant"],["std::collections::hashmap::State::Occupied","","/std/collections/hashmap/State.html#item.Occupied"],["std::collections::hashmap::State::Deleted","","/std/collections/hashmap/State.html#item.Deleted"],["std::collections::hashmap::tests::DummyHasher","","/std/collections/hashmap/tests/DummyHasher.html"],["std::collections::hashmap::tests::test_hashmap_new","","/std/collections/hashmap/tests/#item.test_hashmap_new"],["std::collections::hashmap::tests::test_hashmap_insert","","/std/collections/hashmap/tests/#item.test_hashmap_insert"],["std::collections::hashmap::tests::test_hashmap_get","","/std/collections/hashmap/tests/#item.test_hashmap_get"],["std::collections::hashmap::tests::test_hashmap_get_mut","","/std/collections/hashmap/tests/#item.test_hashmap_get_mut"],["std::collections::hashmap::tests::test_hashmap_remove","","/std/collections/hashmap/tests/#item.test_hashmap_remove"],["std::collections::hashmap::tests::test_hashmap_len","","/std/collections/hashmap/tests/#item.test_hashmap_len"],["std::collections::hashmap::tests::test_hashmap_empty","","/std/collections/hashmap/tests/#item.test_hashmap_empty"],["std::collections::hashmap::tests::test_hashmap_clear","","/std/collections/hashmap/tests/#item.test_hashmap_clear"],["std::collections::hashmap::tests::test_hashmap_iter","","/std/collections/hashmap/tests/#item.test_hashmap_iter"],["std::collections::hashmap::tests::test_hashmap_iter_ref","","/std/collections/hashmap/tests/#item.test_hashmap_iter_ref"],["std::collections::hashmap::tests::test_hashmap_iter_mut","","/std/collections/hashmap/tests/#item.test_hashmap_iter_mut"],["std::collections::hashmap::tests::test_reserve","","/std/collections/hashmap/tests/#item.test_reserve"],["std::collections::hashmap::tests::test_hashmap_from_iter","","/std/collections/hashmap/tests/#item.test_hashmap_from_iter"],["std::collections::hashmap::tests::test_hashmap_extend","","/std/collections/hashmap/tests/#item.test_hashmap_extend"],["std::collections::hashmap::tests::test_hashmap_move","","/std/collections/hashmap/tests/#item.test_hashmap_move"],["std::collections::hashmap::tests::DummyHasher::new","","/std/collections/hashmap/tests/DummyHasher.html#item.new"],["std::collections::hashmap::tests::DummyHasher::write","","/std/collections/hashmap/tests/DummyHasher.html#item.write"],["std::collections::hashmap::tests::DummyHasher::finish","","/std/collections/hashmap/tests/DummyHasher.html#item.finish"],["std::collections::hashset::tests","","/std/collections/hashset/tests/"],["std::collections::hashset::HashSet"," A hash-based set collection.","/std/collections/hashset/HashSet.html"],["std::collections::hashset::HashSetIterator"," Iterator over the values in the hashset","/std/collections/hashset/HashSetIterator.html"],["std::collections::hashset::HashSetRefIterator"," Iterator over the pointers to the values in the hashset","/std/collections/hashset/HashSetRefIterator.html"],["std::collections::hashset::HashSet::new"," Creates an empty set","/std/collections/hashset/HashSet.html#item.new"],["std::collections::hashset::HashSet::with_capacity"," Creates an empty set that can store up to `capacity` items without","/std/collections/hashset/HashSet.html#item.with_capacity"],["std::collections::hashset::HashSet::with_size"," Creates a set with a specific number of buckets.","/std/collections/hashset/HashSet.html#item.with_size"],["std::collections::hashset::HashSet::reserve"," Reserves space for at least `additional` more elements to be inserted without","/std/collections/hashset/HashSet.html#item.reserve"],["std::collections::hashset::HashSet::rehash"," Resizes the underlying array to exactly the given `new_capacity`.","/std/collections/hashset/HashSet.html#item.rehash"],["std::collections::hashset::HashSet::shrink_to_fit"," Reduces the size of underlying storage to fit the contained elements if needed.","/std/collections/hashset/HashSet.html#item.shrink_to_fit"],["std::collections::hashset::HashSet::insert"," Inserts a value into the set.","/std/collections/hashset/HashSet.html#item.insert"],["std::collections::hashset::HashSet::remove"," Removes a value from the set.","/std/collections/hashset/HashSet.html#item.remove"],["std::collections::hashset::HashSet::contains"," Retreives `true` if the set contains the given value, `false` otherwise.","/std/collections/hashset/HashSet.html#item.contains"],["std::collections::hashset::HashSet::len"," Retreives the number of elements in the set.","/std/collections/hashset/HashSet.html#item.len"],["std::collections::hashset::HashSet::is_empty"," Returns `true` if the set is empty, `false` otherwise.","/std/collections/hashset/HashSet.html#item.is_empty"],["std::collections::hashset::HashSet::clear"," Clears the set, removing all values.","/std/collections/hashset/HashSet.html#item.clear"],["std::collections::hashset::HashSet::iter"," Returns an iterator over the elements of this iterable.","/std/collections/hashset/HashSet.html#item.iter"],["std::collections::hashset::HashSet::iter_ref"," Returns an iterator over the pointers of the items of the collection.","/std/collections/hashset/HashSet.html#item.iter_ref"],["std::collections::hashset::HashSet::retain"," Removes the elements not mathing the given predicate.","/std/collections/hashset/HashSet.html#item.retain"],["std::collections::hashset::HashSet::free"," Frees the memory backing the object.","/std/collections/hashset/HashSet.html#item.free"],["std::collections::hashset::HashSet::move"," Creates a copy of the object, leaving an inert object behind.","/std/collections/hashset/HashSet.html#item.move"],["std::collections::hashset::HashSet::clone"," Returns a copy of the object.","/std/collections/hashset/HashSet.html#item.clone"],["std::collections::hashset::HashSet::from_iter"," Creates a hash map from an iterator of key-value pairs","/std/collections/hashset/HashSet.html#item.from_iter"],["std::collections::hashset::HashSet::extend"," Inserts additional elements into the set from an iterator","/std/collections/hashset/HashSet.html#item.extend"],["std::collections::hashset::HashSetIterator::next"," Returns the next item, if any.","/std/collections/hashset/HashSetIterator.html#item.next"],["std::collections::hashset::HashSetIterator::next_back"," Returns the next item from the back, if any.","/std/collections/hashset/HashSetIterator.html#item.next_back"],["std::collections::hashset::HashSetIterator::size_hint"," Returns the number of remaining elements, if available.","/std/collections/hashset/HashSetIterator.html#item.size_hint"],["std::collections::hashset::HashSetRefIterator::next"," Returns the next item, if any.","/std/collections/hashset/HashSetRefIterator.html#item.next"],["std::collections::hashset::HashSetRefIterator::next_back"," Returns the next item from the back, if any.","/std/collections/hashset/HashSetRefIterator.html#item.next_back"],["std::collections::hashset::HashSetRefIterator::size_hint"," Returns the number of remaining elements, if available.","/std/collections/hashset/HashSetRefIterator.html#item.size_hint"],["std::collections::hashset::tests::test_hashset_new","","/std/collections/hashset/tests/#item.test_hashset_new"],["std::collections::hashset::tests::test_hashset_with_capacity","","/std/collections/hashset/tests/#item.test_hashset_with_capacity"],["std::collections::hashset::tests::test_hashset_insert","","/std/collections/hashset/tests/#item.test_hashset_insert"],["std::collections::hashset::tests::test_hashset_remove","","/std/collections/hashset/tests/#item.test_hashset_remove"],["std::collections::hashset::tests::test_hashset_contains","","/std/collections/hashset/tests/#item.test_hashset_contains"],["std::collections::hashset::tests::test_hashset_len","","/std/collections/hashset/tests/#item.test_hashset_len"],["std::collections::hashset::tests::test_hashset_empty","","/std/collections/hashset/tests/#item.test_hashset_empty"],["std::collections::hashset::tests::test_hashset_clear","","/std/collections/hashset/tests/#item.test_hashset_clear"],["std::collections::hashset::tests::test_hashset_iter","","/std/collections/hashset/tests/#item.test_hashset_iter"],["std::collections::hashset::tests::test_hashset_iter_ref","","/std/collections/hashset/tests/#item.test_hashset_iter_ref"],["std::collections::hashset::tests::test_hashset_move","","/std/collections/hashset/tests/#item.test_hashset_move"],["std::collections::hashset::tests::test_hashset_from_iter","","/std/collections/hashset/tests/#item.test_hashset_from_iter"],["std::collections::hashset::tests::test_hashset_extend","","/std/collections/hashset/tests/#item.test_hashset_extend"],["std::collections::tests::test_free_all","","/std/collections/tests/#item.test_free_all"],["std::collections::vector::tests","","/std/collections/vector/tests/"],["std::collections::vector::Vector"," Growable heap-allocated array.","/std/collections/vector/Vector.html"],["std::collections::vector::Vector::new"," Create an empty vector","/std/collections/vector/Vector.html#item.new"],["std::collections::vector::Vector::from_raw"," Create a vector from a raw slice and a length.","/std/collections/vector/Vector.html#item.from_raw"],["std::collections::vector::Vector::with_capacity"," Create a vector that can hold up to `capacity` elements without reallocating.","/std/collections/vector/Vector.html#item.with_capacity"],["std::collections::vector::Vector::from_slice"," Create a vector from a slice, copying the elements.","/std/collections/vector/Vector.html#item.from_slice"],["std::collections::vector::Vector::from_iter"," Create a vector from an iterator.","/std/collections/vector/Vector.html#item.from_iter"],["std::collections::vector::Vector::reserve"," Reserve capacity for at least `additional` elements.","/std/collections/vector/Vector.html#item.reserve"],["std::collections::vector::Vector::extend_from_slice"," Extend the vector with the elements from a slice.","/std/collections/vector/Vector.html#item.extend_from_slice"],["std::collections::vector::Vector::extend"," Extend the vector with the elements from an iterator.","/std/collections/vector/Vector.html#item.extend"],["std::collections::vector::Vector::insert"," Insert an element at the given index, shifting all elements after it.","/std/collections/vector/Vector.html#item.insert"],["std::collections::vector::Vector::get"," Get the element at the given index.","/std/collections/vector/Vector.html#item.get"],["std::collections::vector::Vector::as_slice"," View the vector as a slice.","/std/collections/vector/Vector.html#item.as_slice"],["std::collections::vector::Vector::as_slice_mut"," View the vector as a mutable slice.","/std/collections/vector/Vector.html#item.as_slice_mut"],["std::collections::vector::Vector::push"," Push an element to the end of the vector.","/std/collections/vector/Vector.html#item.push"],["std::collections::vector::Vector::pop"," Pop an element from the end of the vector.","/std/collections/vector/Vector.html#item.pop"],["std::collections::vector::Vector::remove"," Remove an element at the given index, shifting all elements after it.","/std/collections/vector/Vector.html#item.remove"],["std::collections::vector::Vector::len"," Return the length of the vector.","/std/collections/vector/Vector.html#item.len"],["std::collections::vector::Vector::capacity"," Return the size of the underlying buffer.","/std/collections/vector/Vector.html#item.capacity"],["std::collections::vector::Vector::spare_capacity"," Returns a region of memory \"after the last element\".","/std/collections/vector/Vector.html#item.spare_capacity"],["std::collections::vector::Vector::is_empty"," Returns `true` if the vector is empty, `false` otherwise.","/std/collections/vector/Vector.html#item.is_empty"],["std::collections::vector::Vector::clear"," Clear the vector, removing all elements.","/std/collections/vector/Vector.html#item.clear"],["std::collections::vector::Vector::truncate"," Truncate the vector, removing all but the first `new_size` elements.","/std/collections/vector/Vector.html#item.truncate"],["std::collections::vector::Vector::retain"," Removes the elements not mathing the given predicate.","/std/collections/vector/Vector.html#item.retain"],["std::collections::vector::Vector::iter"," Returns an iterator over the vector.","/std/collections/vector/Vector.html#item.iter"],["std::collections::vector::Vector::iter_ref"," Returns an iterator over the pointers to the elements.","/std/collections/vector/Vector.html#item.iter_ref"],["std::collections::vector::Vector::iter_mut"," Returns an iterator over the mutable pointers to the elements.","/std/collections/vector/Vector.html#item.iter_mut"],["std::collections::vector::Vector::shrink_to_fit"," Shrink the underlying buffer to the length of the vector.","/std/collections/vector/Vector.html#item.shrink_to_fit"],["std::collections::vector::Vector::free"," Frees the memory backing the object.","/std/collections/vector/Vector.html#item.free"],["std::collections::vector::Vector::move"," Creates a copy of the object, leaving an inert object behind.","/std/collections/vector/Vector.html#item.move"],["std::collections::vector::Vector::clone"," Create a shallow copy of the vector.","/std/collections/vector/Vector.html#item.clone"],["std::collections::vector::Vector::write_str"," Write a string","/std/collections/vector/Vector.html#item.write_str"],["std::collections::vector::Vector::write_char"," Write a single character","/std/collections/vector/Vector.html#item.write_char"],["std::collections::vector::Vector::fmt"," Write the object into a given formatter.","/std/collections/vector/Vector.html#item.fmt"],["std::collections::vector::tests::test_vector_new","","/std/collections/vector/tests/#item.test_vector_new"],["std::collections::vector::tests::test_vector_from_slice","","/std/collections/vector/tests/#item.test_vector_from_slice"],["std::collections::vector::tests::test_vector_from_iter","","/std/collections/vector/tests/#item.test_vector_from_iter"],["std::collections::vector::tests::test_vector_reserve","","/std/collections/vector/tests/#item.test_vector_reserve"],["std::collections::vector::tests::test_vector_extend_from_slice","","/std/collections/vector/tests/#item.test_vector_extend_from_slice"],["std::collections::vector::tests::test_vector_extend","","/std/collections/vector/tests/#item.test_vector_extend"],["std::collections::vector::tests::test_vector_insert","","/std/collections/vector/tests/#item.test_vector_insert"],["std::collections::vector::tests::test_vector_as_slice","","/std/collections/vector/tests/#item.test_vector_as_slice"],["std::collections::vector::tests::test_vector_as_slice_mut","","/std/collections/vector/tests/#item.test_vector_as_slice_mut"],["std::collections::vector::tests::test_vector_push","","/std/collections/vector/tests/#item.test_vector_push"],["std::collections::vector::tests::test_vector_pop","","/std/collections/vector/tests/#item.test_vector_pop"],["std::collections::vector::tests::test_vector_remove","","/std/collections/vector/tests/#item.test_vector_remove"],["std::collections::vector::tests::test_vector_clear","","/std/collections/vector/tests/#item.test_vector_clear"],["std::collections::vector::tests::test_vector_get","","/std/collections/vector/tests/#item.test_vector_get"],["std::collections::vector::tests::test_vector_move","","/std/collections/vector/tests/#item.test_vector_move"],["std::collections::vector::tests::test_iter_ref","","/std/collections/vector/tests/#item.test_iter_ref"],["std::collections::vector::tests::test_iter_mut","","/std/collections/vector/tests/#item.test_iter_mut"],["std::collections::vector::tests::test_retain","","/std/collections/vector/tests/#item.test_retain"],["std::ffi::tests","","/std/ffi/tests/"],["std::ffi::CString"," A wrapper for a null-terminated (C) string.","/std/ffi/CString.html"],["std::ffi::c_str"," Compile-time null-terminated string.","/std/ffi/c_str.html"],["std::ffi::CString::from_slice"," Create a new CString from a string slice","/std/ffi/CString.html#item.from_slice"],["std::ffi::CString::from_raw"," Create a CString from a raw pointer to a null-terminated string.","/std/ffi/CString.html#item.from_raw"],["std::ffi::CString::null"," A null C string.","/std/ffi/CString.html#item.null"],["std::ffi::CString::len"," Returns the length of the string.","/std/ffi/CString.html#item.len"],["std::ffi::CString::as_slice"," Returns the string slice.","/std/ffi/CString.html#item.as_slice"],["std::ffi::CString::free"," Frees the memory backing the object.","/std/ffi/CString.html#item.free"],["std::ffi::CString::clone"," Returns a copy of the object.","/std/ffi/CString.html#item.clone"],["std::ffi::CString::move"," Creates a copy of the object, leaving an inert object behind.","/std/ffi/CString.html#item.move"],["std::ffi::tests::test_cstring","","/std/ffi/tests/#item.test_cstring"],["std::ffi::tests::test_cstring_clone","","/std/ffi/tests/#item.test_cstring_clone"],["std::fmt::internal","","/std/fmt/internal/"],["std::fmt::tests","","/std/fmt/tests/"],["std::fmt::Formatter"," A sink for string formatting operations","/std/fmt/Formatter.html"],["std::fmt::Formattable"," Types that can be formatted. This is the standard way to implement custom","/std/fmt/Formattable.html"],["std::fmt::Error"," Error that can occur during a string formatting operation.","/std/fmt/Error.html"],["std::fmt::SliceFormatter"," Formatter that writes into a string slice.","/std/fmt/SliceFormatter.html"],["std::fmt::NullFormatter"," A formatter that discards output.","/std/fmt/NullFormatter.html"],["std::fmt::StreamFormatter"," Adapter for writting formatted data into a stream","/std/fmt/StreamFormatter.html"],["std::fmt::hex"," Write value as a hexadecimal number","/std/fmt/#item.hex"],["std::fmt::bin"," Write value as a binary number","/std/fmt/#item.bin"],["std::fmt::oct"," Write value as an octal number","/std/fmt/#item.oct"],["std::fmt::zero_pad"," Pads number with zeros on the left.","/std/fmt/#item.zero_pad"],["std::fmt::precision","","/std/fmt/#item.precision"],["std::fmt::repeat"," Repeats value `times` times.","/std/fmt/#item.repeat"],["std::fmt::pad_with"," Pads arbitrary formattable value on the left with a specified character.","/std/fmt/#item.pad_with"],["std::fmt::Result","","/std/fmt/#item.Result"],["std::fmt::format_args"," Constructs an array of pieces from a format string and arguments.","/std/fmt/format_args.html"],["std::fmt::write"," Write a formatted string into a given formatter.","/std/fmt/write.html"],["std::fmt::writeln"," Write a formatted string and a newline into a given formatter.","/std/fmt/writeln.html"],["std::fmt::format"," Format a string into a `StringBuf`.","/std/fmt/format.html"],["std::fmt::format_in"," Format a string into a preexisting buffer.","/std/fmt/format_in.html"],["std::fmt::Error::new","","/std/fmt/Error.html#item.new"],["std::fmt::Error::fmt"," Write the object into a given formatter.","/std/fmt/Error.html#item.fmt"],["std::fmt::Error::from","","/std/fmt/Error.html#item.from"],["std::fmt::Formattable::fmt"," Write the object into a given formatter.","/std/fmt/Formattable.html#item.fmt"],["std::fmt::Formatter::write_str"," Write a string","/std/fmt/Formatter.html#item.write_str"],["std::fmt::Formatter::write_char"," Write a single character","/std/fmt/Formatter.html#item.write_char"],["std::fmt::NullFormatter::write_str"," Write a string","/std/fmt/NullFormatter.html#item.write_str"],["std::fmt::NullFormatter::write_char"," Write a single character","/std/fmt/NullFormatter.html#item.write_char"],["std::fmt::SliceFormatter::new","","/std/fmt/SliceFormatter.html#item.new"],["std::fmt::SliceFormatter::write_str"," Write a string","/std/fmt/SliceFormatter.html#item.write_str"],["std::fmt::SliceFormatter::write_char"," Write a single character","/std/fmt/SliceFormatter.html#item.write_char"],["std::fmt::SliceFormatter::get"," Get the resulting string","/std/fmt/SliceFormatter.html#item.get"],["std::fmt::StreamFormatter::new","","/std/fmt/StreamFormatter.html#item.new"],["std::fmt::StreamFormatter::write_str"," Write a string","/std/fmt/StreamFormatter.html#item.write_str"],["std::fmt::StreamFormatter::write_char"," Write a single character","/std/fmt/StreamFormatter.html#item.write_char"],["std::fmt::internal::NumFormatAdapter","","/std/fmt/internal/NumFormatAdapter.html"],["std::fmt::internal::FloatFormatAdapter","","/std/fmt/internal/FloatFormatAdapter.html"],["std::fmt::internal::RepeatAdapter","","/std/fmt/internal/RepeatAdapter.html"],["std::fmt::internal::GenericPadAdapter","","/std/fmt/internal/GenericPadAdapter.html"],["std::fmt::internal::format_arg"," Returns a type-erased wrapper around a formattable object.","/std/fmt/internal/#item.format_arg"],["std::fmt::internal::format_integer","","/std/fmt/internal/#item.format_integer"],["std::fmt::internal::format_float","","/std/fmt/internal/#item.format_float"],["std::fmt::internal::write_fmt","","/std/fmt/internal/#item.write_fmt"],["std::fmt::internal::FloatFormatAdapter::fmt","","/std/fmt/internal/FloatFormatAdapter.html#item.fmt"],["std::fmt::internal::GenericPadAdapter::fmt","","/std/fmt/internal/GenericPadAdapter.html#item.fmt"],["std::fmt::internal::NumFormatAdapter::fmt","","/std/fmt/internal/NumFormatAdapter.html#item.fmt"],["std::fmt::internal::NumFormatAdapter::hex","","/std/fmt/internal/NumFormatAdapter.html#item.hex"],["std::fmt::internal::NumFormatAdapter::oct","","/std/fmt/internal/NumFormatAdapter.html#item.oct"],["std::fmt::internal::NumFormatAdapter::bin","","/std/fmt/internal/NumFormatAdapter.html#item.bin"],["std::fmt::internal::NumFormatAdapter::zero_pad","","/std/fmt/internal/NumFormatAdapter.html#item.zero_pad"],["std::fmt::internal::RepeatAdapter::fmt","","/std/fmt/internal/RepeatAdapter.html#item.fmt"],["std::fmt::tests::test_format_integer","","/std/fmt/tests/#item.test_format_integer"],["std::fmt::tests::test_format_radix","","/std/fmt/tests/#item.test_format_radix"],["std::fmt::tests::test_format_zero_pad","","/std/fmt/tests/#item.test_format_zero_pad"],["std::fmt::tests::test_format_radix_and_pad","","/std/fmt/tests/#item.test_format_radix_and_pad"],["std::fmt::tests::test_format_repeat","","/std/fmt/tests/#item.test_format_repeat"],["std::fmt::tests::test_format_generic_pad","","/std/fmt/tests/#item.test_format_generic_pad"],["std::fmt::tests::test_format_float","","/std/fmt/tests/#item.test_format_float"],["std::fmt::tests::test_format_args","","/std/fmt/tests/#item.test_format_args"],["std::fmt::tests::fmt","","/std/fmt/tests/fmt.html"],["std::fmt::tests::BUF","","/std/fmt/tests/#item.BUF"],["std::fs::unix","","/std/fs/unix/"],["std::fs::tests","","/std/fs/tests/"],["std::fs::OpenOptions"," Options for how the file should be opened.","/std/fs/OpenOptions.html"],["std::fs::PathSegment"," A filesystem path segment","/std/fs/PathSegment.html"],["std::fs::PathIterator"," Iterator over the segments of a path","/std/fs/PathIterator.html"],["std::fs::DirBuilder"," Utility for creating directories.","/std/fs/DirBuilder.html"],["std::fs::Path"," A filesystem path","/std/fs/Path.html"],["std::fs::File"," A file.","/std/fs/File.html"],["std::fs::PathBuf"," An owned path buffer","/std/fs/PathBuf.html"],["std::fs::DirIterator"," Iterator over the items in a directory","/std/fs/DirIterator.html"],["std::fs::DirEntry"," Directory entry","/std/fs/DirEntry.html"],["std::fs::FileAttr"," File attributes (`stat`)","/std/fs/FileAttr.html"],["std::fs::create_directory"," Create an empty directory","/std/fs/#item.create_directory"],["std::fs::remove_file"," Remove a file","/std/fs/#item.remove_file"],["std::fs::remove_directory"," Remove an empty directory","/std/fs/#item.remove_directory"],["std::fs::read_directory"," Returns iterator over the items in a directory.","/std/fs/#item.read_directory"],["std::fs::canonicalize"," Returns a canonical absolute path for the given path.","/std/fs/#item.canonicalize"],["std::fs::PathSegmentKind"," Type of the path segment","/std/fs/PathSegmentKind.html"],["std::fs::FileType"," Type of the file (regular file, symlink, directory, ...)","/std/fs/FileType.html"],["std::fs::DirBuilder::new","","/std/fs/DirBuilder.html#item.new"],["std::fs::DirBuilder::recursive"," Sets whether to create a recursive directory structure.","/std/fs/DirBuilder.html#item.recursive"],["std::fs::DirBuilder::mode"," Sets the mode for creation.","/std/fs/DirBuilder.html#item.mode"],["std::fs::DirBuilder::create"," Create the directory (or directory tree) specified by `path`.","/std/fs/DirBuilder.html#item.create"],["std::fs::DirEntry::name"," Return the name of the item in directory","/std/fs/DirEntry.html#item.name"],["std::fs::DirEntry::file_type"," Returns the file type","/std/fs/DirEntry.html#item.file_type"],["std::fs::DirIterator::next"," Returns the next item, if any.","/std/fs/DirIterator.html#item.next"],["std::fs::DirIterator::close"," Closes the file descriptor associated with the iterator.","/std/fs/DirIterator.html#item.close"],["std::fs::File::open"," Opens file in read-only mode.","/std/fs/File.html#item.open"],["std::fs::File::create"," Creates a new file for writing (truncating it if it already exists).","/std/fs/File.html#item.create"],["std::fs::File::open_with"," Opens file with custom options.","/std/fs/File.html#item.open_with"],["std::fs::File::attributes"," Returns the file attributes (`stat`) for the file","/std/fs/File.html#item.attributes"],["std::fs::File::from_fd"," Create a file object from an existing file descriptor.","/std/fs/File.html#item.from_fd"],["std::fs::File::as_fd"," Get the file descriptor for the file.","/std/fs/File.html#item.as_fd"],["std::fs::File::read_to_string"," Read the entire file into a [std::string::StringBuf].","/std/fs/File.html#item.read_to_string"],["std::fs::File::seek"," Jump to a specified position in the stream.","/std/fs/File.html#item.seek"],["std::fs::File::flush"," Flush the stream","/std/fs/File.html#item.flush"],["std::fs::File::sync"," Flushes disk buffers to disk (`fsync`)","/std/fs/File.html#item.sync"],["std::fs::File::close"," Closes the file.","/std/fs/File.html#item.close"],["std::fs::File::move"," Creates a copy of the object, leaving an inert object behind.","/std/fs/File.html#item.move"],["std::fs::FileAttr::from_path"," Returns file attributes for a path.","/std/fs/FileAttr.html#item.from_path"],["std::fs::FileAttr::file_type"," Returns file type.","/std/fs/FileAttr.html#item.file_type"],["std::fs::FileAttr::size"," Returns the size of the file, in bytes.","/std/fs/FileAttr.html#item.size"],["std::fs::FileType::Fifo","","/std/fs/FileType.html#item.Fifo"],["std::fs::FileType::CharacterDevice","","/std/fs/FileType.html#item.CharacterDevice"],["std::fs::FileType::Directory","","/std/fs/FileType.html#item.Directory"],["std::fs::FileType::BlockDevice","","/std/fs/FileType.html#item.BlockDevice"],["std::fs::FileType::Regular","","/std/fs/FileType.html#item.Regular"],["std::fs::FileType::Link","","/std/fs/FileType.html#item.Link"],["std::fs::FileType::Socket","","/std/fs/FileType.html#item.Socket"],["std::fs::FileType::Unknown","","/std/fs/FileType.html#item.Unknown"],["std::fs::FileType::fmt"," Write the object into a given formatter.","/std/fs/FileType.html#item.fmt"],["std::fs::FileType::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/fs/FileType.html#item.equals"],["std::fs::FileType::hash"," Update hasher state with the contents of this object.","/std/fs/FileType.html#item.hash"],["std::fs::OpenOptions::new","","/std/fs/OpenOptions.html#item.new"],["std::fs::OpenOptions::read"," Sets the option for read access.","/std/fs/OpenOptions.html#item.read"],["std::fs::OpenOptions::write"," Sets the option for write access.","/std/fs/OpenOptions.html#item.write"],["std::fs::OpenOptions::append"," Sets the option for append access.","/std/fs/OpenOptions.html#item.append"],["std::fs::OpenOptions::truncate"," Sets the option for truncate access.","/std/fs/OpenOptions.html#item.truncate"],["std::fs::OpenOptions::create"," Sets the option for create access.","/std/fs/OpenOptions.html#item.create"],["std::fs::OpenOptions::create_new"," Sets the option for create new access.","/std/fs/OpenOptions.html#item.create_new"],["std::fs::OpenOptions::custom_flags"," Sets the custom flags.","/std/fs/OpenOptions.html#item.custom_flags"],["std::fs::OpenOptions::mode"," Sets the mode for creation.","/std/fs/OpenOptions.html#item.mode"],["std::fs::OpenOptions::get_access_mode","","/std/fs/OpenOptions.html#item.get_access_mode"],["std::fs::OpenOptions::get_creation_mode","","/std/fs/OpenOptions.html#item.get_creation_mode"],["std::fs::Path::new"," Create a path from a string slice","/std/fs/Path.html#item.new"],["std::fs::Path::iter"," Returns an iterator over the elements of this iterable.","/std/fs/Path.html#item.iter"],["std::fs::Path::as_slice"," View path as a string slice","/std/fs/Path.html#item.as_slice"],["std::fs::Path::is_absolute"," Returns true if the path is absolute, false otherwise","/std/fs/Path.html#item.is_absolute"],["std::fs::Path::is_relative"," Returns true if the path is relative, false otherwise","/std/fs/Path.html#item.is_relative"],["std::fs::Path::parent"," Returns the parent path of the path","/std/fs/Path.html#item.parent"],["std::fs::Path::strip_prefix"," Strips the prefix from the path.","/std/fs/Path.html#item.strip_prefix"],["std::fs::Path::starts_with"," Returns true if `other` is a prefix of the current path, false otherwise","/std/fs/Path.html#item.starts_with"],["std::fs::Path::fmt"," Write the object into a given formatter.","/std/fs/Path.html#item.fmt"],["std::fs::Path::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/fs/Path.html#item.equals"],["std::fs::PathBuf::new"," Create a new empty path buffer","/std/fs/PathBuf.html#item.new"],["std::fs::PathBuf::from_path"," Create a new path buffer from a [Path] instance","/std/fs/PathBuf.html#item.from_path"],["std::fs::PathBuf::from_str"," Create a new path buffer from a string slice","/std/fs/PathBuf.html#item.from_str"],["std::fs::PathBuf::as_path"," View path as [Path] object","/std/fs/PathBuf.html#item.as_path"],["std::fs::PathBuf::extend"," Extend the path buffer from an iterator of path segments","/std/fs/PathBuf.html#item.extend"],["std::fs::PathBuf::with_suffix"," Create a new path buffer with the base path of `self` and","/std/fs/PathBuf.html#item.with_suffix"],["std::fs::PathBuf::push"," Extend the path buffer with a [Path] instance","/std/fs/PathBuf.html#item.push"],["std::fs::PathBuf::pop"," Pop the last path segment from the path buffer","/std/fs/PathBuf.html#item.pop"],["std::fs::PathBuf::from_iter"," Create a new path buffer from an iterator of path segments","/std/fs/PathBuf.html#item.from_iter"],["std::fs::PathBuf::fmt"," Write the object into a given formatter.","/std/fs/PathBuf.html#item.fmt"],["std::fs::PathBuf::clone"," Returns a copy of the object.","/std/fs/PathBuf.html#item.clone"],["std::fs::PathBuf::free"," Frees the memory backing the object.","/std/fs/PathBuf.html#item.free"],["std::fs::PathBuf::move"," Creates a copy of the object, leaving an inert object behind.","/std/fs/PathBuf.html#item.move"],["std::fs::PathIterator::next"," Returns the next item, if any.","/std/fs/PathIterator.html#item.next"],["std::fs::PathSegment::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/fs/PathSegment.html#item.equals"],["std::fs::PathSegment::fmt"," Write the object into a given formatter.","/std/fs/PathSegment.html#item.fmt"],["std::fs::PathSegmentKind::Root","","/std/fs/PathSegmentKind.html#item.Root"],["std::fs::PathSegmentKind::Normal","","/std/fs/PathSegmentKind.html#item.Normal"],["std::fs::PathSegmentKind::CurDir","","/std/fs/PathSegmentKind.html#item.CurDir"],["std::fs::PathSegmentKind::ParentDir","","/std/fs/PathSegmentKind.html#item.ParentDir"],["std::fs::PathSegmentKind::equals","","/std/fs/PathSegmentKind.html#item.equals"],["std::fs::PathSegmentKind::fmt","","/std/fs/PathSegmentKind.html#item.fmt"],["std::fs::tests::test_path_iter","","/std/fs/tests/#item.test_path_iter"],["std::fs::tests::test_path_fmt","","/std/fs/tests/#item.test_path_fmt"],["std::fs::tests::test_is_absolute","","/std/fs/tests/#item.test_is_absolute"],["std::fs::tests::test_strip_prefix","","/std/fs/tests/#item.test_strip_prefix"],["std::fs::tests::test_from_iter","","/std/fs/tests/#item.test_from_iter"],["std::fs::tests::test_push_pop","","/std/fs/tests/#item.test_push_pop"],["std::fs::tests::test_parent","","/std/fs/tests/#item.test_parent"],["std::fs::unix::tests","","/std/fs/unix/tests/"],["std::fs::unix::OpenOptions"," Options for how the file should be opened.","/std/fs/unix/OpenOptions.html"],["std::fs::unix::DirBuilder"," Utility for creating directories.","/std/fs/unix/DirBuilder.html"],["std::fs::unix::File"," A file.","/std/fs/unix/File.html"],["std::fs::unix::DirIterator"," Iterator over the items in a directory","/std/fs/unix/DirIterator.html"],["std::fs::unix::DirEntry"," Directory entry","/std/fs/unix/DirEntry.html"],["std::fs::unix::FileAttr"," File attributes (`stat`)","/std/fs/unix/FileAttr.html"],["std::fs::unix::create_directory"," Create an empty directory","/std/fs/unix/#item.create_directory"],["std::fs::unix::remove_file"," Remove a file","/std/fs/unix/#item.remove_file"],["std::fs::unix::remove_directory"," Remove an empty directory","/std/fs/unix/#item.remove_directory"],["std::fs::unix::read_directory"," Returns iterator over the items in a directory.","/std/fs/unix/#item.read_directory"],["std::fs::unix::canonicalize"," Returns a canonical absolute path for the given path.","/std/fs/unix/#item.canonicalize"],["std::fs::unix::FileType"," Type of the file (regular file, symlink, directory, ...)","/std/fs/unix/FileType.html"],["std::fs::unix::DirBuilder::new","","/std/fs/unix/DirBuilder.html#item.new"],["std::fs::unix::DirBuilder::recursive"," Sets whether to create a recursive directory structure.","/std/fs/unix/DirBuilder.html#item.recursive"],["std::fs::unix::DirBuilder::mode"," Sets the mode for creation.","/std/fs/unix/DirBuilder.html#item.mode"],["std::fs::unix::DirBuilder::create"," Create the directory (or directory tree) specified by `path`.","/std/fs/unix/DirBuilder.html#item.create"],["std::fs::unix::DirEntry::name"," Return the name of the item in directory","/std/fs/unix/DirEntry.html#item.name"],["std::fs::unix::DirEntry::file_type"," Returns the file type","/std/fs/unix/DirEntry.html#item.file_type"],["std::fs::unix::DirIterator::next"," Returns the next item, if any.","/std/fs/unix/DirIterator.html#item.next"],["std::fs::unix::DirIterator::close"," Closes the file descriptor associated with the iterator.","/std/fs/unix/DirIterator.html#item.close"],["std::fs::unix::File::open"," Opens file in read-only mode.","/std/fs/unix/File.html#item.open"],["std::fs::unix::File::create"," Creates a new file for writing (truncating it if it already exists).","/std/fs/unix/File.html#item.create"],["std::fs::unix::File::open_with"," Opens file with custom options.","/std/fs/unix/File.html#item.open_with"],["std::fs::unix::File::attributes"," Returns the file attributes (`stat`) for the file","/std/fs/unix/File.html#item.attributes"],["std::fs::unix::File::from_fd"," Create a file object from an existing file descriptor.","/std/fs/unix/File.html#item.from_fd"],["std::fs::unix::File::as_fd"," Get the file descriptor for the file.","/std/fs/unix/File.html#item.as_fd"],["std::fs::unix::File::read_to_string"," Read the entire file into a [std::string::StringBuf].","/std/fs/unix/File.html#item.read_to_string"],["std::fs::unix::File::seek"," Jump to a specified position in the stream.","/std/fs/unix/File.html#item.seek"],["std::fs::unix::File::flush"," Flush the stream","/std/fs/unix/File.html#item.flush"],["std::fs::unix::File::sync"," Flushes disk buffers to disk (`fsync`)","/std/fs/unix/File.html#item.sync"],["std::fs::unix::File::close"," Closes the file.","/std/fs/unix/File.html#item.close"],["std::fs::unix::File::move"," Creates a copy of the object, leaving an inert object behind.","/std/fs/unix/File.html#item.move"],["std::fs::unix::FileAttr::from_path"," Returns file attributes for a path.","/std/fs/unix/FileAttr.html#item.from_path"],["std::fs::unix::FileAttr::file_type"," Returns file type.","/std/fs/unix/FileAttr.html#item.file_type"],["std::fs::unix::FileAttr::size"," Returns the size of the file, in bytes.","/std/fs/unix/FileAttr.html#item.size"],["std::fs::unix::FileType::Fifo","","/std/fs/unix/FileType.html#item.Fifo"],["std::fs::unix::FileType::CharacterDevice","","/std/fs/unix/FileType.html#item.CharacterDevice"],["std::fs::unix::FileType::Directory","","/std/fs/unix/FileType.html#item.Directory"],["std::fs::unix::FileType::BlockDevice","","/std/fs/unix/FileType.html#item.BlockDevice"],["std::fs::unix::FileType::Regular","","/std/fs/unix/FileType.html#item.Regular"],["std::fs::unix::FileType::Link","","/std/fs/unix/FileType.html#item.Link"],["std::fs::unix::FileType::Socket","","/std/fs/unix/FileType.html#item.Socket"],["std::fs::unix::FileType::Unknown","","/std/fs/unix/FileType.html#item.Unknown"],["std::fs::unix::FileType::fmt"," Write the object into a given formatter.","/std/fs/unix/FileType.html#item.fmt"],["std::fs::unix::FileType::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/fs/unix/FileType.html#item.equals"],["std::fs::unix::FileType::hash"," Update hasher state with the contents of this object.","/std/fs/unix/FileType.html#item.hash"],["std::fs::unix::OpenOptions::new","","/std/fs/unix/OpenOptions.html#item.new"],["std::fs::unix::OpenOptions::read"," Sets the option for read access.","/std/fs/unix/OpenOptions.html#item.read"],["std::fs::unix::OpenOptions::write"," Sets the option for write access.","/std/fs/unix/OpenOptions.html#item.write"],["std::fs::unix::OpenOptions::append"," Sets the option for append access.","/std/fs/unix/OpenOptions.html#item.append"],["std::fs::unix::OpenOptions::truncate"," Sets the option for truncate access.","/std/fs/unix/OpenOptions.html#item.truncate"],["std::fs::unix::OpenOptions::create"," Sets the option for create access.","/std/fs/unix/OpenOptions.html#item.create"],["std::fs::unix::OpenOptions::create_new"," Sets the option for create new access.","/std/fs/unix/OpenOptions.html#item.create_new"],["std::fs::unix::OpenOptions::custom_flags"," Sets the custom flags.","/std/fs/unix/OpenOptions.html#item.custom_flags"],["std::fs::unix::OpenOptions::mode"," Sets the mode for creation.","/std/fs/unix/OpenOptions.html#item.mode"],["std::fs::unix::OpenOptions::get_access_mode","","/std/fs/unix/OpenOptions.html#item.get_access_mode"],["std::fs::unix::OpenOptions::get_creation_mode","","/std/fs/unix/OpenOptions.html#item.get_creation_mode"],["std::fs::unix::tests::mktemp","","/std/fs/unix/tests/#item.mktemp"],["std::fs::unix::tests::test_open","","/std/fs/unix/tests/#item.test_open"],["std::fs::unix::tests::test_read_directory","","/std/fs/unix/tests/#item.test_read_directory"],["std::fs::unix::tests::test_canonicalize","","/std/fs/unix/tests/#item.test_canonicalize"],["std::fs::unix::tests::test_create_remove_directory","","/std/fs/unix/tests/#item.test_create_remove_directory"],["std::fs::unix::tests::test_remove_file","","/std/fs/unix/tests/#item.test_remove_file"],["std::fs::unix::tests::BUF","","/std/fs/unix/tests/#item.BUF"],["std::fs::unix::tests::BUF1","","/std/fs/unix/tests/#item.BUF1"],["std::hash::xxhash","","/std/hash/xxhash/"],["std::hash::Hasher"," Hashing algorithms.","/std/hash/Hasher.html"],["std::hash::Hashable"," Types that can be hashed.","/std/hash/Hashable.html"],["std::hash::hash_of"," Calculate the hash of a value.","/std/hash/#item.hash_of"],["std::hash::DefaultHash"," The default hashing algorithm used for hash-based collections if none is specified.","/std/hash/#item.DefaultHash"],["std::hash::Hashable::hash"," Update hasher state with the contents of this object.","/std/hash/Hashable.html#item.hash"],["std::hash::Hasher::new"," Create a new hasher.","/std/hash/Hasher.html#item.new"],["std::hash::Hasher::write"," Write a byte slice into a hasher.","/std/hash/Hasher.html#item.write"],["std::hash::Hasher::finish"," Finalize the hashing and return the hash value.","/std/hash/Hasher.html#item.finish"],["std::hash::xxhash::tests","","/std/hash/xxhash/tests/"],["std::hash::xxhash::Xxh64"," 64-bit version of xxHash (XXH64)","/std/hash/xxhash/Xxh64.html"],["std::hash::xxhash::round","","/std/hash/xxhash/#item.round"],["std::hash::xxhash::merge_round","","/std/hash/xxhash/#item.merge_round"],["std::hash::xxhash::avalanche","","/std/hash/xxhash/#item.avalanche"],["std::hash::xxhash::CHUNK_SIZE","","/std/hash/xxhash/#item.CHUNK_SIZE"],["std::hash::xxhash::PRIME_1","","/std/hash/xxhash/#item.PRIME_1"],["std::hash::xxhash::PRIME_2","","/std/hash/xxhash/#item.PRIME_2"],["std::hash::xxhash::PRIME_3","","/std/hash/xxhash/#item.PRIME_3"],["std::hash::xxhash::PRIME_4","","/std/hash/xxhash/#item.PRIME_4"],["std::hash::xxhash::PRIME_5","","/std/hash/xxhash/#item.PRIME_5"],["std::hash::xxhash::Xxh64::new","","/std/hash/xxhash/Xxh64.html#item.new"],["std::hash::xxhash::Xxh64::with_seed","","/std/hash/xxhash/Xxh64.html#item.with_seed"],["std::hash::xxhash::Xxh64::write","","/std/hash/xxhash/Xxh64.html#item.write"],["std::hash::xxhash::Xxh64::finish","","/std/hash/xxhash/Xxh64.html#item.finish"],["std::hash::xxhash::tests::test_chunks_dont_matter","","/std/hash/xxhash/tests/#item.test_chunks_dont_matter"],["std::hash::xxhash::tests::test_xxh64","","/std/hash/xxhash/tests/#item.test_xxh64"],["std::internal::assert_eq","","/std/internal/#item.assert_eq"],["std::internal::assert_ne","","/std/internal/#item.assert_ne"],["std::internal::expect","","/std/internal/#item.expect"],["std::intrinsics::compile_fail"," Fail the compilation process with a human-readable message.","/std/intrinsics/#item.compile_fail"],["std::intrinsics::compile_warn"," Emit a warning message during compilation.","/std/intrinsics/#item.compile_warn"],["std::intrinsics::compile_note"," Emit a note during compilation.","/std/intrinsics/#item.compile_note"],["std::intrinsics::unreachable"," Unreachable code","/std/intrinsics/#item.unreachable"],["std::intrinsics::trap"," Trigger a trap (e.g. through an invalid instruction).","/std/intrinsics/#item.trap"],["std::intrinsics::size_of"," Size of type in bytes","/std/intrinsics/#item.size_of"],["std::intrinsics::array_length_of"," Length of a fixed-size array","/std/intrinsics/#item.array_length_of"],["std::intrinsics::type_id"," Unique type identifier","/std/intrinsics/#item.type_id"],["std::intrinsics::type_name"," Name of a type","/std/intrinsics/#item.type_name"],["std::intrinsics::align_of"," Minimum alignment of a type in bytes.","/std/intrinsics/#item.align_of"],["std::intrinsics::aligned_alloca"," Allocate the memory on the stack","/std/intrinsics/#item.aligned_alloca"],["std::intrinsics::vtable"," Generate a virtual method table for the given protocol and type.","/std/intrinsics/#item.vtable"],["std::intrinsics::test_cases"," Minimal support for unit testing in the compiler.","/std/intrinsics/#item.test_cases"],["std::intrinsics::enum_variants"," Enum variants","/std/intrinsics/#item.enum_variants"],["std::intrinsics::asm"," Inline assembly","/std/intrinsics/#item.asm"],["std::intrinsics::codegen_const"," Return the value of a C builtin constant","/std/intrinsics/#item.codegen_const"],["std::intrinsics::codegen_func"," Call a builtin C function","/std/intrinsics/#item.codegen_func"],["std::io::unix","","/std/io/unix/"],["std::io::internal","","/std/io/internal/"],["std::io::tests","","/std/io/tests/"],["std::io::AsFileDescriptor"," Types that are wrappers over a file descriptor.","/std/io/AsFileDescriptor.html"],["std::io::Readable"," Types that implement readable stream semantics.","/std/io/Readable.html"],["std::io::Writable"," Types that implement writable stream semantics.","/std/io/Writable.html"],["std::io::Seekable"," Streams that can be fast-forwarded or rewound to an arbitrary offset.","/std/io/Seekable.html"],["std::io::BufferedReadable"," Readable streams that have an internal buffer.","/std/io/BufferedReadable.html"],["std::io::Error"," Error type for I/O operations","/std/io/Error.html"],["std::io::FileDescriptor"," Platform specific file descriptor.","/std/io/FileDescriptor.html"],["std::io::NullStream"," A null stream (similar to `/dev/null`).","/std/io/NullStream.html"],["std::io::StdioStream"," Standard I/O stream.","/std/io/StdioStream.html"],["std::io::TakeAdapter"," Adapter for a stream that returns EOF after `limit` bytes are read.","/std/io/TakeAdapter.html"],["std::io::Pipe"," A FIFO pipe.","/std/io/Pipe.html"],["std::io::ChainAdapter"," Adapter for a pair of streams that chains them together.","/std/io/ChainAdapter.html"],["std::io::SliceReader"," A readable stream backed by an in-memory string slice.","/std/io/SliceReader.html"],["std::io::StringWriter"," A writable stream backed by [std::string::StringBuf].","/std/io/StringWriter.html"],["std::io::BufferedReader"," A buffered wrapper over an underlying stream.","/std/io/BufferedReader.html"],["std::io::BufferedWriter"," A buffered wrapper over an underlying writable stream.","/std/io/BufferedWriter.html"],["std::io::LineIterator"," Iterator that reads the inner stream line by line.","/std/io/LineIterator.html"],["std::io::take"," Returns an adapter for a stream that returns EOF after `limit` bytes have been read.","/std/io/#item.take"],["std::io::chain"," Chains the two streams together","/std/io/#item.chain"],["std::io::copy"," Copy the entire stream `src` into `dst`","/std/io/#item.copy"],["std::io::copy_using"," Copy the entire stream `src` into `dst` using a provided buffer.","/std/io/#item.copy_using"],["std::io::read_byte"," Reads a single byte from the stream.","/std/io/#item.read_byte"],["std::io::read_until"," Reads the stream into `buf` until a specific byte is encountered.","/std/io/#item.read_until"],["std::io::lines"," Return an iterator that yields the stream's contents line by line.","/std/io/#item.lines"],["std::io::Result"," Type alias for the result of I/O operations.","/std/io/#item.Result"],["std::io::SeekFrom"," Reference point for the seek operation.","/std/io/SeekFrom.html"],["std::io::print"," Prints a formatted string to standard output.","/std/io/print.html"],["std::io::println"," Prints a formatted string to standard output with newline.","/std/io/println.html"],["std::io::eprint"," Prints a formatted string to standard error.","/std/io/eprint.html"],["std::io::eprintln"," Prints a formatted string to standard error with newline.","/std/io/eprintln.html"],["std::io::DEFAULT_BUFFER_SIZE","","/std/io/#item.DEFAULT_BUFFER_SIZE"],["std::io::FMT_BUF"," Buffer for formatted standard I/O.","/std/io/#item.FMT_BUF"],["std::io::AsFileDescriptor::as_fd","","/std/io/AsFileDescriptor.html#item.as_fd"],["std::io::BufferedReadable::fill_buffer"," Return the current contents of the buffer, reading additional","/std/io/BufferedReadable.html#item.fill_buffer"],["std::io::BufferedReadable::consume"," Mark `amount` bytes as consumed, moving the internal buffer","/std/io/BufferedReadable.html#item.consume"],["std::io::BufferedReader::new"," Create a BufferedReader with a heap-allocated buffer of the given size.","/std/io/BufferedReader.html#item.new"],["std::io::BufferedReader::from_slice"," Creates a BufferedReader from an existing-buffer, potentially","/std/io/BufferedReader.html#item.from_slice"],["std::io::BufferedReader::fill_buffer"," Return the current contents of the buffer, reading additional","/std/io/BufferedReader.html#item.fill_buffer"],["std::io::BufferedReader::consume"," Mark `amount` bytes as consumed, moving the internal buffer","/std/io/BufferedReader.html#item.consume"],["std::io::BufferedReader::read"," Reads from the stream into a provided buffer.","/std/io/BufferedReader.html#item.read"],["std::io::BufferedReader::read_exact"," Fills the provided buffer by reading from the stream.","/std/io/BufferedReader.html#item.read_exact"],["std::io::BufferedReader::free"," Frees the memory backing the object.","/std/io/BufferedReader.html#item.free"],["std::io::BufferedReader::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/BufferedReader.html#item.move"],["std::io::BufferedReader::seek"," Jump to a specified position in the stream.","/std/io/BufferedReader.html#item.seek"],["std::io::BufferedWriter::new"," Create a BufferedWriter with a heap-allocated buffer of the given size.","/std/io/BufferedWriter.html#item.new"],["std::io::BufferedWriter::from_slice"," Creates a BufferedWriter from an existing-buffer, potentially","/std/io/BufferedWriter.html#item.from_slice"],["std::io::BufferedWriter::write_full","","/std/io/BufferedWriter.html#item.write_full"],["std::io::BufferedWriter::write"," Write the buffer to the stream.","/std/io/BufferedWriter.html#item.write"],["std::io::BufferedWriter::write_all"," Writes all the bytes in the buffer to the stream.","/std/io/BufferedWriter.html#item.write_all"],["std::io::BufferedWriter::flush"," Flush the stream","/std/io/BufferedWriter.html#item.flush"],["std::io::BufferedWriter::free"," Frees the memory backing the object.","/std/io/BufferedWriter.html#item.free"],["std::io::BufferedWriter::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/BufferedWriter.html#item.move"],["std::io::BufferedWriter::write_str"," Write a string","/std/io/BufferedWriter.html#item.write_str"],["std::io::ChainAdapter::new"," Creates a new adapter for a pair of streams","/std/io/ChainAdapter.html#item.new"],["std::io::ChainAdapter::read"," Reads from the stream into a provided buffer.","/std/io/ChainAdapter.html#item.read"],["std::io::Error::from_errno"," Create `Error` from the last OS error (`errno`)","/std/io/Error.html#item.from_errno"],["std::io::Error::from_errno_custom"," Create `Error` from the last OS error (`errno`)","/std/io/Error.html#item.from_errno_custom"],["std::io::Error::from_gai"," Create `Error` from the code returned by [libc::getaddrinfo].","/std/io/Error.html#item.from_gai"],["std::io::Error::custom"," Create a custom Error.","/std/io/Error.html#item.custom"],["std::io::Error::eof"," Create an error signalling end-of-file.","/std/io/Error.html#item.eof"],["std::io::Error::as_errno","","/std/io/Error.html#item.as_errno"],["std::io::Error::fmt","","/std/io/Error.html#item.fmt"],["std::io::Error::equals","","/std/io/Error.html#item.equals"],["std::io::FileDescriptor::new"," Create a `FileDescriptor` object from a raw file descriptor.","/std/io/FileDescriptor.html#item.new"],["std::io::FileDescriptor::close"," Close the file descriptor.","/std/io/FileDescriptor.html#item.close"],["std::io::FileDescriptor::as_fd","","/std/io/FileDescriptor.html#item.as_fd"],["std::io::FileDescriptor::set_nonblocking"," Sets the file descriptor blocking mode.","/std/io/FileDescriptor.html#item.set_nonblocking"],["std::io::FileDescriptor::set_cloexec"," Sets whether the file descriptor is closed on exec.","/std/io/FileDescriptor.html#item.set_cloexec"],["std::io::FileDescriptor::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/FileDescriptor.html#item.move"],["std::io::LineIterator::with_line_buffer"," Create a line iterator with a pre-allocated buffer.","/std/io/LineIterator.html#item.with_line_buffer"],["std::io::LineIterator::new"," Create a line iterator with a default buffer.","/std/io/LineIterator.html#item.new"],["std::io::LineIterator::with_capacity"," Create a line iterator with a given capacity","/std/io/LineIterator.html#item.with_capacity"],["std::io::LineIterator::next"," Returns the next item, if any.","/std/io/LineIterator.html#item.next"],["std::io::LineIterator::free"," Frees the memory backing the object.","/std/io/LineIterator.html#item.free"],["std::io::LineIterator::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/LineIterator.html#item.move"],["std::io::NullStream::new"," Creates a new null stream.","/std/io/NullStream.html#item.new"],["std::io::NullStream::read"," Reads from the stream into a provided buffer.","/std/io/NullStream.html#item.read"],["std::io::NullStream::read_exact"," Fills the provided buffer by reading from the stream.","/std/io/NullStream.html#item.read_exact"],["std::io::NullStream::read_to_end"," Reads the entire stream into a `StringBuf`.","/std/io/NullStream.html#item.read_to_end"],["std::io::NullStream::write"," Write the buffer to the stream.","/std/io/NullStream.html#item.write"],["std::io::NullStream::write_all"," Writes all the bytes in the buffer to the stream.","/std/io/NullStream.html#item.write_all"],["std::io::NullStream::flush"," Flush the stream","/std/io/NullStream.html#item.flush"],["std::io::Pipe::anonymous"," Create an anonymous pipe pair.","/std/io/Pipe.html#item.anonymous"],["std::io::Pipe::from_fd"," Create a `Pipe` object from a raw file descriptor.","/std/io/Pipe.html#item.from_fd"],["std::io::Pipe::as_fd","","/std/io/Pipe.html#item.as_fd"],["std::io::Pipe::close"," Close the pipe.","/std/io/Pipe.html#item.close"],["std::io::Pipe::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/Pipe.html#item.move"],["std::io::Readable::read"," Reads from the stream into a provided buffer.","/std/io/Readable.html#item.read"],["std::io::Readable::read_exact"," Fills the provided buffer by reading from the stream.","/std/io/Readable.html#item.read_exact"],["std::io::Readable::read_to_end"," Reads the entire stream into a `StringBuf`.","/std/io/Readable.html#item.read_to_end"],["std::io::SeekFrom::Beginning","","/std/io/SeekFrom.html#item.Beginning"],["std::io::SeekFrom::Current","","/std/io/SeekFrom.html#item.Current"],["std::io::SeekFrom::End","","/std/io/SeekFrom.html#item.End"],["std::io::Seekable::seek"," Jump to a specified position in the stream.","/std/io/Seekable.html#item.seek"],["std::io::Seekable::rewind"," Rewind the stream to the beginning.","/std/io/Seekable.html#item.rewind"],["std::io::Seekable::position"," Returns the current position in the stream from the beginning.","/std/io/Seekable.html#item.position"],["std::io::SliceReader::new","","/std/io/SliceReader.html#item.new"],["std::io::SliceReader::read"," Reads from the stream into a provided buffer.","/std/io/SliceReader.html#item.read"],["std::io::SliceReader::fill_buffer"," Return the current contents of the buffer, reading additional","/std/io/SliceReader.html#item.fill_buffer"],["std::io::SliceReader::consume"," Mark `amount` bytes as consumed, moving the internal buffer","/std/io/SliceReader.html#item.consume"],["std::io::SliceReader::seek"," Jump to a specified position in the stream.","/std/io/SliceReader.html#item.seek"],["std::io::SliceReader::position"," Returns the current position in the stream from the beginning.","/std/io/SliceReader.html#item.position"],["std::io::StdioStream::stdin"," Standard input","/std/io/StdioStream.html#item.stdin"],["std::io::StdioStream::stdout"," Standard output","/std/io/StdioStream.html#item.stdout"],["std::io::StdioStream::stderr"," Standard error","/std/io/StdioStream.html#item.stderr"],["std::io::StdioStream::as_fd","","/std/io/StdioStream.html#item.as_fd"],["std::io::StdioStream::close"," Close the stream.","/std/io/StdioStream.html#item.close"],["std::io::StdioStream::flush"," Flush the stream.","/std/io/StdioStream.html#item.flush"],["std::io::StdioStream::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/StdioStream.html#item.move"],["std::io::StringWriter::new","","/std/io/StringWriter.html#item.new"],["std::io::StringWriter::write"," Write the buffer to the stream.","/std/io/StringWriter.html#item.write"],["std::io::StringWriter::flush"," Flush the stream","/std/io/StringWriter.html#item.flush"],["std::io::TakeAdapter::new"," Creates a new adapter for the given stream.","/std/io/TakeAdapter.html#item.new"],["std::io::TakeAdapter::read"," Reads from the stream into a provided buffer.","/std/io/TakeAdapter.html#item.read"],["std::io::Writable::write"," Write the buffer to the stream.","/std/io/Writable.html#item.write"],["std::io::Writable::flush"," Flush the stream","/std/io/Writable.html#item.flush"],["std::io::Writable::write_all"," Writes all the bytes in the buffer to the stream.","/std/io/Writable.html#item.write_all"],["std::io::internal::default_read_exact","","/std/io/internal/#item.default_read_exact"],["std::io::tests::test_slice_reader","","/std/io/tests/#item.test_slice_reader"],["std::io::tests::test_slice_reader_seek","","/std/io/tests/#item.test_slice_reader_seek"],["std::io::tests::test_lines","","/std/io/tests/#item.test_lines"],["std::io::tests::test_read_byte","","/std/io/tests/#item.test_read_byte"],["std::io::tests::test_copy","","/std/io/tests/#item.test_copy"],["std::io::tests::test_null","","/std/io/tests/#item.test_null"],["std::io::tests::test_take","","/std/io/tests/#item.test_take"],["std::io::tests::test_chain","","/std/io/tests/#item.test_chain"],["std::io::tests::read_n","","/std/io/tests/read_n.html"],["std::io::tests::BUF","","/std/io/tests/#item.BUF"],["std::io::unix::FdReadWrite"," Mixin for read and write operations for objects that can be viewed as a file descriptor.","/std/io/unix/FdReadWrite.html"],["std::io::unix::Error"," Error type for I/O operations","/std/io/unix/Error.html"],["std::io::unix::FileDescriptor"," Platform specific file descriptor.","/std/io/unix/FileDescriptor.html"],["std::io::unix::StdioStream"," Standard I/O stream.","/std/io/unix/StdioStream.html"],["std::io::unix::Pipe"," A FIFO pipe.","/std/io/unix/Pipe.html"],["std::io::unix::ErrorKind","","/std/io/unix/ErrorKind.html"],["std::io::unix::errno_try","","/std/io/unix/errno_try.html"],["std::io::unix::Error::from_errno"," Create `Error` from the last OS error (`errno`)","/std/io/unix/Error.html#item.from_errno"],["std::io::unix::Error::from_errno_custom"," Create `Error` from the last OS error (`errno`)","/std/io/unix/Error.html#item.from_errno_custom"],["std::io::unix::Error::from_gai"," Create `Error` from the code returned by [libc::getaddrinfo].","/std/io/unix/Error.html#item.from_gai"],["std::io::unix::Error::custom"," Create a custom Error.","/std/io/unix/Error.html#item.custom"],["std::io::unix::Error::eof"," Create an error signalling end-of-file.","/std/io/unix/Error.html#item.eof"],["std::io::unix::Error::as_errno","","/std/io/unix/Error.html#item.as_errno"],["std::io::unix::Error::fmt","","/std/io/unix/Error.html#item.fmt"],["std::io::unix::Error::equals","","/std/io/unix/Error.html#item.equals"],["std::io::unix::ErrorKind::UnexpectedEof","","/std/io/unix/ErrorKind.html#item.UnexpectedEof"],["std::io::unix::ErrorKind::Os","","/std/io/unix/ErrorKind.html#item.Os"],["std::io::unix::ErrorKind::GetAddrInfo","","/std/io/unix/ErrorKind.html#item.GetAddrInfo"],["std::io::unix::ErrorKind::UserDefined","","/std/io/unix/ErrorKind.html#item.UserDefined"],["std::io::unix::FdReadWrite::read"," Reads from the stream into a provided buffer.","/std/io/unix/FdReadWrite.html#item.read"],["std::io::unix::FdReadWrite::write"," Write the buffer to the stream.","/std/io/unix/FdReadWrite.html#item.write"],["std::io::unix::FileDescriptor::new"," Create a `FileDescriptor` object from a raw file descriptor.","/std/io/unix/FileDescriptor.html#item.new"],["std::io::unix::FileDescriptor::close"," Close the file descriptor.","/std/io/unix/FileDescriptor.html#item.close"],["std::io::unix::FileDescriptor::as_fd","","/std/io/unix/FileDescriptor.html#item.as_fd"],["std::io::unix::FileDescriptor::set_nonblocking"," Sets the file descriptor blocking mode.","/std/io/unix/FileDescriptor.html#item.set_nonblocking"],["std::io::unix::FileDescriptor::set_cloexec"," Sets whether the file descriptor is closed on exec.","/std/io/unix/FileDescriptor.html#item.set_cloexec"],["std::io::unix::FileDescriptor::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/unix/FileDescriptor.html#item.move"],["std::io::unix::Pipe::anonymous"," Create an anonymous pipe pair.","/std/io/unix/Pipe.html#item.anonymous"],["std::io::unix::Pipe::from_fd"," Create a `Pipe` object from a raw file descriptor.","/std/io/unix/Pipe.html#item.from_fd"],["std::io::unix::Pipe::as_fd","","/std/io/unix/Pipe.html#item.as_fd"],["std::io::unix::Pipe::close"," Close the pipe.","/std/io/unix/Pipe.html#item.close"],["std::io::unix::Pipe::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/unix/Pipe.html#item.move"],["std::io::unix::StdioStream::stdin"," Standard input","/std/io/unix/StdioStream.html#item.stdin"],["std::io::unix::StdioStream::stdout"," Standard output","/std/io/unix/StdioStream.html#item.stdout"],["std::io::unix::StdioStream::stderr"," Standard error","/std/io/unix/StdioStream.html#item.stderr"],["std::io::unix::StdioStream::as_fd","","/std/io/unix/StdioStream.html#item.as_fd"],["std::io::unix::StdioStream::close"," Close the stream.","/std/io/unix/StdioStream.html#item.close"],["std::io::unix::StdioStream::flush"," Flush the stream.","/std/io/unix/StdioStream.html#item.flush"],["std::io::unix::StdioStream::move"," Creates a copy of the object, leaving an inert object behind.","/std/io/unix/StdioStream.html#item.move"],["std::iter::internal","","/std/iter/internal/"],["std::iter::tests","","/std/iter/tests/"],["std::iter::Iterator"," Iterators.","/std/iter/Iterator.html"],["std::iter::DoubleEndedIterator"," Iterators that can be consumed from both ends.","/std/iter/DoubleEndedIterator.html"],["std::iter::DoubleEndedIteratorExt"," Extension mixin for [DoubleEndedIterator] types.","/std/iter/DoubleEndedIteratorExt.html"],["std::iter::Iterable"," Types that can be iterated.","/std/iter/Iterable.html"],["std::iter::IterableRef"," Types that can produce an iterator over pointers to their elements.","/std/iter/IterableRef.html"],["std::iter::IterableMut"," Types that can produce an iterator over mutable pointers to their elements.","/std/iter/IterableMut.html"],["std::iter::IteratorExt"," Extension mixin for [Iterator] types.","/std/iter/IteratorExt.html"],["std::iter::RevIterator"," Reverse iterator.","/std/iter/RevIterator.html"],["std::iter::MapIterator"," Map iterator.","/std/iter/MapIterator.html"],["std::iter::TakeWhileIterator"," Iterator that takes elements while a predicate is true.","/std/iter/TakeWhileIterator.html"],["std::iter::SkipWhileIterator"," Iterator that skips elements until a predicate becomes false.","/std/iter/SkipWhileIterator.html"],["std::iter::FilterMapIterator"," Filter map iterator.","/std/iter/FilterMapIterator.html"],["std::iter::FilterIterator"," Filter iterator.","/std/iter/FilterIterator.html"],["std::iter::SkipIterator"," Iterator that skips a specified number of elements.","/std/iter/SkipIterator.html"],["std::iter::StepByIterator"," Step by iterator.","/std/iter/StepByIterator.html"],["std::iter::FusedIterator"," Fused iterator.","/std/iter/FusedIterator.html"],["std::iter::TakeIterator"," Iterator that takes a specified number of elements.","/std/iter/TakeIterator.html"],["std::iter::EnumerateIterator"," Enumerate iterator.","/std/iter/EnumerateIterator.html"],["std::iter::ChainIterator"," Chain iterator.","/std/iter/ChainIterator.html"],["std::iter::InspectIterator"," Inspect iterator.","/std/iter/InspectIterator.html"],["std::iter::Grouping"," A group iterator for [GroupByIterator].","/std/iter/Grouping.html"],["std::iter::GroupByIterator"," Grouping iterator","/std/iter/GroupByIterator.html"],["std::iter::Chunk"," A chunk yielded by [ChunksIterator].","/std/iter/Chunk.html"],["std::iter::ChunksIterator"," Chunking iterator","/std/iter/ChunksIterator.html"],["std::iter::PeekableIterator"," Peekable iterator","/std/iter/PeekableIterator.html"],["std::iter::ZipIterator"," Zip iterator","/std/iter/ZipIterator.html"],["std::iter::FlattenIterator"," Flatten iterator","/std/iter/FlattenIterator.html"],["std::iter::EmptyIterator"," An empty iterator.","/std/iter/EmptyIterator.html"],["std::iter::FromFnIterator"," A function wrapped in an iterator.","/std/iter/FromFnIterator.html"],["std::iter::RepeatIterator"," Iterator that repeats a value infinitely.","/std/iter/RepeatIterator.html"],["std::iter::OnceIterator"," Iterator that yields a single value","/std/iter/OnceIterator.html"],["std::iter::empty"," Returns an iterator that produces no elements.","/std/iter/#item.empty"],["std::iter::from_fn"," Wraps a function in an iterator.","/std/iter/#item.from_fn"],["std::iter::repeat"," Returns an iterator that repeats the same value indefinitely.","/std/iter/#item.repeat"],["std::iter::once"," Returns an iterator that repeats a single element exactly once.","/std/iter/#item.once"],["std::iter::iterable_yield_t"," Type of the element that an [Iterable] yields.","/std/iter/#item.iterable_yield_t"],["std::iter::iterator_yield_t"," Type of the element that an [Iterator] yields.","/std/iter/#item.iterator_yield_t"],["std::iter::ChainIterator::next"," Returns the next item, if any.","/std/iter/ChainIterator.html#item.next"],["std::iter::ChainIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/ChainIterator.html#item.size_hint"],["std::iter::ChainIterator::next_back"," Returns the next item from the back, if any.","/std/iter/ChainIterator.html#item.next_back"],["std::iter::Chunk::next"," Returns the next item, if any.","/std/iter/Chunk.html#item.next"],["std::iter::Chunk::size_hint"," Returns the number of remaining elements, if available.","/std/iter/Chunk.html#item.size_hint"],["std::iter::ChunksIterator::next"," Returns the next item, if any.","/std/iter/ChunksIterator.html#item.next"],["std::iter::ChunksIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/ChunksIterator.html#item.size_hint"],["std::iter::DoubleEndedIterator::next_back"," Returns the next item from the back, if any.","/std/iter/DoubleEndedIterator.html#item.next_back"],["std::iter::DoubleEndedIteratorExt::rev"," \"Reverse\" the iterator.","/std/iter/DoubleEndedIteratorExt.html#item.rev"],["std::iter::EmptyIterator::next"," Returns the next item, if any.","/std/iter/EmptyIterator.html#item.next"],["std::iter::EmptyIterator::next_back"," Returns the next item from the back, if any.","/std/iter/EmptyIterator.html#item.next_back"],["std::iter::EmptyIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/EmptyIterator.html#item.size_hint"],["std::iter::EnumerateIterator::next"," Returns the next item, if any.","/std/iter/EnumerateIterator.html#item.next"],["std::iter::EnumerateIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/EnumerateIterator.html#item.size_hint"],["std::iter::FilterIterator::next"," Returns the next item, if any.","/std/iter/FilterIterator.html#item.next"],["std::iter::FilterIterator::next_back"," Returns the next item from the back, if any.","/std/iter/FilterIterator.html#item.next_back"],["std::iter::FilterMapIterator::next"," Returns the next item, if any.","/std/iter/FilterMapIterator.html#item.next"],["std::iter::FlattenIterator::next"," Returns the next item, if any.","/std/iter/FlattenIterator.html#item.next"],["std::iter::FromFnIterator::next"," Returns the next item, if any.","/std/iter/FromFnIterator.html#item.next"],["std::iter::FusedIterator::next"," Returns the next item, if any.","/std/iter/FusedIterator.html#item.next"],["std::iter::FusedIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/FusedIterator.html#item.size_hint"],["std::iter::FusedIterator::next_back"," Returns the next item from the back, if any.","/std/iter/FusedIterator.html#item.next_back"],["std::iter::GroupByIterator::next"," Returns the next item, if any.","/std/iter/GroupByIterator.html#item.next"],["std::iter::Grouping::next"," Returns the next item, if any.","/std/iter/Grouping.html#item.next"],["std::iter::InspectIterator::next"," Returns the next item, if any.","/std/iter/InspectIterator.html#item.next"],["std::iter::InspectIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/InspectIterator.html#item.size_hint"],["std::iter::Iterable::iter"," Returns an iterator over the elements of this iterable.","/std/iter/Iterable.html#item.iter"],["std::iter::IterableMut::iter_mut"," Returns an iterator over mutable pointers to the elements of the collection.","/std/iter/IterableMut.html#item.iter_mut"],["std::iter::IterableRef::iter_ref"," Returns an iterator over the pointers of the items of the collection.","/std/iter/IterableRef.html#item.iter_ref"],["std::iter::Iterator::next"," Returns the next item, if any.","/std/iter/Iterator.html#item.next"],["std::iter::Iterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/Iterator.html#item.size_hint"],["std::iter::IteratorExt::iter"," Return self.","/std/iter/IteratorExt.html#item.iter"],["std::iter::IteratorExt::fuse"," Return an iterator that returns `Option::none()` forever after the","/std/iter/IteratorExt.html#item.fuse"],["std::iter::IteratorExt::chain"," Returns an iterator that yields all elements of `self` and then all elements of `other`.","/std/iter/IteratorExt.html#item.chain"],["std::iter::IteratorExt::skip"," Returns an iterator that skips first `n` values.","/std/iter/IteratorExt.html#item.skip"],["std::iter::IteratorExt::step_by"," Returns an iterator that steps by `n` values.","/std/iter/IteratorExt.html#item.step_by"],["std::iter::IteratorExt::take"," Returns an iterator that yields at most `n` elements.","/std/iter/IteratorExt.html#item.take"],["std::iter::IteratorExt::enumerate"," Returns an iterator that attaches a sequence number of each item.","/std/iter/IteratorExt.html#item.enumerate"],["std::iter::IteratorExt::last"," Returns the last value of the iterator.","/std/iter/IteratorExt.html#item.last"],["std::iter::IteratorExt::nth"," Returns the `n`-th value of the iterator.","/std/iter/IteratorExt.html#item.nth"],["std::iter::IteratorExt::count"," Counts the number of elements in this iterator.","/std/iter/IteratorExt.html#item.count"],["std::iter::IteratorExt::inspect"," Inspects each element of the iterator.","/std/iter/IteratorExt.html#item.inspect"],["std::iter::IteratorExt::take_while"," Returns an iterator that yields the elements while a predicate is true.","/std/iter/IteratorExt.html#item.take_while"],["std::iter::IteratorExt::skip_while"," Returns an iterator that skips the elements while a predicate is true.","/std/iter/IteratorExt.html#item.skip_while"],["std::iter::IteratorExt::map"," Returns an iterator that transforms the elements of this iterator.","/std/iter/IteratorExt.html#item.map"],["std::iter::IteratorExt::foreach"," Executes a function on each element of this iterator.","/std/iter/IteratorExt.html#item.foreach"],["std::iter::IteratorExt::filter"," Returns an iterator that yields the elements of this iterator that match a predicate.","/std/iter/IteratorExt.html#item.filter"],["std::iter::IteratorExt::find"," Returns the first item matching the predicate.","/std/iter/IteratorExt.html#item.find"],["std::iter::IteratorExt::find_index"," Returns the index of the first item matching the predicate.","/std/iter/IteratorExt.html#item.find_index"],["std::iter::IteratorExt::filter_map"," Transforms and filters the iterator at the same time.","/std/iter/IteratorExt.html#item.filter_map"],["std::iter::IteratorExt::chunks"," Returns an iterator of chunks of size `chunk_size`.","/std/iter/IteratorExt.html#item.chunks"],["std::iter::IteratorExt::reduce"," Reduces the iterator into a single value.","/std/iter/IteratorExt.html#item.reduce"],["std::iter::IteratorExt::sum"," Sums all the values in the iterator.","/std/iter/IteratorExt.html#item.sum"],["std::iter::IteratorExt::min"," Returns the minimum value of the iterator.","/std/iter/IteratorExt.html#item.min"],["std::iter::IteratorExt::max"," Returns the maximum value of the iterator.","/std/iter/IteratorExt.html#item.max"],["std::iter::IteratorExt::all"," Returns `true` if all elements of the iterator match a predicate, `false` otherwise.","/std/iter/IteratorExt.html#item.all"],["std::iter::IteratorExt::any"," Returns `true` if any element of the iterator matches a predicate, `false` otherwise.","/std/iter/IteratorExt.html#item.any"],["std::iter::IteratorExt::to_vector"," Collects the values of the iterator into a vector.","/std/iter/IteratorExt.html#item.to_vector"],["std::iter::IteratorExt::fill_slice"," Fills the slice with the values of the iterator.","/std/iter/IteratorExt.html#item.fill_slice"],["std::iter::IteratorExt::peekable"," Returns a \"peekable\" iterator.","/std/iter/IteratorExt.html#item.peekable"],["std::iter::IteratorExt::group_by"," Returns an iterator of groups grouped by a key.","/std/iter/IteratorExt.html#item.group_by"],["std::iter::IteratorExt::zip"," Combines two iterators, returning an iterator of pairs.","/std/iter/IteratorExt.html#item.zip"],["std::iter::IteratorExt::flatten"," Flattens an iterator over iterable types into a single iterator.","/std/iter/IteratorExt.html#item.flatten"],["std::iter::MapIterator::next"," Returns the next item, if any.","/std/iter/MapIterator.html#item.next"],["std::iter::MapIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/MapIterator.html#item.size_hint"],["std::iter::MapIterator::next_back"," Returns the next item from the back, if any.","/std/iter/MapIterator.html#item.next_back"],["std::iter::OnceIterator::next"," Returns the next item, if any.","/std/iter/OnceIterator.html#item.next"],["std::iter::OnceIterator::next_back"," Returns the next item from the back, if any.","/std/iter/OnceIterator.html#item.next_back"],["std::iter::OnceIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/OnceIterator.html#item.size_hint"],["std::iter::PeekableIterator::next"," Returns the next item, if any.","/std/iter/PeekableIterator.html#item.next"],["std::iter::PeekableIterator::peek"," Return the next element in the iterator without consuming it.","/std/iter/PeekableIterator.html#item.peek"],["std::iter::PeekableIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/PeekableIterator.html#item.size_hint"],["std::iter::RepeatIterator::next"," Returns the next item, if any.","/std/iter/RepeatIterator.html#item.next"],["std::iter::RepeatIterator::next_back"," Returns the next item from the back, if any.","/std/iter/RepeatIterator.html#item.next_back"],["std::iter::RepeatIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/RepeatIterator.html#item.size_hint"],["std::iter::RevIterator::next"," Returns the next item, if any.","/std/iter/RevIterator.html#item.next"],["std::iter::RevIterator::next_back"," Returns the next item from the back, if any.","/std/iter/RevIterator.html#item.next_back"],["std::iter::RevIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/RevIterator.html#item.size_hint"],["std::iter::SkipIterator::next"," Returns the next item, if any.","/std/iter/SkipIterator.html#item.next"],["std::iter::SkipIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/SkipIterator.html#item.size_hint"],["std::iter::SkipWhileIterator::next"," Returns the next item, if any.","/std/iter/SkipWhileIterator.html#item.next"],["std::iter::StepByIterator::next"," Returns the next item, if any.","/std/iter/StepByIterator.html#item.next"],["std::iter::StepByIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/StepByIterator.html#item.size_hint"],["std::iter::TakeIterator::next"," Returns the next item, if any.","/std/iter/TakeIterator.html#item.next"],["std::iter::TakeIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/TakeIterator.html#item.size_hint"],["std::iter::TakeWhileIterator::next"," Returns the next item, if any.","/std/iter/TakeWhileIterator.html#item.next"],["std::iter::ZipIterator::next"," Returns the next item, if any.","/std/iter/ZipIterator.html#item.next"],["std::iter::ZipIterator::size_hint"," Returns the number of remaining elements, if available.","/std/iter/ZipIterator.html#item.size_hint"],["std::iter::internal::iter_plus","","/std/iter/internal/#item.iter_plus"],["std::iter::internal::iter_min","","/std/iter/internal/#item.iter_min"],["std::iter::internal::iter_max","","/std/iter/internal/#item.iter_max"],["std::iter::tests::test_map","","/std/iter/tests/#item.test_map"],["std::iter::tests::test_map_rev","","/std/iter/tests/#item.test_map_rev"],["std::iter::tests::test_filter","","/std/iter/tests/#item.test_filter"],["std::iter::tests::test_filter_rev","","/std/iter/tests/#item.test_filter_rev"],["std::iter::tests::test_filter_map","","/std/iter/tests/#item.test_filter_map"],["std::iter::tests::test_reduce","","/std/iter/tests/#item.test_reduce"],["std::iter::tests::test_empty","","/std/iter/tests/#item.test_empty"],["std::iter::tests::test_all","","/std/iter/tests/#item.test_all"],["std::iter::tests::test_any","","/std/iter/tests/#item.test_any"],["std::iter::tests::test_repeat","","/std/iter/tests/#item.test_repeat"],["std::iter::tests::test_skip","","/std/iter/tests/#item.test_skip"],["std::iter::tests::test_take","","/std/iter/tests/#item.test_take"],["std::iter::tests::test_count","","/std/iter/tests/#item.test_count"],["std::iter::tests::test_last","","/std/iter/tests/#item.test_last"],["std::iter::tests::test_chain","","/std/iter/tests/#item.test_chain"],["std::iter::tests::test_chain_rev","","/std/iter/tests/#item.test_chain_rev"],["std::iter::tests::test_enumerate","","/std/iter/tests/#item.test_enumerate"],["std::iter::tests::test_foreach","","/std/iter/tests/#item.test_foreach"],["std::iter::tests::test_inspect","","/std/iter/tests/#item.test_inspect"],["std::iter::tests::test_to_vector","","/std/iter/tests/#item.test_to_vector"],["std::iter::tests::test_take_while","","/std/iter/tests/#item.test_take_while"],["std::iter::tests::test_skip_while","","/std/iter/tests/#item.test_skip_while"],["std::iter::tests::test_step_by","","/std/iter/tests/#item.test_step_by"],["std::iter::tests::test_nth","","/std/iter/tests/#item.test_nth"],["std::iter::tests::test_once","","/std/iter/tests/#item.test_once"],["std::iter::tests::fill_slice","","/std/iter/tests/#item.fill_slice"],["std::iter::tests::test_peekable","","/std/iter/tests/#item.test_peekable"],["std::iter::tests::test_group_by","","/std/iter/tests/#item.test_group_by"],["std::iter::tests::test_group_by_draining","","/std/iter/tests/#item.test_group_by_draining"],["std::iter::tests::test_rev","","/std/iter/tests/#item.test_rev"],["std::iter::tests::test_from_fn","","/std/iter/tests/#item.test_from_fn"],["std::iter::tests::test_fuse","","/std/iter/tests/#item.test_fuse"],["std::iter::tests::test_sum","","/std/iter/tests/#item.test_sum"],["std::iter::tests::test_min","","/std/iter/tests/#item.test_min"],["std::iter::tests::test_max","","/std/iter/tests/#item.test_max"],["std::iter::tests::test_zip","","/std/iter/tests/#item.test_zip"],["std::iter::tests::test_zip_shorter","","/std/iter/tests/#item.test_zip_shorter"],["std::iter::tests::test_flatten","","/std/iter/tests/#item.test_flatten"],["std::iter::tests::test_flatten_2","","/std/iter/tests/#item.test_flatten_2"],["std::iter::tests::test_flatten_3","","/std/iter/tests/#item.test_flatten_3"],["std::iter::tests::test_flatten_4","","/std/iter/tests/#item.test_flatten_4"],["std::iter::tests::test_find","","/std/iter/tests/#item.test_find"],["std::iter::tests::test_find_index","","/std/iter/tests/#item.test_find_index"],["std::iter::tests::test_chunks","","/std/iter/tests/#item.test_chunks"],["std::iter::tests::test_chunks_not_used","","/std/iter/tests/#item.test_chunks_not_used"],["std::iter::tests::test_chunks_1","","/std/iter/tests/#item.test_chunks_1"],["std::iter::tests::test_chunks_empty","","/std/iter/tests/#item.test_chunks_empty"],["std::iter::tests::test_chunks_0","","/std/iter/tests/#item.test_chunks_0"],["std::math::tests","","/std/math/tests/"],["std::math::abs"," Absolute value of a number","/std/math/#item.abs"],["std::math::widening_abs"," Absolute value of an integer (widened to the unsigned type)","/std/math/#item.widening_abs"],["std::math::div_floor"," Calculates the quotient and remainder of integer division","/std/math/#item.div_floor"],["std::math::E"," Base of the natural logarithm","/std/math/#item.E"],["std::math::FRAC_1_PI"," 1/π","/std/math/#item.FRAC_1_PI"],["std::math::FRAC_1_SQRT_2"," 1/sqrt(2)","/std/math/#item.FRAC_1_SQRT_2"],["std::math::FRAC_2_PI"," 2/π","/std/math/#item.FRAC_2_PI"],["std::math::FRAC_2_SQRT_PI"," 2/sqrt(π)","/std/math/#item.FRAC_2_SQRT_PI"],["std::math::FRAC_PI_2"," π/2","/std/math/#item.FRAC_PI_2"],["std::math::FRAC_PI_3"," π/3","/std/math/#item.FRAC_PI_3"],["std::math::FRAC_PI_4"," π/4","/std/math/#item.FRAC_PI_4"],["std::math::FRAC_PI_6"," π/6","/std/math/#item.FRAC_PI_6"],["std::math::FRAC_PI_8"," π/8","/std/math/#item.FRAC_PI_8"],["std::math::LN_10"," Natural logarithm of 10","/std/math/#item.LN_10"],["std::math::LN_2"," Natural logarithm of 2","/std/math/#item.LN_2"],["std::math::LOG10_2"," Logarithm base 10 of 2","/std/math/#item.LOG10_2"],["std::math::LOG10_E"," Logarithm base 10 of E","/std/math/#item.LOG10_E"],["std::math::LOG2_10"," Logarithm base 2 of 10","/std/math/#item.LOG2_10"],["std::math::LOG2_E"," Logarithm base 2 of E","/std/math/#item.LOG2_E"],["std::math::PI"," π","/std/math/#item.PI"],["std::math::SQRT_2"," Square root of 2","/std/math/#item.SQRT_2"],["std::math::TAU"," 2π (also known as τ)","/std/math/#item.TAU"],["std::math::tests::test_abs","","/std/math/tests/#item.test_abs"],["std::math::tests::test_div_floor","","/std/math/tests/#item.test_div_floor"],["std::math::tests::test_various_math","","/std/math/tests/#item.test_various_math"],["std::mem::internal","","/std/mem/internal/"],["std::mem::tests","","/std/mem/tests/"],["std::mem::Freeable"," Types that can be \"freed\".","/std/mem/Freeable.html"],["std::mem::Movable"," Types that implement move semantics","/std/mem/Movable.html"],["std::mem::Clonable"," Types that be copied non-trivially (usually types containing a heap allocation).","/std/mem/Clonable.html"],["std::mem::AsSlice"," Types that can be viewed as slices","/std/mem/AsSlice.html"],["std::mem::AsSliceMut"," Types that can be viewed as mutable slices","/std/mem/AsSliceMut.html"],["std::mem::slice"," Fat pointers to a contiguous region of memory.","/std/mem/slice.html"],["std::mem::SliceIterator"," Iterator over elements of a slice","/std/mem/SliceIterator.html"],["std::mem::SliceRefIterator"," Iterator over pointers to elements of a slice","/std/mem/SliceRefIterator.html"],["std::mem::alloc"," Allocates a single object on the heap using a default allocator (`malloc`)","/std/mem/#item.alloc"],["std::mem::alloc_zeroed"," Allocates a single object on the heap using a default allocator (`malloc`)","/std/mem/#item.alloc_zeroed"],["std::mem::free"," Frees a heap-allocated object","/std/mem/#item.free"],["std::mem::size_of"," Memory size of for a given type in bytes.","/std/mem/#item.size_of"],["std::mem::align_of"," Minimum alignment for given type in bytes.","/std/mem/#item.align_of"],["std::mem::swap"," Swaps the data in two memory locations.","/std/mem/#item.swap"],["std::mem::replace"," Replaces a memory at location `a` with value `b`.","/std/mem/#item.replace"],["std::mem::zeroed"," Zero-initialized object of a given type.","/std/mem/#item.zeroed"],["std::mem::uninitialized"," Uninitialized object.","/std/mem/#item.uninitialized"],["std::mem::AsSlice::as_slice","","/std/mem/AsSlice.html#item.as_slice"],["std::mem::AsSliceMut::as_slice_mut","","/std/mem/AsSliceMut.html#item.as_slice_mut"],["std::mem::Clonable::clone"," Returns a copy of the object.","/std/mem/Clonable.html#item.clone"],["std::mem::Freeable::free"," Frees the memory backing the object.","/std/mem/Freeable.html#item.free"],["std::mem::Movable::move"," Creates a copy of the object, leaving an inert object behind.","/std/mem/Movable.html#item.move"],["std::mem::SliceIterator::next"," Returns the next item, if any.","/std/mem/SliceIterator.html#item.next"],["std::mem::SliceIterator::next_back"," Returns the next item from the back, if any.","/std/mem/SliceIterator.html#item.next_back"],["std::mem::SliceIterator::size_hint"," Returns the number of remaining elements, if available.","/std/mem/SliceIterator.html#item.size_hint"],["std::mem::SliceRefIterator::next"," Returns the next item, if any.","/std/mem/SliceRefIterator.html#item.next"],["std::mem::SliceRefIterator::next_back"," Returns the next item from the back, if any.","/std/mem/SliceRefIterator.html#item.next_back"],["std::mem::SliceRefIterator::size_hint"," Returns the number of remaining elements, if available.","/std/mem/SliceRefIterator.html#item.size_hint"],["std::mem::internal::slice_index"," Implementation for single-element indexing for slices.","/std/mem/internal/#item.slice_index"],["std::mem::internal::slice_range_index"," Implementation for range indexing for slices.","/std/mem/internal/#item.slice_range_index"],["std::mem::internal::slice_const_coerce"," Compiler invokes this function to coerce a mutable slice","/std/mem/internal/#item.slice_const_coerce"],["std::mem::internal::slice_const_cast","","/std/mem/internal/#item.slice_const_cast"],["std::mem::internal::bounds_check","","/std/mem/internal/bounds_check.html"],["std::mem::slice::empty"," Empty slice","/std/mem/slice.html#item.empty"],["std::mem::slice::from_raw"," Create a slice from a pointer and length","/std/mem/slice.html#item.from_raw"],["std::mem::slice::len"," Returns the length of the slice","/std/mem/slice.html#item.len"],["std::mem::slice::as_ptr"," Returns a pointer to the first element of the slice.","/std/mem/slice.html#item.as_ptr"],["std::mem::slice::alloc"," Allocates an array of specified size on the heap.","/std/mem/slice.html#item.alloc"],["std::mem::slice::realloc"," Resizes a heap-allocated array.","/std/mem/slice.html#item.realloc"],["std::mem::slice::alloc_zeroed"," Allocates an array of specified size on the heap.","/std/mem/slice.html#item.alloc_zeroed"],["std::mem::slice::copy_to_nonoverlapping"," Copies a region of memory from `src` to `dst`.","/std/mem/slice.html#item.copy_to_nonoverlapping"],["std::mem::slice::copy_to"," Copies a region of memory from `src` to `dst`.","/std/mem/slice.html#item.copy_to"],["std::mem::slice::to_array"," Copy a slice into a fixed-size array.","/std/mem/slice.html#item.to_array"],["std::mem::slice::iter"," Returns an iterator over the elements of this iterable.","/std/mem/slice.html#item.iter"],["std::mem::slice::iter_ref"," Returns an iterator over the pointers of the items of the collection.","/std/mem/slice.html#item.iter_ref"],["std::mem::slice::iter_mut"," Returns an iterator over mutable pointers to the elements of the collection.","/std/mem/slice.html#item.iter_mut"],["std::mem::slice::fill"," Fill slice with a value","/std/mem/slice.html#item.fill"],["std::mem::slice::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/mem/slice.html#item.equals"],["std::mem::slice::compare"," Compare the value","/std/mem/slice.html#item.compare"],["std::mem::slice::hash"," Update hasher state with the contents of this object.","/std/mem/slice.html#item.hash"],["std::mem::slice::fmt"," Write the object into a given formatter.","/std/mem/slice.html#item.fmt"],["std::mem::slice::free"," Frees the slice.","/std/mem/slice.html#item.free"],["std::mem::tests::slice_range_index","","/std/mem/tests/#item.slice_range_index"],["std::mem::tests::size_of_zst","","/std/mem/tests/#item.size_of_zst"],["std::mem::tests::align_of_zst","","/std/mem/tests/#item.align_of_zst"],["std::mem::tests::test_fill","","/std/mem/tests/#item.test_fill"],["std::mem::tests::test_copy_nonoverlapping","","/std/mem/tests/#item.test_copy_nonoverlapping"],["std::mem::tests::test_copy","","/std/mem/tests/#item.test_copy"],["std::mem::tests::test_slice_equals","","/std/mem/tests/#item.test_slice_equals"],["std::mem::tests::test_slice_compare","","/std/mem/tests/#item.test_slice_compare"],["std::mem::tests::test_bounds_check","","/std/mem/tests/#item.test_bounds_check"],["std::mem::tests::test_bounds_check_1","","/std/mem/tests/#item.test_bounds_check_1"],["std::mem::tests::test_bounds_check_2","","/std/mem/tests/#item.test_bounds_check_2"],["std::mem::tests::test_bounds_check_3","","/std/mem/tests/#item.test_bounds_check_3"],["std::mem::tests::test_bounds_check_4","","/std/mem/tests/#item.test_bounds_check_4"],["std::mem::tests::test_bounds_check_5","","/std/mem/tests/#item.test_bounds_check_5"],["std::mem::tests::test_bounds_check_6","","/std/mem/tests/#item.test_bounds_check_6"],["std::net::unix","","/std/net/unix/"],["std::net::address","","/std/net/address/"],["std::net::Ipv6Addr"," An IPv6 address","/std/net/Ipv6Addr.html"],["std::net::NameLookup"," Domain name resolution iterator","/std/net/NameLookup.html"],["std::net::Socket"," A network or local socket","/std/net/Socket.html"],["std::net::TcpStream"," A TCP connection","/std/net/TcpStream.html"],["std::net::Ipv4Addr"," An IPv4 address","/std/net/Ipv4Addr.html"],["std::net::TcpListener"," A TCP listener which can accept new connections.","/std/net/TcpListener.html"],["std::net::IpAddr"," IP address (IPv6 or IPv4).","/std/net/IpAddr.html"],["std::net::SocketAddr"," Socket address (e.g. IP address and port)","/std/net/SocketAddr.html"],["std::net::UdpSocket"," A UDP socket","/std/net/UdpSocket.html"],["std::net::buffered"," Create a buffered reader/writer pair for a socket.","/std/net/#item.buffered"],["std::net::AddrKind"," Network address family","/std/net/AddrKind.html"],["std::net::Shutdown"," Which end(s) of the socket to shutdown","/std/net/Shutdown.html"],["std::net::AddrKind::V6","","/std/net/AddrKind.html#item.V6"],["std::net::AddrKind::V4","","/std/net/AddrKind.html#item.V4"],["std::net::IpAddr::v6"," IPv6 address","/std/net/IpAddr.html#item.v6"],["std::net::IpAddr::v4"," IPv4 address","/std/net/IpAddr.html#item.v4"],["std::net::IpAddr::fmt"," Write the object into a given formatter.","/std/net/IpAddr.html#item.fmt"],["std::net::IpAddr::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/net/IpAddr.html#item.equals"],["std::net::IpAddr::hash"," Update hasher state with the contents of this object.","/std/net/IpAddr.html#item.hash"],["std::net::Ipv4Addr::new"," Creates a new IPv4 address from four eight-bit octets.","/std/net/Ipv4Addr.html#item.new"],["std::net::Ipv4Addr::localhost"," Localhost IPv4 address (127.0.0.1)","/std/net/Ipv4Addr.html#item.localhost"],["std::net::Ipv4Addr::unspecified"," Unspecified IPv4 address (0.0.0.0)","/std/net/Ipv4Addr.html#item.unspecified"],["std::net::Ipv4Addr::broadcast"," Broadcast IPv4 address (255.255.255.255)","/std/net/Ipv4Addr.html#item.broadcast"],["std::net::Ipv4Addr::from_libc","","/std/net/Ipv4Addr.html#item.from_libc"],["std::net::Ipv4Addr::to_octets"," Returns an array of octets.","/std/net/Ipv4Addr.html#item.to_octets"],["std::net::Ipv4Addr::to_ipv6_compatible"," Returns the IPv4 address as IPv6 compatible address.","/std/net/Ipv4Addr.html#item.to_ipv6_compatible"],["std::net::Ipv4Addr::to_ipv6_mapped"," Returns the IPv4 address as IPv6 mapped address.","/std/net/Ipv4Addr.html#item.to_ipv6_mapped"],["std::net::Ipv4Addr::parse"," Parses an IPv4 address from a string.","/std/net/Ipv4Addr.html#item.parse"],["std::net::Ipv4Addr::fmt"," Write the object into a given formatter.","/std/net/Ipv4Addr.html#item.fmt"],["std::net::Ipv4Addr::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/net/Ipv4Addr.html#item.equals"],["std::net::Ipv4Addr::hash"," Update hasher state with the contents of this object.","/std/net/Ipv4Addr.html#item.hash"],["std::net::Ipv6Addr::new"," Create a new IPv6 address from 16-bit segments","/std/net/Ipv6Addr.html#item.new"],["std::net::Ipv6Addr::from_segments"," Create a new IPv6 address from a slice of 16-bit segments","/std/net/Ipv6Addr.html#item.from_segments"],["std::net::Ipv6Addr::localhost"," Localhost address (`::1`)","/std/net/Ipv6Addr.html#item.localhost"],["std::net::Ipv6Addr::unspecified"," Unspecified address (`::`)","/std/net/Ipv6Addr.html#item.unspecified"],["std::net::Ipv6Addr::from_libc"," Convert `in6_addr` into an IPv6 address","/std/net/Ipv6Addr.html#item.from_libc"],["std::net::Ipv6Addr::to_segments"," Convert IPv6 address to an array of 16-bit segments","/std/net/Ipv6Addr.html#item.to_segments"],["std::net::Ipv6Addr::to_ipv4"," Extract IPv4 address from an IPv6 address if it's a v4-mapped or v4-compat address","/std/net/Ipv6Addr.html#item.to_ipv4"],["std::net::Ipv6Addr::parse"," Parses an IPv6 address from a string.","/std/net/Ipv6Addr.html#item.parse"],["std::net::Ipv6Addr::fmt"," Write the object into a given formatter.","/std/net/Ipv6Addr.html#item.fmt"],["std::net::Ipv6Addr::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/net/Ipv6Addr.html#item.equals"],["std::net::Ipv6Addr::hash"," Update hasher state with the contents of this object.","/std/net/Ipv6Addr.html#item.hash"],["std::net::NameLookup::resolve"," Resolve a hostname to network addresses","/std/net/NameLookup.html#item.resolve"],["std::net::NameLookup::next"," Returns the next item, if any.","/std/net/NameLookup.html#item.next"],["std::net::NameLookup::free"," Frees the memory backing the object.","/std/net/NameLookup.html#item.free"],["std::net::NameLookup::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/NameLookup.html#item.move"],["std::net::Shutdown::Read","","/std/net/Shutdown.html#item.Read"],["std::net::Shutdown::Write","","/std/net/Shutdown.html#item.Write"],["std::net::Shutdown::Both","","/std/net/Shutdown.html#item.Both"],["std::net::Socket::new"," Create a new socket with a given family and type","/std/net/Socket.html#item.new"],["std::net::Socket::as_fd","","/std/net/Socket.html#item.as_fd"],["std::net::Socket::shutdown"," Shuts down the reading or writing end of the socket or both.","/std/net/Socket.html#item.shutdown"],["std::net::Socket::recv_from_with_flags","","/std/net/Socket.html#item.recv_from_with_flags"],["std::net::Socket::recv_with_flags","","/std/net/Socket.html#item.recv_with_flags"],["std::net::Socket::read"," Reads from the stream into a provided buffer.","/std/net/Socket.html#item.read"],["std::net::Socket::peer_addr"," Returns the address of the remote peer","/std/net/Socket.html#item.peer_addr"],["std::net::Socket::socket_addr"," Returns the address of the remote peer","/std/net/Socket.html#item.socket_addr"],["std::net::Socket::close"," Closes the socket.","/std/net/Socket.html#item.close"],["std::net::Socket::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/Socket.html#item.move"],["std::net::SocketAddr::new"," Create SocketAddr from IP address and port","/std/net/SocketAddr.html#item.new"],["std::net::SocketAddr::with_flowinfo_and_scope"," Create SocketAddr from IPv6 address, port, flow info and scope ID.","/std/net/SocketAddr.html#item.with_flowinfo_and_scope"],["std::net::SocketAddr::set_port"," Sets the port number","/std/net/SocketAddr.html#item.set_port"],["std::net::SocketAddr::port"," Returns the port number","/std/net/SocketAddr.html#item.port"],["std::net::SocketAddr::ip"," Returns the IP address","/std/net/SocketAddr.html#item.ip"],["std::net::SocketAddr::parse"," Parses a socket address from a string.","/std/net/SocketAddr.html#item.parse"],["std::net::SocketAddr::fmt"," Write the object into a given formatter.","/std/net/SocketAddr.html#item.fmt"],["std::net::SocketAddr::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/net/SocketAddr.html#item.equals"],["std::net::SocketAddr::hash"," Update hasher state with the contents of this object.","/std/net/SocketAddr.html#item.hash"],["std::net::TcpListener::from_socket"," Create a new TCP listener from a socket.","/std/net/TcpListener.html#item.from_socket"],["std::net::TcpListener::bind"," Creates a new TCP listener bound to the specified address.","/std/net/TcpListener.html#item.bind"],["std::net::TcpListener::as_fd","","/std/net/TcpListener.html#item.as_fd"],["std::net::TcpListener::accept"," Accepts a new incoming connection.","/std/net/TcpListener.html#item.accept"],["std::net::TcpListener::socket_addr"," Returns the address of the remote peer","/std/net/TcpListener.html#item.socket_addr"],["std::net::TcpListener::close"," Closes the socket.","/std/net/TcpListener.html#item.close"],["std::net::TcpListener::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/TcpListener.html#item.move"],["std::net::TcpStream::connect"," Establishes a TCP connection to a remote host.","/std/net/TcpStream.html#item.connect"],["std::net::TcpStream::from_socket"," Create a new TCP stream from a raw socket","/std/net/TcpStream.html#item.from_socket"],["std::net::TcpStream::as_fd","","/std/net/TcpStream.html#item.as_fd"],["std::net::TcpStream::peer_addr"," Returns the address of the remote peer","/std/net/TcpStream.html#item.peer_addr"],["std::net::TcpStream::socket_addr"," Returns the address of the remote peer","/std/net/TcpStream.html#item.socket_addr"],["std::net::TcpStream::shutdown"," Shuts down the reading or writing end of the socket or both.","/std/net/TcpStream.html#item.shutdown"],["std::net::TcpStream::read"," Reads from the stream into a provided buffer.","/std/net/TcpStream.html#item.read"],["std::net::TcpStream::write"," Write the buffer to the stream.","/std/net/TcpStream.html#item.write"],["std::net::TcpStream::flush"," Flush the stream","/std/net/TcpStream.html#item.flush"],["std::net::TcpStream::close"," Closes the socket.","/std/net/TcpStream.html#item.close"],["std::net::TcpStream::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/TcpStream.html#item.move"],["std::net::UdpSocket::from_socket"," Create a new UDP socket from a raw socket.","/std/net/UdpSocket.html#item.from_socket"],["std::net::UdpSocket::bind"," Creates a new UDP socket bound to the specified address.","/std/net/UdpSocket.html#item.bind"],["std::net::UdpSocket::connect"," \"Connects\" the UDP socket to the specified address.","/std/net/UdpSocket.html#item.connect"],["std::net::UdpSocket::recv_from"," Receives data from the socket.","/std/net/UdpSocket.html#item.recv_from"],["std::net::UdpSocket::peek_from"," Receives data from the socket without consuming it.","/std/net/UdpSocket.html#item.peek_from"],["std::net::UdpSocket::send_to"," Sends data to a particular address.","/std/net/UdpSocket.html#item.send_to"],["std::net::UdpSocket::recv"," Receives data from the socket.","/std/net/UdpSocket.html#item.recv"],["std::net::UdpSocket::peek"," Receives data from the socket without consuming it.","/std/net/UdpSocket.html#item.peek"],["std::net::UdpSocket::send"," Sends data to the socket.","/std/net/UdpSocket.html#item.send"],["std::net::UdpSocket::as_fd","","/std/net/UdpSocket.html#item.as_fd"],["std::net::UdpSocket::peer_addr"," Returns the address of the remote peer","/std/net/UdpSocket.html#item.peer_addr"],["std::net::UdpSocket::socket_addr"," Returns the address of the remote peer","/std/net/UdpSocket.html#item.socket_addr"],["std::net::UdpSocket::close"," Closes the socket.","/std/net/UdpSocket.html#item.close"],["std::net::UdpSocket::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/UdpSocket.html#item.move"],["std::net::address::internal","","/std/net/address/internal/"],["std::net::address::tests","","/std/net/address/tests/"],["std::net::address::Ipv6Addr"," An IPv6 address","/std/net/address/Ipv6Addr.html"],["std::net::address::Ipv4Addr"," An IPv4 address","/std/net/address/Ipv4Addr.html"],["std::net::address::IpAddr"," IP address (IPv6 or IPv4).","/std/net/address/IpAddr.html"],["std::net::address::SocketAddr"," Socket address (e.g. IP address and port)","/std/net/address/SocketAddr.html"],["std::net::address::AddrKind"," Network address family","/std/net/address/AddrKind.html"],["std::net::address::AddrKind::V6","","/std/net/address/AddrKind.html#item.V6"],["std::net::address::AddrKind::V4","","/std/net/address/AddrKind.html#item.V4"],["std::net::address::IpAddr::v6"," IPv6 address","/std/net/address/IpAddr.html#item.v6"],["std::net::address::IpAddr::v4"," IPv4 address","/std/net/address/IpAddr.html#item.v4"],["std::net::address::IpAddr::fmt"," Write the object into a given formatter.","/std/net/address/IpAddr.html#item.fmt"],["std::net::address::IpAddr::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/net/address/IpAddr.html#item.equals"],["std::net::address::IpAddr::hash"," Update hasher state with the contents of this object.","/std/net/address/IpAddr.html#item.hash"],["std::net::address::Ipv4Addr::new"," Creates a new IPv4 address from four eight-bit octets.","/std/net/address/Ipv4Addr.html#item.new"],["std::net::address::Ipv4Addr::localhost"," Localhost IPv4 address (127.0.0.1)","/std/net/address/Ipv4Addr.html#item.localhost"],["std::net::address::Ipv4Addr::unspecified"," Unspecified IPv4 address (0.0.0.0)","/std/net/address/Ipv4Addr.html#item.unspecified"],["std::net::address::Ipv4Addr::broadcast"," Broadcast IPv4 address (255.255.255.255)","/std/net/address/Ipv4Addr.html#item.broadcast"],["std::net::address::Ipv4Addr::from_libc","","/std/net/address/Ipv4Addr.html#item.from_libc"],["std::net::address::Ipv4Addr::to_octets"," Returns an array of octets.","/std/net/address/Ipv4Addr.html#item.to_octets"],["std::net::address::Ipv4Addr::to_ipv6_compatible"," Returns the IPv4 address as IPv6 compatible address.","/std/net/address/Ipv4Addr.html#item.to_ipv6_compatible"],["std::net::address::Ipv4Addr::to_ipv6_mapped"," Returns the IPv4 address as IPv6 mapped address.","/std/net/address/Ipv4Addr.html#item.to_ipv6_mapped"],["std::net::address::Ipv4Addr::parse"," Parses an IPv4 address from a string.","/std/net/address/Ipv4Addr.html#item.parse"],["std::net::address::Ipv4Addr::fmt"," Write the object into a given formatter.","/std/net/address/Ipv4Addr.html#item.fmt"],["std::net::address::Ipv4Addr::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/net/address/Ipv4Addr.html#item.equals"],["std::net::address::Ipv4Addr::hash"," Update hasher state with the contents of this object.","/std/net/address/Ipv4Addr.html#item.hash"],["std::net::address::Ipv6Addr::new"," Create a new IPv6 address from 16-bit segments","/std/net/address/Ipv6Addr.html#item.new"],["std::net::address::Ipv6Addr::from_segments"," Create a new IPv6 address from a slice of 16-bit segments","/std/net/address/Ipv6Addr.html#item.from_segments"],["std::net::address::Ipv6Addr::localhost"," Localhost address (`::1`)","/std/net/address/Ipv6Addr.html#item.localhost"],["std::net::address::Ipv6Addr::unspecified"," Unspecified address (`::`)","/std/net/address/Ipv6Addr.html#item.unspecified"],["std::net::address::Ipv6Addr::from_libc"," Convert `in6_addr` into an IPv6 address","/std/net/address/Ipv6Addr.html#item.from_libc"],["std::net::address::Ipv6Addr::to_segments"," Convert IPv6 address to an array of 16-bit segments","/std/net/address/Ipv6Addr.html#item.to_segments"],["std::net::address::Ipv6Addr::to_ipv4"," Extract IPv4 address from an IPv6 address if it's a v4-mapped or v4-compat address","/std/net/address/Ipv6Addr.html#item.to_ipv4"],["std::net::address::Ipv6Addr::parse"," Parses an IPv6 address from a string.","/std/net/address/Ipv6Addr.html#item.parse"],["std::net::address::Ipv6Addr::fmt"," Write the object into a given formatter.","/std/net/address/Ipv6Addr.html#item.fmt"],["std::net::address::Ipv6Addr::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/net/address/Ipv6Addr.html#item.equals"],["std::net::address::Ipv6Addr::hash"," Update hasher state with the contents of this object.","/std/net/address/Ipv6Addr.html#item.hash"],["std::net::address::SocketAddr::new"," Create SocketAddr from IP address and port","/std/net/address/SocketAddr.html#item.new"],["std::net::address::SocketAddr::with_flowinfo_and_scope"," Create SocketAddr from IPv6 address, port, flow info and scope ID.","/std/net/address/SocketAddr.html#item.with_flowinfo_and_scope"],["std::net::address::SocketAddr::set_port"," Sets the port number","/std/net/address/SocketAddr.html#item.set_port"],["std::net::address::SocketAddr::port"," Returns the port number","/std/net/address/SocketAddr.html#item.port"],["std::net::address::SocketAddr::ip"," Returns the IP address","/std/net/address/SocketAddr.html#item.ip"],["std::net::address::SocketAddr::parse"," Parses a socket address from a string.","/std/net/address/SocketAddr.html#item.parse"],["std::net::address::SocketAddr::fmt"," Write the object into a given formatter.","/std/net/address/SocketAddr.html#item.fmt"],["std::net::address::SocketAddr::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/net/address/SocketAddr.html#item.equals"],["std::net::address::SocketAddr::hash"," Update hasher state with the contents of this object.","/std/net/address/SocketAddr.html#item.hash"],["std::net::address::internal::ipv6_parse_part"," Parses A or B for IPv6 addresses in \"A::B\" format","/std/net/address/internal/#item.ipv6_parse_part"],["std::net::address::internal::IpAddrInner","","/std/net/address/internal/IpAddrInner.html"],["std::net::address::internal::SocketAddrInner","","/std/net/address/internal/SocketAddrInner.html"],["std::net::address::tests::test_addr","","/std/net/address/tests/#item.test_addr"],["std::net::address::tests::test_addr_mapped","","/std/net/address/tests/#item.test_addr_mapped"],["std::net::address::tests::test_ipv4_addr","","/std/net/address/tests/#item.test_ipv4_addr"],["std::net::address::tests::test_socket_addr","","/std/net/address/tests/#item.test_socket_addr"],["std::net::address::tests::test_socket_addr_with_scope_id","","/std/net/address/tests/#item.test_socket_addr_with_scope_id"],["std::net::address::tests::test_ipv4_socket_addr","","/std/net/address/tests/#item.test_ipv4_socket_addr"],["std::net::address::tests::test_ipv6_parse","","/std/net/address/tests/#item.test_ipv6_parse"],["std::net::address::tests::test_ipv6_parse_invalid","","/std/net/address/tests/#item.test_ipv6_parse_invalid"],["std::net::address::tests::test_ipv4_parse","","/std/net/address/tests/#item.test_ipv4_parse"],["std::net::address::tests::test_hash","","/std/net/address/tests/#item.test_hash"],["std::net::address::tests::test_sa_parse","","/std/net/address/tests/#item.test_sa_parse"],["std::net::address::tests::test_sa_parse_invalid","","/std/net/address/tests/#item.test_sa_parse_invalid"],["std::net::address::tests::fmt","","/std/net/address/tests/fmt.html"],["std::net::address::tests::fmt_ipv6","","/std/net/address/tests/fmt_ipv6.html"],["std::net::address::tests::roundtrip_v6","","/std/net/address/tests/roundtrip_v6.html"],["std::net::address::tests::fail_v6","","/std/net/address/tests/fail_v6.html"],["std::net::address::tests::roundtrip_sa","","/std/net/address/tests/roundtrip_sa.html"],["std::net::address::tests::fail_sa","","/std/net/address/tests/fail_sa.html"],["std::net::address::tests::BUF","","/std/net/address/tests/#item.BUF"],["std::net::unix::internal","","/std/net/unix/internal/"],["std::net::unix::tests","","/std/net/unix/tests/"],["std::net::unix::NameLookup"," Domain name resolution iterator","/std/net/unix/NameLookup.html"],["std::net::unix::Socket"," A network or local socket","/std/net/unix/Socket.html"],["std::net::unix::TcpStream"," A TCP connection","/std/net/unix/TcpStream.html"],["std::net::unix::TcpListener"," A TCP listener which can accept new connections.","/std/net/unix/TcpListener.html"],["std::net::unix::UdpSocket"," A UDP socket","/std/net/unix/UdpSocket.html"],["std::net::unix::Shutdown"," Which end(s) of the socket to shutdown","/std/net/unix/Shutdown.html"],["std::net::unix::MSG_NOSIGNAL","","/std/net/unix/#item.MSG_NOSIGNAL"],["std::net::unix::NameLookup::resolve"," Resolve a hostname to network addresses","/std/net/unix/NameLookup.html#item.resolve"],["std::net::unix::NameLookup::next"," Returns the next item, if any.","/std/net/unix/NameLookup.html#item.next"],["std::net::unix::NameLookup::free"," Frees the memory backing the object.","/std/net/unix/NameLookup.html#item.free"],["std::net::unix::NameLookup::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/unix/NameLookup.html#item.move"],["std::net::unix::Shutdown::Read","","/std/net/unix/Shutdown.html#item.Read"],["std::net::unix::Shutdown::Write","","/std/net/unix/Shutdown.html#item.Write"],["std::net::unix::Shutdown::Both","","/std/net/unix/Shutdown.html#item.Both"],["std::net::unix::Socket::new"," Create a new socket with a given family and type","/std/net/unix/Socket.html#item.new"],["std::net::unix::Socket::as_fd","","/std/net/unix/Socket.html#item.as_fd"],["std::net::unix::Socket::shutdown"," Shuts down the reading or writing end of the socket or both.","/std/net/unix/Socket.html#item.shutdown"],["std::net::unix::Socket::recv_from_with_flags","","/std/net/unix/Socket.html#item.recv_from_with_flags"],["std::net::unix::Socket::recv_with_flags","","/std/net/unix/Socket.html#item.recv_with_flags"],["std::net::unix::Socket::read"," Reads from the stream into a provided buffer.","/std/net/unix/Socket.html#item.read"],["std::net::unix::Socket::peer_addr"," Returns the address of the remote peer","/std/net/unix/Socket.html#item.peer_addr"],["std::net::unix::Socket::socket_addr"," Returns the address of the remote peer","/std/net/unix/Socket.html#item.socket_addr"],["std::net::unix::Socket::close"," Closes the socket.","/std/net/unix/Socket.html#item.close"],["std::net::unix::Socket::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/unix/Socket.html#item.move"],["std::net::unix::TcpListener::from_socket"," Create a new TCP listener from a socket.","/std/net/unix/TcpListener.html#item.from_socket"],["std::net::unix::TcpListener::bind"," Creates a new TCP listener bound to the specified address.","/std/net/unix/TcpListener.html#item.bind"],["std::net::unix::TcpListener::as_fd","","/std/net/unix/TcpListener.html#item.as_fd"],["std::net::unix::TcpListener::accept"," Accepts a new incoming connection.","/std/net/unix/TcpListener.html#item.accept"],["std::net::unix::TcpListener::socket_addr"," Returns the address of the remote peer","/std/net/unix/TcpListener.html#item.socket_addr"],["std::net::unix::TcpListener::close"," Closes the socket.","/std/net/unix/TcpListener.html#item.close"],["std::net::unix::TcpListener::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/unix/TcpListener.html#item.move"],["std::net::unix::TcpStream::connect"," Establishes a TCP connection to a remote host.","/std/net/unix/TcpStream.html#item.connect"],["std::net::unix::TcpStream::from_socket"," Create a new TCP stream from a raw socket","/std/net/unix/TcpStream.html#item.from_socket"],["std::net::unix::TcpStream::as_fd","","/std/net/unix/TcpStream.html#item.as_fd"],["std::net::unix::TcpStream::peer_addr"," Returns the address of the remote peer","/std/net/unix/TcpStream.html#item.peer_addr"],["std::net::unix::TcpStream::socket_addr"," Returns the address of the remote peer","/std/net/unix/TcpStream.html#item.socket_addr"],["std::net::unix::TcpStream::shutdown"," Shuts down the reading or writing end of the socket or both.","/std/net/unix/TcpStream.html#item.shutdown"],["std::net::unix::TcpStream::read"," Reads from the stream into a provided buffer.","/std/net/unix/TcpStream.html#item.read"],["std::net::unix::TcpStream::write"," Write the buffer to the stream.","/std/net/unix/TcpStream.html#item.write"],["std::net::unix::TcpStream::flush"," Flush the stream","/std/net/unix/TcpStream.html#item.flush"],["std::net::unix::TcpStream::close"," Closes the socket.","/std/net/unix/TcpStream.html#item.close"],["std::net::unix::TcpStream::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/unix/TcpStream.html#item.move"],["std::net::unix::UdpSocket::from_socket"," Create a new UDP socket from a raw socket.","/std/net/unix/UdpSocket.html#item.from_socket"],["std::net::unix::UdpSocket::bind"," Creates a new UDP socket bound to the specified address.","/std/net/unix/UdpSocket.html#item.bind"],["std::net::unix::UdpSocket::connect"," \"Connects\" the UDP socket to the specified address.","/std/net/unix/UdpSocket.html#item.connect"],["std::net::unix::UdpSocket::recv_from"," Receives data from the socket.","/std/net/unix/UdpSocket.html#item.recv_from"],["std::net::unix::UdpSocket::peek_from"," Receives data from the socket without consuming it.","/std/net/unix/UdpSocket.html#item.peek_from"],["std::net::unix::UdpSocket::send_to"," Sends data to a particular address.","/std/net/unix/UdpSocket.html#item.send_to"],["std::net::unix::UdpSocket::recv"," Receives data from the socket.","/std/net/unix/UdpSocket.html#item.recv"],["std::net::unix::UdpSocket::peek"," Receives data from the socket without consuming it.","/std/net/unix/UdpSocket.html#item.peek"],["std::net::unix::UdpSocket::send"," Sends data to the socket.","/std/net/unix/UdpSocket.html#item.send"],["std::net::unix::UdpSocket::as_fd","","/std/net/unix/UdpSocket.html#item.as_fd"],["std::net::unix::UdpSocket::peer_addr"," Returns the address of the remote peer","/std/net/unix/UdpSocket.html#item.peer_addr"],["std::net::unix::UdpSocket::socket_addr"," Returns the address of the remote peer","/std/net/unix/UdpSocket.html#item.socket_addr"],["std::net::unix::UdpSocket::close"," Closes the socket.","/std/net/unix/UdpSocket.html#item.close"],["std::net::unix::UdpSocket::move"," Creates a copy of the object, leaving an inert object behind.","/std/net/unix/UdpSocket.html#item.move"],["std::net::unix::internal::sockaddr_to_addr","","/std/net/unix/internal/#item.sockaddr_to_addr"],["std::net::unix::internal::addr_to_family","","/std/net/unix/internal/#item.addr_to_family"],["std::net::unix::tests::fork","","/std/net/unix/tests/#item.fork"],["std::net::unix::tests::test_name_resolution","","/std/net/unix/tests/#item.test_name_resolution"],["std::net::unix::tests::test_basic_tcp","","/std/net/unix/tests/#item.test_basic_tcp"],["std::net::unix::tests::test_basic_udp","","/std/net/unix/tests/#item.test_basic_udp"],["std::net::unix::tests::test_udp_connect","","/std/net/unix/tests/#item.test_udp_connect"],["std::net::unix::tests::test_udp_peek","","/std/net/unix/tests/#item.test_udp_peek"],["std::option::internal","","/std/option/internal/"],["std::option::tests","","/std/option/tests/"],["std::option::Option"," Optional value","/std/option/Option.html"],["std::option::try"," Extract the value or short-circuit the calling function.","/std/option/try.html"],["std::option::Option::some"," Create a populated `Option` value","/std/option/Option.html#item.some"],["std::option::Option::none"," Create an empty `Option` value","/std/option/Option.html#item.none"],["std::option::Option::is_some"," Returns `true` if the option is populated, `false` otherwise.","/std/option/Option.html#item.is_some"],["std::option::Option::unwrap"," Returns a value, if present, panic otherwise.","/std/option/Option.html#item.unwrap"],["std::option::Option::ok_or"," Convert the option into a [std::result::Result].","/std/option/Option.html#item.ok_or"],["std::option::Option::ok_or_else"," Convert the option into a [std::result::Result].","/std/option/Option.html#item.ok_or_else"],["std::option::Option::unwrap_or"," Returns a value, if present, otherwise return a default value.","/std/option/Option.html#item.unwrap_or"],["std::option::Option::unwrap_or_else"," Returns a value, if present, otherwise invoke func to get the default.","/std/option/Option.html#item.unwrap_or_else"],["std::option::Option::map"," Transform the value inside the `Option` by calling the provided function.","/std/option/Option.html#item.map"],["std::option::Option::and"," If `self` is none, return none, otherwise return `other`","/std/option/Option.html#item.and"],["std::option::Option::and_then"," If `self` is none, return none, otherwise return the result of","/std/option/Option.html#item.and_then"],["std::option::Option::or"," Return `self` if it is populated, otherwise return `other`.","/std/option/Option.html#item.or"],["std::option::Option::or_else"," Return `self` if it is populated, otherwise return the result of","/std/option/Option.html#item.or_else"],["std::option::Option::as_nullable_ptr"," Returns pointer to inner or a null pointer if not present.","/std/option/Option.html#item.as_nullable_ptr"],["std::option::Option::as_ptr"," Transform a pointer to `Option` to an `Option` of pointer.","/std/option/Option.html#item.as_ptr"],["std::option::Option::as_mut_ptr"," Transform a mutable pointer to `Option` to an `Option` of mutable pointer.","/std/option/Option.html#item.as_mut_ptr"],["std::option::Option::flatten"," Flattens a nested `Option` into a single `Option`.","/std/option/Option.html#item.flatten"],["std::option::Option::zip"," Merges two `Option`s into an `Option` of a tuple.","/std/option/Option.html#item.zip"],["std::option::Option::iter"," Returns an iterator over the elements of this iterable.","/std/option/Option.html#item.iter"],["std::option::Option::move"," Creates a copy of the object, leaving an inert object behind.","/std/option/Option.html#item.move"],["std::option::Option::transpose"," Convert `Option<Result<T, E>>` to `Result<Option<T>, E>`","/std/option/Option.html#item.transpose"],["std::option::Option::hash"," Update hasher state with the contents of this object.","/std/option/Option.html#item.hash"],["std::option::Option::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/option/Option.html#item.equals"],["std::option::Option::compare"," Compare the value","/std/option/Option.html#item.compare"],["std::option::Option::fmt"," Write the object into a given formatter.","/std/option/Option.html#item.fmt"],["std::option::Option::free"," Frees the memory backing the object.","/std/option/Option.html#item.free"],["std::option::internal::unwrap_panic","","/std/option/internal/#item.unwrap_panic"],["std::option::tests::option_ok","","/std/option/tests/#item.option_ok"],["std::option::tests::option_none","","/std/option/tests/#item.option_none"],["std::option::tests::option_equals","","/std/option/tests/#item.option_equals"],["std::option::tests::option_compare","","/std/option/tests/#item.option_compare"],["std::option::tests::option_fmt","","/std/option/tests/#item.option_fmt"],["std::option::tests::option_iter","","/std/option/tests/#item.option_iter"],["std::option::tests::option_ok_or","","/std/option/tests/#item.option_ok_or"],["std::option::tests::option_ok_or_else","","/std/option/tests/#item.option_ok_or_else"],["std::option::tests::option_move","","/std/option/tests/#item.option_move"],["std::option::tests::option_unwrap","","/std/option/tests/#item.option_unwrap"],["std::option::tests::option_unwrap_none","","/std/option/tests/#item.option_unwrap_none"],["std::option::tests::option_unwrap_or","","/std/option/tests/#item.option_unwrap_or"],["std::option::tests::hash","","/std/option/tests/#item.hash"],["std::option::tests::test_hash","","/std/option/tests/#item.test_hash"],["std::option::tests::fmt","","/std/option/tests/fmt.html"],["std::option::tests::BUF","","/std/option/tests/#item.BUF"],["std::panicking::internal","","/std/panicking/internal/"],["std::panicking::PanicInfo","","/std/panicking/PanicInfo.html"],["std::panicking::panic"," Ungracefully terminate the thread or process with an error message.","/std/panicking/panic.html"],["std::panicking::internal::PanicFormatter"," Small formatter with as few dependencies as possible.","/std/panicking/internal/PanicFormatter.html"],["std::panicking::internal::backtrace","","/std/panicking/internal/#item.backtrace"],["std::panicking::internal::backtrace_symbols","","/std/panicking/internal/#item.backtrace_symbols"],["std::panicking::internal::backtrace_symbols_fd","","/std/panicking/internal/#item.backtrace_symbols_fd"],["std::panicking::internal::set_panic_hook","","/std/panicking/internal/#item.set_panic_hook"],["std::panicking::internal::print_panic_message","","/std/panicking/internal/#item.print_panic_message"],["std::panicking::internal::panic_impl","","/std/panicking/internal/#item.panic_impl"],["std::panicking::internal::PANICKING","","/std/panicking/internal/#item.PANICKING"],["std::panicking::internal::PANIC_HOOK","","/std/panicking/internal/#item.PANIC_HOOK"],["std::panicking::internal::PanicFormatter::write_str","","/std/panicking/internal/PanicFormatter.html#item.write_str"],["std::prelude::void"," Unit type (`()`)","/std/prelude/void.html"],["std::prelude::bool"," Boolean type","/std/prelude/bool.html"],["std::prelude::u8"," 8-bit unsigned integer (byte)","/std/prelude/u8.html"],["std::prelude::u16"," 16-bit unsigned integer","/std/prelude/u16.html"],["std::prelude::u32"," 32-bit unsigned integer","/std/prelude/u32.html"],["std::prelude::u64"," 64-bit unsigned integer","/std/prelude/u64.html"],["std::prelude::u128"," 128-bit unsigned integer","/std/prelude/u128.html"],["std::prelude::usize"," Native unsigned integer (machine word)","/std/prelude/usize.html"],["std::prelude::i8"," Signed 8-bit integer","/std/prelude/i8.html"],["std::prelude::i16"," Signed 16-bit integer","/std/prelude/i16.html"],["std::prelude::i32"," Signed 32-bit integer","/std/prelude/i32.html"],["std::prelude::i64"," Signed 64-bit integer","/std/prelude/i64.html"],["std::prelude::i128"," Signed 128-bit integer","/std/prelude/i128.html"],["std::prelude::isize"," Native signed integer (machine word)","/std/prelude/isize.html"],["std::prelude::f32"," Single precision floating point type","/std/prelude/f32.html"],["std::prelude::f64"," Double precision floating point type","/std/prelude/f64.html"],["std::prelude::Self"," A placeholder for the `Self` type in the protocol of a `dyn` object.","/std/prelude/Self.html"],["std::prelude::Option"," Optional value","/std/prelude/Option.html"],["std::prelude::Result"," Either a success value or an error value.","/std/prelude/Result.html"],["std::prelude::print"," Prints a formatted string to standard output.","/std/prelude/print.html"],["std::prelude::panic"," Ungracefully terminate the thread or process with an error message.","/std/prelude/panic.html"],["std::prelude::println"," Prints a formatted string to standard output with newline.","/std/prelude/println.html"],["std::prelude::compile_fail"," Causes the compilation to fail if reached.","/std/prelude/compile_fail.html"],["std::prelude::eprint"," Prints a formatted string to standard error.","/std/prelude/eprint.html"],["std::prelude::eprintln"," Prints a formatted string to standard error with newline.","/std/prelude/eprintln.html"],["std::prelude::try"," Extract the success value or short-circuit the calling function.","/std/prelude/try.html"],["std::prelude::assert"," Panics if `cond` evaluates to false.","/std/prelude/assert.html"],["std::prelude::assert_eq"," Panics if `lhs` and `rhs` are not equal.","/std/prelude/assert_eq.html"],["std::prelude::assert_ne"," Panics if `lhs` and `rhs` are equal.","/std/prelude/assert_ne.html"],["std::prelude::unreachable"," Treats the location as unreachable during program flow.","/std/prelude/unreachable.html"],["std::prelude::dbg"," A helper for printing a value of a subexpression for debugging purposes.","/std/prelude/dbg.html"],["std::prelude::Option::some"," Create a populated `Option` value","/std/prelude/Option.html#item.some"],["std::prelude::Option::none"," Create an empty `Option` value","/std/prelude/Option.html#item.none"],["std::prelude::Option::is_some"," Returns `true` if the option is populated, `false` otherwise.","/std/prelude/Option.html#item.is_some"],["std::prelude::Option::unwrap"," Returns a value, if present, panic otherwise.","/std/prelude/Option.html#item.unwrap"],["std::prelude::Option::ok_or"," Convert the option into a [std::result::Result].","/std/prelude/Option.html#item.ok_or"],["std::prelude::Option::ok_or_else"," Convert the option into a [std::result::Result].","/std/prelude/Option.html#item.ok_or_else"],["std::prelude::Option::unwrap_or"," Returns a value, if present, otherwise return a default value.","/std/prelude/Option.html#item.unwrap_or"],["std::prelude::Option::unwrap_or_else"," Returns a value, if present, otherwise invoke func to get the default.","/std/prelude/Option.html#item.unwrap_or_else"],["std::prelude::Option::map"," Transform the value inside the `Option` by calling the provided function.","/std/prelude/Option.html#item.map"],["std::prelude::Option::and"," If `self` is none, return none, otherwise return `other`","/std/prelude/Option.html#item.and"],["std::prelude::Option::and_then"," If `self` is none, return none, otherwise return the result of","/std/prelude/Option.html#item.and_then"],["std::prelude::Option::or"," Return `self` if it is populated, otherwise return `other`.","/std/prelude/Option.html#item.or"],["std::prelude::Option::or_else"," Return `self` if it is populated, otherwise return the result of","/std/prelude/Option.html#item.or_else"],["std::prelude::Option::as_nullable_ptr"," Returns pointer to inner or a null pointer if not present.","/std/prelude/Option.html#item.as_nullable_ptr"],["std::prelude::Option::as_ptr"," Transform a pointer to `Option` to an `Option` of pointer.","/std/prelude/Option.html#item.as_ptr"],["std::prelude::Option::as_mut_ptr"," Transform a mutable pointer to `Option` to an `Option` of mutable pointer.","/std/prelude/Option.html#item.as_mut_ptr"],["std::prelude::Option::flatten"," Flattens a nested `Option` into a single `Option`.","/std/prelude/Option.html#item.flatten"],["std::prelude::Option::zip"," Merges two `Option`s into an `Option` of a tuple.","/std/prelude/Option.html#item.zip"],["std::prelude::Option::iter"," Returns an iterator over the elements of this iterable.","/std/prelude/Option.html#item.iter"],["std::prelude::Option::move"," Creates a copy of the object, leaving an inert object behind.","/std/prelude/Option.html#item.move"],["std::prelude::Option::transpose"," Convert `Option<Result<T, E>>` to `Result<Option<T>, E>`","/std/prelude/Option.html#item.transpose"],["std::prelude::Option::hash"," Update hasher state with the contents of this object.","/std/prelude/Option.html#item.hash"],["std::prelude::Option::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/prelude/Option.html#item.equals"],["std::prelude::Option::compare"," Compare the value","/std/prelude/Option.html#item.compare"],["std::prelude::Option::fmt"," Write the object into a given formatter.","/std/prelude/Option.html#item.fmt"],["std::prelude::Option::free"," Frees the memory backing the object.","/std/prelude/Option.html#item.free"],["std::prelude::Option::Movable"," Types that implement move semantics","/std/prelude/Option/Movable.html"],["std::prelude::Option::Hasher"," Hashing algorithms.","/std/prelude/Option/Hasher.html"],["std::prelude::Option::Formattable"," Types that can be formatted. This is the standard way to implement custom","/std/prelude/Option/Formattable.html"],["std::prelude::Option::write"," Write a formatted string into a given formatter.","/std/prelude/Option/write.html"],["std::prelude::Option::Formattable::fmt"," Write the object into a given formatter.","/std/prelude/Option/Formattable.html#item.fmt"],["std::prelude::Option::Hasher::new"," Create a new hasher.","/std/prelude/Option/Hasher.html#item.new"],["std::prelude::Option::Hasher::write"," Write a byte slice into a hasher.","/std/prelude/Option/Hasher.html#item.write"],["std::prelude::Option::Hasher::finish"," Finalize the hashing and return the hash value.","/std/prelude/Option/Hasher.html#item.finish"],["std::prelude::Option::Movable::move"," Creates a copy of the object, leaving an inert object behind.","/std/prelude/Option/Movable.html#item.move"],["std::prelude::Result::ok"," Create a success variant","/std/prelude/Result.html#item.ok"],["std::prelude::Result::err"," Create a error variant","/std/prelude/Result.html#item.err"],["std::prelude::Result::is_ok"," Returns `true` if the result conains an OK variant, `false` otherwise","/std/prelude/Result.html#item.is_ok"],["std::prelude::Result::is_err"," Returns `true` if the result conains an error variant, `false` otherwise","/std/prelude/Result.html#item.is_err"],["std::prelude::Result::get"," Converts from `Result<T, E>` to `Option<T>`.","/std/prelude/Result.html#item.get"],["std::prelude::Result::get_err"," Converts from `Result<T, E>` to `Option<E>`.","/std/prelude/Result.html#item.get_err"],["std::prelude::Result::unwrap"," Return the success value, panicking if error value is present","/std/prelude/Result.html#item.unwrap"],["std::prelude::Result::unwrap_err"," Return the error value, panicking if success value is present","/std/prelude/Result.html#item.unwrap_err"],["std::prelude::Result::unwrap_or"," Return the success value or a default value","/std/prelude/Result.html#item.unwrap_or"],["std::prelude::Result::unwrap_or_else"," Return the success value or a default value provided by a callback","/std/prelude/Result.html#item.unwrap_or_else"],["std::prelude::Result::map"," Transform the success value inside the `Result` by calling the provided function.","/std/prelude/Result.html#item.map"],["std::prelude::Result::map_err"," Transform the error value inside the `Result` by calling the provided function.","/std/prelude/Result.html#item.map_err"],["std::prelude::Result::and_then"," Transform the value inside the `Result` by calling the provided function, which returns a","/std/prelude/Result.html#item.and_then"],["std::prelude::Result::transpose"," Convert `Result<Option<T>, E>` to `Option<Result<T, E>>`","/std/prelude/Result.html#item.transpose"],["std::prelude::Result::fmt"," Write the object into a given formatter.","/std/prelude/Result.html#item.fmt"],["std::prelude::Result::hash"," Update hasher state with the contents of this object.","/std/prelude/Result.html#item.hash"],["std::prelude::Result::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/prelude/Result.html#item.equals"],["std::prelude::Result::move"," Creates a copy of the object, leaving an inert object behind.","/std/prelude/Result.html#item.move"],["std::prelude::Result::free"," Frees the memory backing the object.","/std/prelude/Result.html#item.free"],["std::prelude::Result::Freeable"," Types that can be \"freed\".","/std/prelude/Result/Freeable.html"],["std::prelude::Result::Equatable"," Types that can be compared for equality.","/std/prelude/Result/Equatable.html"],["std::prelude::Result::Formatter"," A sink for string formatting operations","/std/prelude/Result/Formatter.html"],["std::prelude::Result::Movable"," Types that implement move semantics","/std/prelude/Result/Movable.html"],["std::prelude::Result::Hasher"," Hashing algorithms.","/std/prelude/Result/Hasher.html"],["std::prelude::Result::Formattable"," Types that can be formatted. This is the standard way to implement custom","/std/prelude/Result/Formattable.html"],["std::prelude::Result::Hashable"," Types that can be hashed.","/std/prelude/Result/Hashable.html"],["std::prelude::Result::write"," Write a formatted string into a given formatter.","/std/prelude/Result/write.html"],["std::prelude::Result::Equatable::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/prelude/Result/Equatable.html#item.equals"],["std::prelude::Result::Equatable::not_equals"," Returns `false` if arguments are equal, `true` otherwise","/std/prelude/Result/Equatable.html#item.not_equals"],["std::prelude::Result::Formattable::fmt"," Write the object into a given formatter.","/std/prelude/Result/Formattable.html#item.fmt"],["std::prelude::Result::Formatter::write_str"," Write a string","/std/prelude/Result/Formatter.html#item.write_str"],["std::prelude::Result::Formatter::write_char"," Write a single character","/std/prelude/Result/Formatter.html#item.write_char"],["std::prelude::Result::Freeable::free"," Frees the memory backing the object.","/std/prelude/Result/Freeable.html#item.free"],["std::prelude::Result::Hashable::hash"," Update hasher state with the contents of this object.","/std/prelude/Result/Hashable.html#item.hash"],["std::prelude::Result::Hasher::new"," Create a new hasher.","/std/prelude/Result/Hasher.html#item.new"],["std::prelude::Result::Hasher::write"," Write a byte slice into a hasher.","/std/prelude/Result/Hasher.html#item.write"],["std::prelude::Result::Hasher::finish"," Finalize the hashing and return the hash value.","/std/prelude/Result/Hasher.html#item.finish"],["std::prelude::Result::Hasher::size_of"," Memory size of for a given type in bytes.","/std/prelude/Result/Hasher.html#item.size_of"],["std::prelude::Result::Movable::move"," Creates a copy of the object, leaving an inert object behind.","/std/prelude/Result/Movable.html#item.move"],["std::prelude::bool::max_value"," Returns `true`.","/std/prelude/bool.html#item.max_value"],["std::prelude::bool::min_value"," Returns `false`.","/std/prelude/bool.html#item.min_value"],["std::prelude::bool::then_some"," Convert boolean into an [Option] with a given value.","/std/prelude/bool.html#item.then_some"],["std::prelude::bool::then"," Convert boolean into an [Option] with a value provided by a closure.","/std/prelude/bool.html#item.then"],["std::prelude::bool::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/prelude/bool.html#item.equals"],["std::prelude::bool::compare"," Compare the value","/std/prelude/bool.html#item.compare"],["std::prelude::bool::hash"," Update hasher state with the contents of this object.","/std/prelude/bool.html#item.hash"],["std::prelude::bool::fmt"," Write the object into a given formatter.","/std/prelude/bool.html#item.fmt"],["std::prelude::f32::is_sign_negative"," Returns `true` if the number has a negative sign, `false` otherwise.","/std/prelude/f32.html#item.is_sign_negative"],["std::prelude::f32::max_value"," Returns the maximum value of `f32`.","/std/prelude/f32.html#item.max_value"],["std::prelude::f32::min_value"," Returns the minimum value of `f32`.","/std/prelude/f32.html#item.min_value"],["std::prelude::f32::min_positive"," Returns the smallest positive value of `f32`.","/std/prelude/f32.html#item.min_positive"],["std::prelude::f32::epsilon"," Returns the machine epsilon for `f32`.","/std/prelude/f32.html#item.epsilon"],["std::prelude::f32::acos"," Inverse cosine","/std/prelude/f32.html#item.acos"],["std::prelude::f32::asin"," Inverse sine","/std/prelude/f32.html#item.asin"],["std::prelude::f32::atan"," Inverse tangent","/std/prelude/f32.html#item.atan"],["std::prelude::f32::atan2"," Four-quadrant inverse tangent","/std/prelude/f32.html#item.atan2"],["std::prelude::f32::atanh"," Inverse hyperbolic cosine","/std/prelude/f32.html#item.atanh"],["std::prelude::f32::cbrt"," Cube root","/std/prelude/f32.html#item.cbrt"],["std::prelude::f32::ceil"," Ceiling of number","/std/prelude/f32.html#item.ceil"],["std::prelude::f32::cos"," Cosine","/std/prelude/f32.html#item.cos"],["std::prelude::f32::cosh"," Hyperbolic cosine","/std/prelude/f32.html#item.cosh"],["std::prelude::f32::erf"," Gauss error function","/std/prelude/f32.html#item.erf"],["std::prelude::f32::erfc"," Complementary error function (1 - [erf(self)](erf))","/std/prelude/f32.html#item.erfc"],["std::prelude::f32::exp"," Exponential function (e^`self`)","/std/prelude/f32.html#item.exp"],["std::prelude::f32::floor"," Floor of number","/std/prelude/f32.html#item.floor"],["std::prelude::f32::frexp"," Decomposes `self` into a normalized fractional part and an integral power of two.","/std/prelude/f32.html#item.frexp"],["std::prelude::f32::ldexp"," Multiplies `self` by 2 raised to the power of `exp`.","/std/prelude/f32.html#item.ldexp"],["std::prelude::f32::log"," Natural logarithm","/std/prelude/f32.html#item.log"],["std::prelude::f32::log2"," Base 2 logarithm","/std/prelude/f32.html#item.log2"],["std::prelude::f32::log10"," Base 10 logarithm","/std/prelude/f32.html#item.log10"],["std::prelude::f32::modf"," Decompose `self` into a whole and fractional part","/std/prelude/f32.html#item.modf"],["std::prelude::f32::pow"," Power function","/std/prelude/f32.html#item.pow"],["std::prelude::f32::round"," Rounds `self` to the closest integer.","/std/prelude/f32.html#item.round"],["std::prelude::f32::sin"," Sine function","/std/prelude/f32.html#item.sin"],["std::prelude::f32::sinh"," Hyperbolic sine function","/std/prelude/f32.html#item.sinh"],["std::prelude::f32::sqrt"," Square root","/std/prelude/f32.html#item.sqrt"],["std::prelude::f32::tan"," Tangent function","/std/prelude/f32.html#item.tan"],["std::prelude::f32::tanh"," Hyperbolic tangent function","/std/prelude/f32.html#item.tanh"],["std::prelude::f32::trunc"," Returns the integer part of `self` (round towards zero).","/std/prelude/f32.html#item.trunc"],["std::prelude::f64::is_sign_negative"," Returns `true` if the number has a negative sign, `false` otherwise.","/std/prelude/f64.html#item.is_sign_negative"],["std::prelude::f64::max_value"," Returns the maximum value of `f64`","/std/prelude/f64.html#item.max_value"],["std::prelude::f64::min_value"," Returns the minimum value of `f64`","/std/prelude/f64.html#item.min_value"],["std::prelude::f64::min_positive"," Returns the smallest positive value of `f64`.","/std/prelude/f64.html#item.min_positive"],["std::prelude::f64::epsilon"," Returns the machine epsilon for `f64`.","/std/prelude/f64.html#item.epsilon"],["std::prelude::f64::acos"," Inverse cosine","/std/prelude/f64.html#item.acos"],["std::prelude::f64::asin"," Inverse sine","/std/prelude/f64.html#item.asin"],["std::prelude::f64::atan"," Inverse tangent","/std/prelude/f64.html#item.atan"],["std::prelude::f64::atan2"," Four-quadrant inverse tangent","/std/prelude/f64.html#item.atan2"],["std::prelude::f64::atanh"," Inverse hyperbolic cosine","/std/prelude/f64.html#item.atanh"],["std::prelude::f64::cbrt"," Cube root","/std/prelude/f64.html#item.cbrt"],["std::prelude::f64::ceil"," Ceiling of number","/std/prelude/f64.html#item.ceil"],["std::prelude::f64::cos"," Cosine","/std/prelude/f64.html#item.cos"],["std::prelude::f64::cosh"," Hyperbolic cosine","/std/prelude/f64.html#item.cosh"],["std::prelude::f64::erf"," Gauss error function","/std/prelude/f64.html#item.erf"],["std::prelude::f64::erfc"," Complementary error function (1 - [erf(self)](erf))","/std/prelude/f64.html#item.erfc"],["std::prelude::f64::exp"," Exponential function (e^`self`)","/std/prelude/f64.html#item.exp"],["std::prelude::f64::floor"," Floor of number","/std/prelude/f64.html#item.floor"],["std::prelude::f64::frexp"," Decomposes `self` into a normalized fractional part and an integral power of two.","/std/prelude/f64.html#item.frexp"],["std::prelude::f64::ldexp"," Multiplies `self` by 2 raised to the power of `exp`.","/std/prelude/f64.html#item.ldexp"],["std::prelude::f64::log"," Natural logarithm","/std/prelude/f64.html#item.log"],["std::prelude::f64::log2"," Base 2 logarithm","/std/prelude/f64.html#item.log2"],["std::prelude::f64::log10"," Base 10 logarithm","/std/prelude/f64.html#item.log10"],["std::prelude::f64::modf"," Decompose `self` into a whole and fractional part","/std/prelude/f64.html#item.modf"],["std::prelude::f64::pow"," Power function","/std/prelude/f64.html#item.pow"],["std::prelude::f64::round"," Rounds `self` to the closest integer.","/std/prelude/f64.html#item.round"],["std::prelude::f64::sin"," Sine function","/std/prelude/f64.html#item.sin"],["std::prelude::f64::sinh"," Hyperbolic sine function","/std/prelude/f64.html#item.sinh"],["std::prelude::f64::sqrt"," Square root","/std/prelude/f64.html#item.sqrt"],["std::prelude::f64::tan"," Tangent function","/std/prelude/f64.html#item.tan"],["std::prelude::f64::tanh"," Hyperbolic tangent function","/std/prelude/f64.html#item.tanh"],["std::prelude::f64::trunc"," Returns the integer part of `self` (round towards zero).","/std/prelude/f64.html#item.trunc"],["std::prelude::i128::max_value"," Returns the maximum value of `i128`.","/std/prelude/i128.html#item.max_value"],["std::prelude::i128::min_value"," Returns the minimum value of `i128`.","/std/prelude/i128.html#item.min_value"],["std::prelude::i16::max_value"," Returns the maximum value of `i16`.","/std/prelude/i16.html#item.max_value"],["std::prelude::i16::min_value"," Returns the minimum value of `i16`.","/std/prelude/i16.html#item.min_value"],["std::prelude::i32::max_value"," Returns the maximum value of `i32`.","/std/prelude/i32.html#item.max_value"],["std::prelude::i32::min_value"," Returns the minimum value of `i32`.","/std/prelude/i32.html#item.min_value"],["std::prelude::i64::max_value"," Returns the maximum value of `i64`.","/std/prelude/i64.html#item.max_value"],["std::prelude::i64::min_value"," Returns the minimum value of `i64`.","/std/prelude/i64.html#item.min_value"],["std::prelude::i8::max_value"," Returns the maximum value of `i8`.","/std/prelude/i8.html#item.max_value"],["std::prelude::i8::min_value"," Returns the minimum value of `i8`.","/std/prelude/i8.html#item.min_value"],["std::prelude::isize::max_value"," Returns the maximum value of `isize`.","/std/prelude/isize.html#item.max_value"],["std::prelude::isize::min_value"," Returns the minimum value of `isize`.","/std/prelude/isize.html#item.min_value"],["std::prelude::u128::max_value"," Returns the maximum value of `u128`.","/std/prelude/u128.html#item.max_value"],["std::prelude::u128::min_value"," Returns the minimum value of `u128`.","/std/prelude/u128.html#item.min_value"],["std::prelude::u16::max_value"," Returns the maximum value of `u16`.","/std/prelude/u16.html#item.max_value"],["std::prelude::u16::min_value"," Returns the minimum value of `u16`.","/std/prelude/u16.html#item.min_value"],["std::prelude::u32::max_value"," Returns the maximum value of `u32`.","/std/prelude/u32.html#item.max_value"],["std::prelude::u32::min_value"," Returns the minimum value of `u32`.","/std/prelude/u32.html#item.min_value"],["std::prelude::u64::max_value"," Returns the maximum value of `u64`.","/std/prelude/u64.html#item.max_value"],["std::prelude::u64::min_value"," Returns the minimum value of `u64`.","/std/prelude/u64.html#item.min_value"],["std::prelude::u8::max_value"," Returns the maximum value of `u8`.","/std/prelude/u8.html#item.max_value"],["std::prelude::u8::min_value"," Returns the minimum value of `u8`.","/std/prelude/u8.html#item.min_value"],["std::prelude::usize::max_value"," Returns the maximum value of `usize`.","/std/prelude/usize.html#item.max_value"],["std::prelude::usize::min_value"," Returns the minimum value of `usize`.","/std/prelude/usize.html#item.min_value"],["std::prelude::void::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/prelude/void.html#item.equals"],["std::prelude::void::compare"," Compare the value","/std/prelude/void.html#item.compare"],["std::prelude::void::hash"," Update hasher state with the contents of this object.","/std/prelude/void.html#item.hash"],["std::process::unix","","/std/process/unix/"],["std::process::EnvVars"," Iterator over the environment variables.","/std/process/EnvVars.html"],["std::process::Output"," Captured output of a child process.","/std/process/Output.html"],["std::process::Child"," Child process","/std/process/Child.html"],["std::process::Forked"," Builder for creating a forked process.","/std/process/Forked.html"],["std::process::Command"," Builder for creating a process.","/std/process/Command.html"],["std::process::exit"," Exits the process with a given return code.","/std/process/#item.exit"],["std::process::env"," Return environment variables of the current process.","/std/process/#item.env"],["std::process::current_dir"," Returns the current working directory as a `PathBuf`.","/std/process/#item.current_dir"],["std::process::Stdio"," Standard I/O stream redirection type","/std/process/Stdio.html"],["std::process::Child::from_pid"," Construct `Child` from a given process id.","/std/process/Child.html#item.from_pid"],["std::process::Child::wait_with_output"," Wait for child to exit, reading stdout and stderr if I/O redirection is requested.","/std/process/Child.html#item.wait_with_output"],["std::process::Child::wait"," Wait for child to exit, returning the exit status.","/std/process/Child.html#item.wait"],["std::process::Child::kill"," Kill the child process.","/std/process/Child.html#item.kill"],["std::process::Child::close"," Close all pipes.","/std/process/Child.html#item.close"],["std::process::Command::new","","/std/process/Command.html#item.new"],["std::process::Command::args"," Set command line arguments.","/std/process/Command.html#item.args"],["std::process::Command::env"," Set environment variables.","/std/process/Command.html#item.env"],["std::process::Command::stdin"," Set the stdin redirection type","/std/process/Command.html#item.stdin"],["std::process::Command::stdout"," Set the stdout redirection type","/std/process/Command.html#item.stdout"],["std::process::Command::stderr"," Set the stderr redirection type","/std/process/Command.html#item.stderr"],["std::process::Command::spawn"," Spawn a process.","/std/process/Command.html#item.spawn"],["std::process::EnvVars::get"," Gets the value of the environment variable with the given name.","/std/process/EnvVars.html#item.get"],["std::process::EnvVars::next"," Returns the next item, if any.","/std/process/EnvVars.html#item.next"],["std::process::Forked::new","","/std/process/Forked.html#item.new"],["std::process::Forked::stdin"," Set the stdin redirection type","/std/process/Forked.html#item.stdin"],["std::process::Forked::stdout"," Set the stdout redirection type","/std/process/Forked.html#item.stdout"],["std::process::Forked::stderr"," Set the stderr redirection type","/std/process/Forked.html#item.stderr"],["std::process::Forked::spawn"," Fork the process.","/std/process/Forked.html#item.spawn"],["std::process::Output::move"," Creates a copy of the object, leaving an inert object behind.","/std/process/Output.html#item.move"],["std::process::Output::free"," Frees the memory backing the object.","/std/process/Output.html#item.free"],["std::process::Stdio::Piped","","/std/process/Stdio.html#item.Piped"],["std::process::Stdio::Null","","/std/process/Stdio.html#item.Null"],["std::process::Stdio::Inherit","","/std/process/Stdio.html#item.Inherit"],["std::process::unix::internal","","/std/process/unix/internal/"],["std::process::unix::tests","","/std/process/unix/tests/"],["std::process::unix::EnvVars"," Iterator over the environment variables.","/std/process/unix/EnvVars.html"],["std::process::unix::Output"," Captured output of a child process.","/std/process/unix/Output.html"],["std::process::unix::Child"," Child process","/std/process/unix/Child.html"],["std::process::unix::Forked"," Builder for creating a forked process.","/std/process/unix/Forked.html"],["std::process::unix::Command"," Builder for creating a process.","/std/process/unix/Command.html"],["std::process::unix::env"," Return environment variables of the current process.","/std/process/unix/#item.env"],["std::process::unix::current_dir"," Returns the current working directory as a `PathBuf`.","/std/process/unix/#item.current_dir"],["std::process::unix::set_current_dir"," Change the current working directory to the specified path.","/std/process/unix/#item.set_current_dir"],["std::process::unix::Child::from_pid"," Construct `Child` from a given process id.","/std/process/unix/Child.html#item.from_pid"],["std::process::unix::Child::wait_with_output"," Wait for child to exit, reading stdout and stderr if I/O redirection is requested.","/std/process/unix/Child.html#item.wait_with_output"],["std::process::unix::Child::wait"," Wait for child to exit, returning the exit status.","/std/process/unix/Child.html#item.wait"],["std::process::unix::Child::kill"," Kill the child process.","/std/process/unix/Child.html#item.kill"],["std::process::unix::Child::close"," Close all pipes.","/std/process/unix/Child.html#item.close"],["std::process::unix::Command::new","","/std/process/unix/Command.html#item.new"],["std::process::unix::Command::args"," Set command line arguments.","/std/process/unix/Command.html#item.args"],["std::process::unix::Command::env"," Set environment variables.","/std/process/unix/Command.html#item.env"],["std::process::unix::Command::stdin"," Set the stdin redirection type","/std/process/unix/Command.html#item.stdin"],["std::process::unix::Command::stdout"," Set the stdout redirection type","/std/process/unix/Command.html#item.stdout"],["std::process::unix::Command::stderr"," Set the stderr redirection type","/std/process/unix/Command.html#item.stderr"],["std::process::unix::Command::spawn"," Spawn a process.","/std/process/unix/Command.html#item.spawn"],["std::process::unix::EnvVars::get"," Gets the value of the environment variable with the given name.","/std/process/unix/EnvVars.html#item.get"],["std::process::unix::EnvVars::next"," Returns the next item, if any.","/std/process/unix/EnvVars.html#item.next"],["std::process::unix::Forked::new","","/std/process/unix/Forked.html#item.new"],["std::process::unix::Forked::stdin"," Set the stdin redirection type","/std/process/unix/Forked.html#item.stdin"],["std::process::unix::Forked::stdout"," Set the stdout redirection type","/std/process/unix/Forked.html#item.stdout"],["std::process::unix::Forked::stderr"," Set the stderr redirection type","/std/process/unix/Forked.html#item.stderr"],["std::process::unix::Forked::spawn"," Fork the process.","/std/process/unix/Forked.html#item.spawn"],["std::process::unix::Output::move"," Creates a copy of the object, leaving an inert object behind.","/std/process/unix/Output.html#item.move"],["std::process::unix::Output::free"," Frees the memory backing the object.","/std/process/unix/Output.html#item.free"],["std::process::unix::internal::ChildStdio","","/std/process/unix/internal/ChildStdio.html"],["std::process::unix::internal::ExecParams"," Holder for `execve` args converted to C-strings.","/std/process/unix/internal/ExecParams.html"],["std::process::unix::internal::maybe_read_to_end","","/std/process/unix/internal/#item.maybe_read_to_end"],["std::process::unix::internal::read_to_end_2"," Reads two pipes (or any other stream) into respecitve buffers at the same time.","/std/process/unix/internal/#item.read_to_end_2"],["std::process::unix::internal::environ","","/std/process/unix/internal/#item.environ"],["std::process::unix::internal::ChildStdio::new","","/std/process/unix/internal/ChildStdio.html#item.new"],["std::process::unix::internal::ChildStdio::close","","/std/process/unix/internal/ChildStdio.html#item.close"],["std::process::unix::internal::ChildStdio::install","","/std/process/unix/internal/ChildStdio.html#item.install"],["std::process::unix::internal::ChildStdio::into_inner","","/std/process/unix/internal/ChildStdio.html#item.into_inner"],["std::process::unix::internal::ExecParams::new","","/std/process/unix/internal/ExecParams.html#item.new"],["std::process::unix::internal::ExecParams::name","","/std/process/unix/internal/ExecParams.html#item.name"],["std::process::unix::internal::ExecParams::argv","","/std/process/unix/internal/ExecParams.html#item.argv"],["std::process::unix::internal::ExecParams::envp","","/std/process/unix/internal/ExecParams.html#item.envp"],["std::process::unix::internal::ExecParams::free","","/std/process/unix/internal/ExecParams.html#item.free"],["std::process::unix::tests::test_spawn_args","","/std/process/unix/tests/#item.test_spawn_args"],["std::process::unix::tests::test_spawn_env","","/std/process/unix/tests/#item.test_spawn_env"],["std::process::unix::tests::spawn_fails_on_exec_failure","","/std/process/unix/tests/#item.spawn_fails_on_exec_failure"],["std::process::unix::tests::test_kill","","/std/process/unix/tests/#item.test_kill"],["std::process::unix::tests::test_fork","","/std/process/unix/tests/#item.test_fork"],["std::process::unix::tests::test_fork_starvation","","/std/process/unix/tests/#item.test_fork_starvation"],["std::process::unix::tests::test_current_directory","","/std/process/unix/tests/#item.test_current_directory"],["std::random::internal","","/std/random/internal/"],["std::random::tests","","/std/random/tests/"],["std::random::Rng"," Random number generators","/std/random/Rng.html"],["std::random::RngExt"," Extension mixin for the [Rng] trait","/std/random/RngExt.html"],["std::random::Pcg32"," PCG-32 random number generator","/std/random/Pcg32.html"],["std::random::OsRng"," RNG backed by a OS-provided random number generation facility","/std/random/OsRng.html"],["std::random::thread_rng"," A thread-local RNG.","/std/random/#item.thread_rng"],["std::random::DefaultRng"," Default general purpose random number generator.","/std/random/#item.DefaultRng"],["std::random::OsRng::new"," Create a new instance of OsRng","/std/random/OsRng.html#item.new"],["std::random::OsRng::new"," Create a new instance of OsRng","/std/random/OsRng.html#item.new.1"],["std::random::OsRng::next_u32"," Generate a 32-bit integer.","/std/random/OsRng.html#item.next_u32"],["std::random::OsRng::next_u64"," Generate a 64-bit integer.","/std/random/OsRng.html#item.next_u64"],["std::random::OsRng::fill_bytes"," Fill the slice with random bytes.","/std/random/OsRng.html#item.fill_bytes"],["std::random::OsRng::close"," Close the file descriptor","/std/random/OsRng.html#item.close"],["std::random::Pcg32::from_seed"," Create a Pcg32 random number generator from a given seed.","/std/random/Pcg32.html#item.from_seed"],["std::random::Pcg32::next_u32"," Generate a 32-bit integer.","/std/random/Pcg32.html#item.next_u32"],["std::random::Pcg32::next_u64"," Generate a 64-bit integer.","/std/random/Pcg32.html#item.next_u64"],["std::random::Rng::next_u32"," Generate a 32-bit integer.","/std/random/Rng.html#item.next_u32"],["std::random::Rng::next_u64"," Generate a 64-bit integer.","/std/random/Rng.html#item.next_u64"],["std::random::Rng::fill_bytes"," Fill the slice with random bytes.","/std/random/Rng.html#item.fill_bytes"],["std::random::RngExt::next"," Generate a random number in a given [integer range](std::range).","/std/random/RngExt.html#item.next"],["std::random::RngExt::next_float"," Generate a random floating point number in `[0, 1)` interval","/std/random/RngExt.html#item.next_float"],["std::random::RngExt::shuffle"," Permute a slice of elements in random order.","/std/random/RngExt.html#item.shuffle"],["std::random::RngExt::choice"," Return a random element of the slice.","/std/random/RngExt.html#item.choice"],["std::random::internal::seed_default_rng","","/std/random/internal/#item.seed_default_rng"],["std::random::internal::gen_uniform"," Generate a random integer between 0 (inclusive) and `upper_bound` (exclusive)","/std/random/internal/#item.gen_uniform"],["std::random::internal::gen_unsigned"," Generate a random integer of any unsigned integer type","/std/random/internal/#item.gen_unsigned"],["std::random::internal::THREAD_RNG","","/std/random/internal/#item.THREAD_RNG"],["std::random::tests::test_float","","/std/random/tests/#item.test_float"],["std::random::tests::test_range","","/std/random/tests/#item.test_range"],["std::random::tests::test_range_inclusive","","/std/random/tests/#item.test_range_inclusive"],["std::random::tests::test_range_from","","/std/random/tests/#item.test_range_from"],["std::random::tests::test_range_to","","/std/random/tests/#item.test_range_to"],["std::random::tests::test_range_to_inclusive","","/std/random/tests/#item.test_range_to_inclusive"],["std::random::tests::test_shuffle","","/std/random/tests/#item.test_shuffle"],["std::random::tests::SEED","","/std/random/tests/#item.SEED"],["std::range::tests","","/std/range/tests/"],["std::range::RangeFull"," An unbounded range (`..`)","/std/range/RangeFull.html"],["std::range::RangeFrom"," A range with a lower bound (`a..`)","/std/range/RangeFrom.html"],["std::range::RangeTo"," A range with an upper bound (`..a`)","/std/range/RangeTo.html"],["std::range::RangeToInclusive"," A range with an inclusive upper bound (`..=a`)","/std/range/RangeToInclusive.html"],["std::range::Range"," A range with both lower and upper bounds (`a..b`)","/std/range/Range.html"],["std::range::RangeInclusive"," A inclusive range with both lower and upper bounds (`a..=b`)","/std/range/RangeInclusive.html"],["std::range::Range::new"," Create a new range from the given lower and upper bounds.","/std/range/Range.html#item.new"],["std::range::Range::iter"," Returns an iterator over the elements of this iterable.","/std/range/Range.html#item.iter"],["std::range::Range::next"," Returns the next item, if any.","/std/range/Range.html#item.next"],["std::range::Range::next_back"," Returns the next item from the back, if any.","/std/range/Range.html#item.next_back"],["std::range::Range::size_hint"," Returns the number of remaining elements, if available.","/std/range/Range.html#item.size_hint"],["std::range::Range::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/range/Range.html#item.equals"],["std::range::Range::hash"," Update hasher state with the contents of this object.","/std/range/Range.html#item.hash"],["std::range::RangeFrom::new"," Create a new range with an lower bound.","/std/range/RangeFrom.html#item.new"],["std::range::RangeFrom::iter"," Returns an iterator over the elements of this iterable.","/std/range/RangeFrom.html#item.iter"],["std::range::RangeFrom::next"," Returns the next item, if any.","/std/range/RangeFrom.html#item.next"],["std::range::RangeFrom::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/range/RangeFrom.html#item.equals"],["std::range::RangeFrom::hash"," Update hasher state with the contents of this object.","/std/range/RangeFrom.html#item.hash"],["std::range::RangeFull::new"," Create a new unbounded range","/std/range/RangeFull.html#item.new"],["std::range::RangeFull::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/range/RangeFull.html#item.equals"],["std::range::RangeFull::hash"," Update hasher state with the contents of this object.","/std/range/RangeFull.html#item.hash"],["std::range::RangeInclusive::new"," Create a new inclusive range from the given lower and upper bounds.","/std/range/RangeInclusive.html#item.new"],["std::range::RangeInclusive::iter"," Returns an iterator over the elements of this iterable.","/std/range/RangeInclusive.html#item.iter"],["std::range::RangeInclusive::next"," Returns the next item, if any.","/std/range/RangeInclusive.html#item.next"],["std::range::RangeInclusive::next_back"," Returns the next item from the back, if any.","/std/range/RangeInclusive.html#item.next_back"],["std::range::RangeInclusive::size_hint"," Returns the number of remaining elements, if available.","/std/range/RangeInclusive.html#item.size_hint"],["std::range::RangeInclusive::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/range/RangeInclusive.html#item.equals"],["std::range::RangeInclusive::hash"," Update hasher state with the contents of this object.","/std/range/RangeInclusive.html#item.hash"],["std::range::RangeTo::new"," Create a new range with an upper bound.","/std/range/RangeTo.html#item.new"],["std::range::RangeTo::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/range/RangeTo.html#item.equals"],["std::range::RangeTo::hash"," Update hasher state with the contents of this object.","/std/range/RangeTo.html#item.hash"],["std::range::RangeToInclusive::new"," Create a new range with an inclusive upper bound.","/std/range/RangeToInclusive.html#item.new"],["std::range::RangeToInclusive::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/range/RangeToInclusive.html#item.equals"],["std::range::RangeToInclusive::hash"," Update hasher state with the contents of this object.","/std/range/RangeToInclusive.html#item.hash"],["std::range::tests::test_range","","/std/range/tests/#item.test_range"],["std::range::tests::test_range_inclusive","","/std/range/tests/#item.test_range_inclusive"],["std::range::tests::test_range_lower","","/std/range/tests/#item.test_range_lower"],["std::range::tests::test_equality","","/std/range/tests/#item.test_equality"],["std::range::tests::test_hash","","/std/range/tests/#item.test_hash"],["std::result::internal","","/std/result/internal/"],["std::result::Result"," Either a success value or an error value.","/std/result/Result.html"],["std::result::try"," Extract the success value or short-circuit the calling function.","/std/result/try.html"],["std::result::Result::ok"," Create a success variant","/std/result/Result.html#item.ok"],["std::result::Result::err"," Create a error variant","/std/result/Result.html#item.err"],["std::result::Result::is_ok"," Returns `true` if the result conains an OK variant, `false` otherwise","/std/result/Result.html#item.is_ok"],["std::result::Result::is_err"," Returns `true` if the result conains an error variant, `false` otherwise","/std/result/Result.html#item.is_err"],["std::result::Result::get"," Converts from `Result<T, E>` to `Option<T>`.","/std/result/Result.html#item.get"],["std::result::Result::get_err"," Converts from `Result<T, E>` to `Option<E>`.","/std/result/Result.html#item.get_err"],["std::result::Result::unwrap"," Return the success value, panicking if error value is present","/std/result/Result.html#item.unwrap"],["std::result::Result::unwrap_err"," Return the error value, panicking if success value is present","/std/result/Result.html#item.unwrap_err"],["std::result::Result::unwrap_or"," Return the success value or a default value","/std/result/Result.html#item.unwrap_or"],["std::result::Result::unwrap_or_else"," Return the success value or a default value provided by a callback","/std/result/Result.html#item.unwrap_or_else"],["std::result::Result::map"," Transform the success value inside the `Result` by calling the provided function.","/std/result/Result.html#item.map"],["std::result::Result::map_err"," Transform the error value inside the `Result` by calling the provided function.","/std/result/Result.html#item.map_err"],["std::result::Result::and_then"," Transform the value inside the `Result` by calling the provided function, which returns a","/std/result/Result.html#item.and_then"],["std::result::Result::transpose"," Convert `Result<Option<T>, E>` to `Option<Result<T, E>>`","/std/result/Result.html#item.transpose"],["std::result::Result::fmt"," Write the object into a given formatter.","/std/result/Result.html#item.fmt"],["std::result::Result::hash"," Update hasher state with the contents of this object.","/std/result/Result.html#item.hash"],["std::result::Result::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/result/Result.html#item.equals"],["std::result::Result::move"," Creates a copy of the object, leaving an inert object behind.","/std/result/Result.html#item.move"],["std::result::Result::free"," Frees the memory backing the object.","/std/result/Result.html#item.free"],["std::result::internal::unwrap_panic_err","","/std/result/internal/#item.unwrap_panic_err"],["std::result::internal::unwrap_panic_ok","","/std/result/internal/#item.unwrap_panic_ok"],["std::runtime::internal","","/std/runtime/internal/"],["std::runtime::internal::TestCaseMeta"," Test case metadata","/std/runtime/internal/TestCaseMeta.html"],["std::runtime::internal::main"," Program entrypoint glue.","/std/runtime/internal/#item.main"],["std::runtime::internal::argc_argv_to_slice"," Converts `argc` and `argv` into a `&[&[u8]]` slice of strings.","/std/runtime/internal/argc_argv_to_slice.html"],["std::runtime::internal::STACK_ARGS_MAX"," Maximum number of program arguments that can be stack-allocated.","/std/runtime/internal/#item.STACK_ARGS_MAX"],["std::runtime::internal::TEST_CASES"," Discovered unit test cases.","/std/runtime/internal/#item.TEST_CASES"],["std::runtime::internal::TestCaseMeta::new","","/std/runtime/internal/TestCaseMeta.html#item.new"],["std::string::tests","","/std/string/tests/"],["std::string::SplitIterator"," Iterator over parts of a string split by a delimiter.","/std/string/SplitIterator.html"],["std::string::ReplaceAdapter","","/std/string/ReplaceAdapter.html"],["std::string::JoinAdapter","","/std/string/JoinAdapter.html"],["std::string::is_whitespace"," Returns `true` if character is an ASCII whitespace character, `false` otherwise.","/std/string/#item.is_whitespace"],["std::string::to_lower"," Convert character to lower case.","/std/string/#item.to_lower"],["std::string::to_upper"," Convert character to upper case.","/std/string/#item.to_upper"],["std::string::starts_with"," Returns `true` if string starts with the given prefix, `false` otherwise.","/std/string/#item.starts_with"],["std::string::ends_with"," Returns `true` if string ends with the given suffix, `false` otherwise.","/std/string/#item.ends_with"],["std::string::trim_prefix"," Return string without the given prefix.","/std/string/#item.trim_prefix"],["std::string::trim_suffix"," Return string without the given suffix.","/std/string/#item.trim_suffix"],["std::string::find"," Finds a substring in a string.","/std/string/#item.find"],["std::string::find_char"," Finds the index of the first occurrence of a character in a string.","/std/string/#item.find_char"],["std::string::contains"," Returns `true` if `needle` is a substring of self, `false` otherwise.","/std/string/#item.contains"],["std::string::trim_start"," Trims ASCII whitespace from the start of the string.","/std/string/#item.trim_start"],["std::string::trim_end"," Trims ASCII whitespace from the end of the string.","/std/string/#item.trim_end"],["std::string::trim"," Trims the whitespace from the start and end of the string.","/std/string/#item.trim"],["std::string::split"," Returns an iterator over the parts of the string split by the given delimiter.","/std/string/#item.split"],["std::string::replace"," Replaces all occurrences of `needle` with `replacement`, returning a new string.","/std/string/#item.replace"],["std::string::replace_fmt"," Returns an object that formats to the string with all `needle` occurrences replaced with","/std/string/#item.replace_fmt"],["std::string::join"," Join the parts of a string with the given delimiter, returning a new string.","/std/string/#item.join"],["std::string::join_fmt"," Returns an object that formats to parts joined with the separartor.","/std/string/#item.join_fmt"],["std::string::parse_integer"," Parses an integer with the given radix.","/std/string/#item.parse_integer"],["std::string::StringBuf"," A heap-allocated string.","/std/string/#item.StringBuf"],["std::string::RADIX_DIGITS","","/std/string/#item.RADIX_DIGITS"],["std::string::JoinAdapter::fmt","","/std/string/JoinAdapter.html#item.fmt"],["std::string::ReplaceAdapter::fmt","","/std/string/ReplaceAdapter.html#item.fmt"],["std::string::SplitIterator::new","","/std/string/SplitIterator.html#item.new"],["std::string::SplitIterator::next"," Returns the next item, if any.","/std/string/SplitIterator.html#item.next"],["std::string::tests::starts_with_positive","","/std/string/tests/#item.starts_with_positive"],["std::string::tests::starts_with_negative","","/std/string/tests/#item.starts_with_negative"],["std::string::tests::find_positive","","/std/string/tests/#item.find_positive"],["std::string::tests::find_negative","","/std/string/tests/#item.find_negative"],["std::string::tests::test_parse_integer","","/std/string/tests/#item.test_parse_integer"],["std::string::tests::test_parse_integer_radix","","/std/string/tests/#item.test_parse_integer_radix"],["std::string::tests::test_trim_start","","/std/string/tests/#item.test_trim_start"],["std::string::tests::test_trim_end","","/std/string/tests/#item.test_trim_end"],["std::string::tests::test_trim","","/std/string/tests/#item.test_trim"],["std::string::tests::test_split","","/std/string/tests/#item.test_split"],["std::string::tests::test_join","","/std/string/tests/#item.test_join"],["std::string::tests::test_replace","","/std/string/tests/#item.test_replace"],["std::sync::channel"," Multi-threaded queues (channels)","/std/sync/channel/"],["std::sync::internal","","/std/sync/internal/"],["std::sync::tests","","/std/sync/tests/"],["std::sync::Lockable"," Protocol for types implementing mutex-like semantics.","/std/sync/Lockable.html"],["std::sync::Atomic"," Values that can be operated on atomically.","/std/sync/Atomic.html"],["std::sync::Mutex"," A mutual exclusion lock (mutex)","/std/sync/Mutex.html"],["std::sync::RwLock"," Reader-writer lock","/std/sync/RwLock.html"],["std::sync::CondVar"," Condition variable","/std/sync/CondVar.html"],["std::sync::Spinlock"," A spinlock.","/std/sync/Spinlock.html"],["std::sync::Event"," A synchronization primitive that allows multiple threads to wait until the","/std/sync/Event.html"],["std::sync::Oneshot"," A one-shot channel (future).","/std/sync/Oneshot.html"],["std::sync::fence"," Memory barrier","/std/sync/#item.fence"],["std::sync::compiler_fence"," Compiler-only memory barrier","/std/sync/#item.compiler_fence"],["std::sync::spin_loop"," A hint to the CPU that we are spinning","/std/sync/#item.spin_loop"],["std::sync::with_lock"," Execute a closure with the lock held","/std/sync/#item.with_lock"],["std::sync::Ordering"," Memory ordering","/std/sync/Ordering.html"],["std::sync::Atomic::new"," Create a new `Atomic` value with the given initial value.","/std/sync/Atomic.html#item.new"],["std::sync::Atomic::from_mut_ptr"," Convert a pointer to a value into a `Atomic` pointer referencing the same memory.","/std/sync/Atomic.html#item.from_mut_ptr"],["std::sync::Atomic::from_mut_slice"," Convert a slice of values into a slice of `Atomic` values referencing the same memory.","/std/sync/Atomic.html#item.from_mut_slice"],["std::sync::Atomic::load"," Loads a value from the atomic variable.","/std/sync/Atomic.html#item.load"],["std::sync::Atomic::store"," Stores a value into the atomic variable.","/std/sync/Atomic.html#item.store"],["std::sync::Atomic::exchange"," Stores a value into the atomic variable, atomically returning the old value.","/std/sync/Atomic.html#item.exchange"],["std::sync::Atomic::compare_exchange"," Atomically compares the value in the atomic variable to `expected` and, if they are equal,","/std/sync/Atomic.html#item.compare_exchange"],["std::sync::Atomic::compare_exchange_weak"," Atomically compares the value in the atomic variable to `expected` and, if they are equal,","/std/sync/Atomic.html#item.compare_exchange_weak"],["std::sync::Atomic::fetch_update"," Updates the value of the atomic variable using a callback function.","/std/sync/Atomic.html#item.fetch_update"],["std::sync::Atomic::fetch_add"," Atomically adds `value` to the atomic variable and returns the old value.","/std/sync/Atomic.html#item.fetch_add"],["std::sync::Atomic::fetch_sub"," Atomically subtracts `value` from the atomic variable and returns the old value.","/std/sync/Atomic.html#item.fetch_sub"],["std::sync::Atomic::fetch_and"," Atomically performs `*self &= value` and returns the old value.","/std/sync/Atomic.html#item.fetch_and"],["std::sync::Atomic::fetch_or"," Atomically performs `*self |= value` and returns the old value.","/std/sync/Atomic.html#item.fetch_or"],["std::sync::Atomic::fetch_xor"," Atomically performs `*self ^= value` and returns the old value.","/std/sync/Atomic.html#item.fetch_xor"],["std::sync::Atomic::fetch_nand"," Atomically performs `*self = ~(*self & value)` and returns the old value.","/std/sync/Atomic.html#item.fetch_nand"],["std::sync::CondVar::new"," Creates a new condition variable.","/std/sync/CondVar.html#item.new"],["std::sync::CondVar::wait"," Waits on a condition variable.","/std/sync/CondVar.html#item.wait"],["std::sync::CondVar::wait_timeout"," Waits on a condition variable with a timeout.","/std/sync/CondVar.html#item.wait_timeout"],["std::sync::CondVar::notify_one"," Signals a condition variable, waking up one waiting thread.","/std/sync/CondVar.html#item.notify_one"],["std::sync::CondVar::notify_all"," Signals a condition variable, waking up all waiting threads.","/std/sync/CondVar.html#item.notify_all"],["std::sync::Event::new"," Create a new event in an unset state","/std/sync/Event.html#item.new"],["std::sync::Event::new_set"," Create a new event in a set state","/std/sync/Event.html#item.new_set"],["std::sync::Event::set"," Signals the event, waking up all threads that are waiting on it.","/std/sync/Event.html#item.set"],["std::sync::Event::reset"," Resets the event, so that it can be waited on and signalled again.","/std/sync/Event.html#item.reset"],["std::sync::Event::is_set"," Checks if the event is signalled.","/std/sync/Event.html#item.is_set"],["std::sync::Event::wait"," Waits for the event to be signalled.","/std/sync/Event.html#item.wait"],["std::sync::Lockable::lock"," Acquires the lock","/std/sync/Lockable.html#item.lock"],["std::sync::Lockable::unlock"," Releases the lock","/std/sync/Lockable.html#item.unlock"],["std::sync::Mutex::new"," Creates a new mutex.","/std/sync/Mutex.html#item.new"],["std::sync::Mutex::lock"," Acquires a mutex, blocking the current thread until it can acquire it.","/std/sync/Mutex.html#item.lock"],["std::sync::Mutex::try_lock"," Attempts to acquire a mutex, but does not block.","/std/sync/Mutex.html#item.try_lock"],["std::sync::Mutex::unlock"," Releases a mutex.","/std/sync/Mutex.html#item.unlock"],["std::sync::Oneshot::new"," Creates a new one-shot channel.","/std/sync/Oneshot.html#item.new"],["std::sync::Oneshot::from_value"," Creates a completed one-shot channel from a value","/std/sync/Oneshot.html#item.from_value"],["std::sync::Oneshot::send"," Sets the value of the channel.","/std/sync/Oneshot.html#item.send"],["std::sync::Oneshot::recv"," Gets the value of the channel.","/std/sync/Oneshot.html#item.recv"],["std::sync::Oneshot::try_recv"," Tries to get the value of the channel","/std/sync/Oneshot.html#item.try_recv"],["std::sync::Ordering::Relaxed","","/std/sync/Ordering.html#item.Relaxed"],["std::sync::Ordering::Acquire","","/std/sync/Ordering.html#item.Acquire"],["std::sync::Ordering::Release","","/std/sync/Ordering.html#item.Release"],["std::sync::Ordering::AcqRel","","/std/sync/Ordering.html#item.AcqRel"],["std::sync::Ordering::SeqCst","","/std/sync/Ordering.html#item.SeqCst"],["std::sync::RwLock::new"," Creates a new reader-writer lock.","/std/sync/RwLock.html#item.new"],["std::sync::RwLock::read_lock"," Acquires a reader-writer lock for reading.","/std/sync/RwLock.html#item.read_lock"],["std::sync::RwLock::try_read_lock"," Attempts to acquire a reader-writer lock for reading.","/std/sync/RwLock.html#item.try_read_lock"],["std::sync::RwLock::write_lock"," Acquires a reader-writer lock for writing.","/std/sync/RwLock.html#item.write_lock"],["std::sync::RwLock::try_write_lock"," Attempts to acquire a reader-writer lock for writing.","/std/sync/RwLock.html#item.try_write_lock"],["std::sync::RwLock::unlock"," Releases a reader-writer lock.","/std/sync/RwLock.html#item.unlock"],["std::sync::Spinlock::new"," Creates a new mutex.","/std/sync/Spinlock.html#item.new"],["std::sync::Spinlock::lock"," Acquires a spinlock, spinning until it is acquired.","/std/sync/Spinlock.html#item.lock"],["std::sync::Spinlock::try_lock"," Attempts to acquire a spinlock, but does not spin.","/std/sync/Spinlock.html#item.try_lock"],["std::sync::Spinlock::try_lock_bounded"," Attempts to acquire a spinlock, spining for up to `times` times.","/std/sync/Spinlock.html#item.try_lock_bounded"],["std::sync::Spinlock::unlock"," Releases a spinlock.","/std/sync/Spinlock.html#item.unlock"],["std::sync::channel::internal","","/std/sync/channel/internal/"],["std::sync::channel::tests","","/std/sync/channel/tests/"],["std::sync::channel::Channel"," A simple bounded synchronous queue.","/std/sync/channel/Channel.html"],["std::sync::channel::UnboundedChannel"," An unbounded synchronous queue.","/std/sync/channel/UnboundedChannel.html"],["std::sync::channel::ChannelIterator"," Iterator over values of [Channel] and [UnboundedChannel].","/std/sync/channel/ChannelIterator.html"],["std::sync::channel::ChannelError"," Error returned by [Channel] operations.","/std/sync/channel/ChannelError.html"],["std::sync::channel::Channel::new"," Creates a new channel with a given capacity","/std/sync/channel/Channel.html#item.new"],["std::sync::channel::Channel::send"," Send a value to the channel.","/std/sync/channel/Channel.html#item.send"],["std::sync::channel::Channel::try_send"," Try to send a value to the channel.","/std/sync/channel/Channel.html#item.try_send"],["std::sync::channel::Channel::send_timeout"," Try to send a value to the channel with a timeout.","/std/sync/channel/Channel.html#item.send_timeout"],["std::sync::channel::Channel::recv"," Receive a value from the channel.","/std/sync/channel/Channel.html#item.recv"],["std::sync::channel::Channel::try_recv"," Try to receive a value from the channel.","/std/sync/channel/Channel.html#item.try_recv"],["std::sync::channel::Channel::recv_timeout"," Try to receive a value from the channel with a timeout.","/std/sync/channel/Channel.html#item.recv_timeout"],["std::sync::channel::Channel::close"," Close the channel.","/std/sync/channel/Channel.html#item.close"],["std::sync::channel::Channel::iter"," Returns an iterator over the elements of this iterable.","/std/sync/channel/Channel.html#item.iter"],["std::sync::channel::Channel::free"," Frees the memory backing the object.","/std/sync/channel/Channel.html#item.free"],["std::sync::channel::ChannelError::Closed","","/std/sync/channel/ChannelError.html#item.Closed"],["std::sync::channel::ChannelError::WouldBlock","","/std/sync/channel/ChannelError.html#item.WouldBlock"],["std::sync::channel::ChannelError::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/sync/channel/ChannelError.html#item.equals"],["std::sync::channel::ChannelError::fmt"," Write the object into a given formatter.","/std/sync/channel/ChannelError.html#item.fmt"],["std::sync::channel::ChannelIterator::next"," Returns the next item, if any.","/std/sync/channel/ChannelIterator.html#item.next"],["std::sync::channel::UnboundedChannel::new"," Creates a new unbounded channel","/std/sync/channel/UnboundedChannel.html#item.new"],["std::sync::channel::UnboundedChannel::shrink_to_fit"," Reduces the size of the underlying queue to the number of contained values.","/std/sync/channel/UnboundedChannel.html#item.shrink_to_fit"],["std::sync::channel::UnboundedChannel::send"," Send a value to the channel.","/std/sync/channel/UnboundedChannel.html#item.send"],["std::sync::channel::UnboundedChannel::recv"," Receive a value from the channel.","/std/sync/channel/UnboundedChannel.html#item.recv"],["std::sync::channel::UnboundedChannel::try_recv"," Try to receive a value from the channel.","/std/sync/channel/UnboundedChannel.html#item.try_recv"],["std::sync::channel::UnboundedChannel::recv_timeout"," Try to receive a value from the channel with a timeout.","/std/sync/channel/UnboundedChannel.html#item.recv_timeout"],["std::sync::channel::UnboundedChannel::close"," Close the channel.","/std/sync/channel/UnboundedChannel.html#item.close"],["std::sync::channel::UnboundedChannel::iter"," Returns an iterator over the elements of this iterable.","/std/sync/channel/UnboundedChannel.html#item.iter"],["std::sync::channel::UnboundedChannel::free"," Frees the memory backing the object.","/std/sync/channel/UnboundedChannel.html#item.free"],["std::sync::channel::internal::ConditionExt","","/std/sync/channel/internal/ConditionExt.html"],["std::sync::channel::tests::test_channel","","/std/sync/channel/tests/#item.test_channel"],["std::sync::channel::tests::test_channel_closed","","/std/sync/channel/tests/#item.test_channel_closed"],["std::sync::channel::tests::test_channel_try","","/std/sync/channel/tests/#item.test_channel_try"],["std::sync::channel::tests::test_channel_timeout","","/std/sync/channel/tests/#item.test_channel_timeout"],["std::sync::channel::tests::test_channel_iter","","/std/sync/channel/tests/#item.test_channel_iter"],["std::sync::channel::tests::test_unbounded_channel","","/std/sync/channel/tests/#item.test_unbounded_channel"],["std::sync::channel::tests::test_unbounded_channel_closed","","/std/sync/channel/tests/#item.test_unbounded_channel_closed"],["std::sync::channel::tests::test_unbounded_channel_try","","/std/sync/channel/tests/#item.test_unbounded_channel_try"],["std::sync::channel::tests::test_unbounded_channel_timeout","","/std/sync/channel/tests/#item.test_unbounded_channel_timeout"],["std::sync::channel::tests::test_unbounded_channel_iter","","/std/sync/channel/tests/#item.test_unbounded_channel_iter"],["std::sync::internal::EventWaiter","","/std/sync/internal/EventWaiter.html"],["std::sync::internal::EVENT_RESET","","/std/sync/internal/#item.EVENT_RESET"],["std::sync::internal::EVENT_SET","","/std/sync/internal/#item.EVENT_SET"],["std::sync::tests::test_ordering_values_match","","/std/sync/tests/#item.test_ordering_values_match"],["std::sync::tests::test_load","","/std/sync/tests/#item.test_load"],["std::sync::tests::test_store","","/std/sync/tests/#item.test_store"],["std::sync::tests::test_exchange","","/std/sync/tests/#item.test_exchange"],["std::sync::tests::test_compare_exchange","","/std/sync/tests/#item.test_compare_exchange"],["std::sync::tests::test_compare_exchange_weak","","/std/sync/tests/#item.test_compare_exchange_weak"],["std::sync::tests::test_fetch_add","","/std/sync/tests/#item.test_fetch_add"],["std::sync::tests::test_fetch_sub","","/std/sync/tests/#item.test_fetch_sub"],["std::sync::tests::test_fetch_and","","/std/sync/tests/#item.test_fetch_and"],["std::sync::tests::test_fetch_or","","/std/sync/tests/#item.test_fetch_or"],["std::sync::tests::test_fetch_xor","","/std/sync/tests/#item.test_fetch_xor"],["std::sync::tests::test_fetch_nand","","/std/sync/tests/#item.test_fetch_nand"],["std::sync::tests::test_mutex","","/std/sync/tests/#item.test_mutex"],["std::sync::tests::test_rwlock","","/std/sync/tests/#item.test_rwlock"],["std::sync::tests::test_condvar","","/std/sync/tests/#item.test_condvar"],["std::sync::tests::test_event","","/std/sync/tests/#item.test_event"],["std::sync::tests::test_event_blocking","","/std/sync/tests/#item.test_event_blocking"],["std::sync::tests::test_oneshot","","/std/sync/tests/#item.test_oneshot"],["std::sync::tests::test_oneshot_completed","","/std/sync/tests/#item.test_oneshot_completed"],["std::sync::tests::test_oneshot_blocking","","/std/sync/tests/#item.test_oneshot_blocking"],["std::sync::tests::test_spinlock","","/std/sync/tests/#item.test_spinlock"],["std::sync::tests::test_spinlock_try","","/std/sync/tests/#item.test_spinlock_try"],["std::sync::tests::test_spinlock_bounded","","/std/sync/tests/#item.test_spinlock_bounded"],["std::tests::test_likely","","/std/tests/#item.test_likely"],["std::thread::parker"," Thread \"parking\". Adapted from Rust's `Parker` implementation.","/std/thread/parker/"],["std::thread::pool"," Thread pool","/std/thread/pool/"],["std::thread::internal","","/std/thread/internal/"],["std::thread::tests","","/std/thread/tests/"],["std::thread::JoinError"," An error returned from [JoinHandle::join].","/std/thread/JoinError.html"],["std::thread::JoinHandle"," A handle that allows to wait for the thread to finish.","/std/thread/JoinHandle.html"],["std::thread::Builder"," A thread builder.","/std/thread/Builder.html"],["std::thread::Thread"," A structure representing an Alumina thread.","/std/thread/Thread.html"],["std::thread::spawn"," Spawn a new thread with default settings.","/std/thread/#item.spawn"],["std::thread::sleep"," Suspends thread execution for the specified duration.","/std/thread/#item.sleep"],["std::thread::yield"," Yields the execution of the current thread.","/std/thread/#item.yield"],["std::thread::JoinErrorKind","","/std/thread/JoinErrorKind.html"],["std::thread::Builder::new"," Create a new default [Builder] instance.","/std/thread/Builder.html#item.new"],["std::thread::Builder::catch_panic"," Whether panics should be caught by the thread.","/std/thread/Builder.html#item.catch_panic"],["std::thread::Builder::stack_size"," Sets the size of the stack for the new thread.","/std/thread/Builder.html#item.stack_size"],["std::thread::Builder::spawn"," Spawn a thread in joinable state.","/std/thread/Builder.html#item.spawn"],["std::thread::Builder::spawn_detached"," Spawn a thread in detached state.","/std/thread/Builder.html#item.spawn_detached"],["std::thread::JoinError::from_os","","/std/thread/JoinError.html#item.from_os"],["std::thread::JoinError::from_panic","","/std/thread/JoinError.html#item.from_panic"],["std::thread::JoinError::fmt"," Write the object into a given formatter.","/std/thread/JoinError.html#item.fmt"],["std::thread::JoinErrorKind::Os","","/std/thread/JoinErrorKind.html#item.Os"],["std::thread::JoinErrorKind::Panic","","/std/thread/JoinErrorKind.html#item.Panic"],["std::thread::JoinErrorKind::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/thread/JoinErrorKind.html#item.equals"],["std::thread::JoinHandle::thread"," Returns the [Thread] object associated with this join handle.","/std/thread/JoinHandle.html#item.thread"],["std::thread::JoinHandle::join"," Waits for the associated thread to finish.","/std/thread/JoinHandle.html#item.join"],["std::thread::JoinHandle::detach"," Detaches the thread, letting it run in background.","/std/thread/JoinHandle.html#item.detach"],["std::thread::Thread::current"," Returns the current thread","/std/thread/Thread.html#item.current"],["std::thread::Thread::id"," Returns the native thread id of a thread.","/std/thread/Thread.html#item.id"],["std::thread::Thread::park"," Suspends the current thread until another thread calls [Thread::unpark].","/std/thread/Thread.html#item.park"],["std::thread::Thread::park_timeout"," Suspends the current thread until another thread calls [Thread::unpark] or until","/std/thread/Thread.html#item.park_timeout"],["std::thread::Thread::unpark"," Resumes the execution of a thread that was previously parked.","/std/thread/Thread.html#item.unpark"],["std::thread::Thread::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/thread/Thread.html#item.equals"],["std::thread::Thread::hash"," Update hasher state with the contents of this object.","/std/thread/Thread.html#item.hash"],["std::thread::internal::ThreadInfo","","/std/thread/internal/ThreadInfo.html"],["std::thread::internal::ThreadHandle"," Ref-counted additional data associated with an Alumina thread","/std/thread/internal/ThreadHandle.html"],["std::thread::internal::ThreadHandleFunc"," An aliased version of [ThreadHandle] that also contains the function to be called.","/std/thread/internal/ThreadHandleFunc.html"],["std::thread::internal::threading_init"," Sets up associated data of the main thread","/std/thread/internal/#item.threading_init"],["std::thread::internal::ensure_threading"," Compile-time assert that threading is enabled.","/std/thread/internal/ensure_threading.html"],["std::thread::internal::pthread_try","","/std/thread/internal/pthread_try.html"],["std::thread::internal::MAIN_THREAD_INFO","","/std/thread/internal/#item.MAIN_THREAD_INFO"],["std::thread::internal::THREAD_INFO","","/std/thread/internal/#item.THREAD_INFO"],["std::thread::internal::ThreadHandle::new","","/std/thread/internal/ThreadHandle.html#item.new"],["std::thread::internal::ThreadHandle::pop","","/std/thread/internal/ThreadHandle.html#item.pop"],["std::thread::internal::ThreadHandle::free","","/std/thread/internal/ThreadHandle.html#item.free"],["std::thread::internal::ThreadInfo::create","","/std/thread/internal/ThreadInfo.html#item.create"],["std::thread::internal::ThreadInfo::init","","/std/thread/internal/ThreadInfo.html#item.init"],["std::thread::internal::ThreadInfo::free","","/std/thread/internal/ThreadInfo.html#item.free"],["std::thread::parker::futex","","/std/thread/parker/futex/"],["std::thread::parker::pthread","","/std/thread/parker/pthread/"],["std::thread::parker::tests","","/std/thread/parker/tests/"],["std::thread::parker::Parker","","/std/thread/parker/Parker.html"],["std::thread::parker::Parker::new","","/std/thread/parker/Parker.html#item.new"],["std::thread::parker::Parker::park","","/std/thread/parker/Parker.html#item.park"],["std::thread::parker::Parker::park_timeout","","/std/thread/parker/Parker.html#item.park_timeout"],["std::thread::parker::Parker::unpark","","/std/thread/parker/Parker.html#item.unpark"],["std::thread::parker::futex::Parker","","/std/thread/parker/futex/Parker.html"],["std::thread::parker::futex::futex_wait","","/std/thread/parker/futex/#item.futex_wait"],["std::thread::parker::futex::futex_wake","","/std/thread/parker/futex/#item.futex_wake"],["std::thread::parker::futex::PARKED","","/std/thread/parker/futex/#item.PARKED"],["std::thread::parker::futex::EMPTY","","/std/thread/parker/futex/#item.EMPTY"],["std::thread::parker::futex::NOTIFIED","","/std/thread/parker/futex/#item.NOTIFIED"],["std::thread::parker::futex::Parker::new","","/std/thread/parker/futex/Parker.html#item.new"],["std::thread::parker::futex::Parker::park","","/std/thread/parker/futex/Parker.html#item.park"],["std::thread::parker::futex::Parker::park_timeout","","/std/thread/parker/futex/Parker.html#item.park_timeout"],["std::thread::parker::futex::Parker::unpark","","/std/thread/parker/futex/Parker.html#item.unpark"],["std::thread::parker::pthread::Parker","","/std/thread/parker/pthread/Parker.html"],["std::thread::parker::pthread::EMPTY","","/std/thread/parker/pthread/#item.EMPTY"],["std::thread::parker::pthread::PARKED","","/std/thread/parker/pthread/#item.PARKED"],["std::thread::parker::pthread::NOTIFIED","","/std/thread/parker/pthread/#item.NOTIFIED"],["std::thread::parker::pthread::Parker::new","","/std/thread/parker/pthread/Parker.html#item.new"],["std::thread::parker::pthread::Parker::park","","/std/thread/parker/pthread/Parker.html#item.park"],["std::thread::parker::pthread::Parker::park_timeout","","/std/thread/parker/pthread/Parker.html#item.park_timeout"],["std::thread::parker::pthread::Parker::unpark","","/std/thread/parker/pthread/Parker.html#item.unpark"],["std::thread::parker::tests::test_park","","/std/thread/parker/tests/#item.test_park"],["std::thread::parker::tests::test_park_timeout","","/std/thread/parker/tests/#item.test_park_timeout"],["std::thread::pool::internal","","/std/thread/pool/internal/"],["std::thread::pool::tests","","/std/thread/pool/tests/"],["std::thread::pool::TaskHandle"," A handle that allow to wait on tasks spawned on a thread pool.","/std/thread/pool/TaskHandle.html"],["std::thread::pool::ThreadPool"," A thread pool.","/std/thread/pool/ThreadPool.html"],["std::thread::pool::TaskHandle::wait"," Returns the result of the task.","/std/thread/pool/TaskHandle.html#item.wait"],["std::thread::pool::TaskHandle::try_wait"," Tries to return the result of the task.","/std/thread/pool/TaskHandle.html#item.try_wait"],["std::thread::pool::TaskHandle::detach"," Ignores the result of the task.","/std/thread/pool/TaskHandle.html#item.detach"],["std::thread::pool::ThreadPool::unbounded"," Creates a new thread pool with an unbounded task queue.","/std/thread/pool/ThreadPool.html#item.unbounded"],["std::thread::pool::ThreadPool::bounded"," Creates a new thread pool with a bounded task queue.","/std/thread/pool/ThreadPool.html#item.bounded"],["std::thread::pool::ThreadPool::spawn"," Spawns a new task on the thread pool, returning a handle that can be used to wait for the result.","/std/thread/pool/ThreadPool.html#item.spawn"],["std::thread::pool::ThreadPool::spawn_detached"," Spawns a new task on the thread pool.","/std/thread/pool/ThreadPool.html#item.spawn_detached"],["std::thread::pool::ThreadPool::close"," Completes the task queue, preventing new tasks to be spawned.","/std/thread/pool/ThreadPool.html#item.close"],["std::thread::pool::ThreadPool::join"," Closes the thread pool and waits for all remaining tasks to finish.","/std/thread/pool/ThreadPool.html#item.join"],["std::thread::pool::internal::JoinableTask","","/std/thread/pool/internal/JoinableTask.html"],["std::thread::pool::internal::JoinableTaskFunc","","/std/thread/pool/internal/JoinableTaskFunc.html"],["std::thread::pool::internal::Task","","/std/thread/pool/internal/Task.html"],["std::thread::pool::internal::ThreadPoolInner","","/std/thread/pool/internal/ThreadPoolInner.html"],["std::thread::pool::internal::WorkQueue","","/std/thread/pool/internal/WorkQueue.html"],["std::thread::pool::internal::JoinableTask::new","","/std/thread/pool/internal/JoinableTask.html#item.new"],["std::thread::pool::internal::JoinableTask::free","","/std/thread/pool/internal/JoinableTask.html#item.free"],["std::thread::pool::internal::Task::new","","/std/thread/pool/internal/Task.html#item.new"],["std::thread::pool::internal::Task::new_joinable","","/std/thread/pool/internal/Task.html#item.new_joinable"],["std::thread::pool::internal::Task::run","","/std/thread/pool/internal/Task.html#item.run"],["std::thread::pool::internal::ThreadPoolInner::free","","/std/thread/pool/internal/ThreadPoolInner.html#item.free"],["std::thread::pool::tests::test_spawn","","/std/thread/pool/tests/#item.test_spawn"],["std::thread::pool::tests::test_spawn_detached","","/std/thread/pool/tests/#item.test_spawn_detached"],["std::thread::pool::tests::test_unbounded_spawn","","/std/thread/pool/tests/#item.test_unbounded_spawn"],["std::thread::pool::tests::test_unbounded_spawn_detached","","/std/thread/pool/tests/#item.test_unbounded_spawn_detached"],["std::thread::tests::test_spawn","","/std/thread/tests/#item.test_spawn"],["std::thread::tests::test_spawn_custom","","/std/thread/tests/#item.test_spawn_custom"],["std::thread::tests::test_spawn_detached","","/std/thread/tests/#item.test_spawn_detached"],["std::thread::tests::test_spawn_no_catch_panic","","/std/thread/tests/#item.test_spawn_no_catch_panic"],["std::thread::tests::test_spawn_manual_exit","","/std/thread/tests/#item.test_spawn_manual_exit"],["std::thread::tests::test_panic","","/std/thread/tests/#item.test_panic"],["std::thread::tests::test_park_timeout","","/std/thread/tests/#item.test_park_timeout"],["std::thread::tests::test_detach","","/std/thread/tests/#item.test_detach"],["std::thread::tests::test_detach_finished","","/std/thread/tests/#item.test_detach_finished"],["std::thread::tests::test_detach_panic","","/std/thread/tests/#item.test_detach_panic"],["std::thread::tests::test_detach_panic_2","","/std/thread/tests/#item.test_detach_panic_2"],["std::thread::tests::test_detach_panic_3","","/std/thread/tests/#item.test_detach_panic_3"],["std::thread::tests::test_current","","/std/thread/tests/#item.test_current"],["std::thread::tests::test_current_foreign_thread","","/std/thread/tests/#item.test_current_foreign_thread"],["std::time::internal"," Darwin-specific implementation.","/std/time/internal/"],["std::time::tests","","/std/time/tests/"],["std::time::Instant"," A specific point in time","/std/time/Instant.html"],["std::time::Duration"," Represents a span of time.","/std/time/Duration.html"],["std::time::NANOS_PER_SEC","","/std/time/#item.NANOS_PER_SEC"],["std::time::NANOS_PER_MILLI","","/std/time/#item.NANOS_PER_MILLI"],["std::time::NANOS_PER_MICRO","","/std/time/#item.NANOS_PER_MICRO"],["std::time::MILLIS_PER_SEC","","/std/time/#item.MILLIS_PER_SEC"],["std::time::MICROS_PER_SEC","","/std/time/#item.MICROS_PER_SEC"],["std::time::Duration::new","","/std/time/Duration.html#item.new"],["std::time::Duration::zero"," A duration of zero time","/std/time/Duration.html#item.zero"],["std::time::Duration::is_negative"," Returns `true` if duration is negative, `false` otherwise","/std/time/Duration.html#item.is_negative"],["std::time::Duration::from_secs"," Duration from a specified number of seconds","/std/time/Duration.html#item.from_secs"],["std::time::Duration::from_millis"," Duration from a specified number of milliseconds","/std/time/Duration.html#item.from_millis"],["std::time::Duration::from_micros"," Duration from a specified number of microseconds","/std/time/Duration.html#item.from_micros"],["std::time::Duration::from_nanos"," Duration from a specified number of nanoseconds","/std/time/Duration.html#item.from_nanos"],["std::time::Duration::add"," Add a duration to another.","/std/time/Duration.html#item.add"],["std::time::Duration::sub"," Subtract a duration from the current duration.","/std/time/Duration.html#item.sub"],["std::time::Duration::total_secs"," Total number of seconds as a floating point.","/std/time/Duration.html#item.total_secs"],["std::time::Duration::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/time/Duration.html#item.equals"],["std::time::Duration::hash"," Update hasher state with the contents of this object.","/std/time/Duration.html#item.hash"],["std::time::Duration::compare"," Compare the value","/std/time/Duration.html#item.compare"],["std::time::Duration::fmt"," Write the object into a given formatter.","/std/time/Duration.html#item.fmt"],["std::time::Instant::now"," Current instant","/std/time/Instant.html#item.now"],["std::time::Instant::duration_since"," Returns time elapsed since an earlier instant.","/std/time/Instant.html#item.duration_since"],["std::time::Instant::add"," Add a specific duration to an instant.","/std/time/Instant.html#item.add"],["std::time::Instant::sub"," Subtract a specific duration from an instant.","/std/time/Instant.html#item.sub"],["std::time::Instant::equals"," Returns `true` if arguments are equal, `false` otherwise","/std/time/Instant.html#item.equals"],["std::time::Instant::hash"," Update hasher state with the contents of this object.","/std/time/Instant.html#item.hash"],["std::time::Instant::compare"," Compare the value","/std/time/Instant.html#item.compare"],["std::time::internal::mach_timebase_info_t","","/std/time/internal/mach_timebase_info_t.html"],["std::time::internal::mach_absolute_time","","/std/time/internal/#item.mach_absolute_time"],["std::time::internal::mach_timebase_info","","/std/time/internal/#item.mach_timebase_info"],["std::time::internal::TIMEBASE","","/std/time/internal/#item.TIMEBASE"],["std::time::tests::test_monotonish","","/std/time/tests/#item.test_monotonish"],["std::time::tests::test_from","","/std/time/tests/#item.test_from"],["std::time::tests::test_from_negative","","/std/time/tests/#item.test_from_negative"],["std::time::tests::test_artithmetic","","/std/time/tests/#item.test_artithmetic"],["std::time::tests::test_hash","","/std/time/tests/#item.test_hash"],["std::time::tests::test_fmt","","/std/time/tests/#item.test_fmt"],["std::time::tests::BUF","","/std/time/tests/#item.BUF"],["std::typing::internal","","/std/typing/internal/"],["std::typing::tests","","/std/typing/tests/"],["std::typing::dyn"," \"Dyn\" object, a type-erased pointer to an object and a vtable for protocol functions.","/std/typing/dyn.html"],["std::typing::Self"," A placeholder for the `Self` type in the protocol of a `dyn` object.","/std/typing/Self.html"],["std::typing::type_id"," Returns a unique identifer for the type passed as the generic parameter.","/std/typing/#item.type_id"],["std::typing::type_name"," Returns a human-readable name for the type passed as the generic parameter.","/std/typing/#item.type_name"],["std::typing::enum_variants"," Returns the names and associated values of enum variants.","/std/typing/#item.enum_variants"],["std::typing::assert_type_eq"," Asserts that the types are equal.","/std/typing/#item.assert_type_eq"],["std::typing::assert_type_ne"," Asserts that the types are not equal.","/std/typing/#item.assert_type_ne"],["std::typing::TypeId","","/std/typing/#item.TypeId"],["std::typing::internal::make_enum_variant","","/std/typing/internal/#item.make_enum_variant"],["std::typing::internal::dyn_new","","/std/typing/internal/#item.dyn_new"],["std::typing::internal::dyn_const_coerce","","/std/typing/internal/#item.dyn_const_coerce"],["std::typing::internal::dyn_const_cast","","/std/typing/internal/#item.dyn_const_cast"],["std::typing::internal::dyn_data","","/std/typing/internal/#item.dyn_data"],["std::typing::internal::dyn_vtable_index","","/std/typing/internal/#item.dyn_vtable_index"],["std::typing::internal::void_ptr_of","","/std/typing/internal/#item.void_ptr_of"],["std::typing::internal::ENUM_VARIANTS","","/std/typing/internal/#item.ENUM_VARIANTS"],["std::typing::internal::VTABLE","","/std/typing/internal/#item.VTABLE"],["std::typing::tests::Foo","","/std/typing/tests/Foo.html"],["std::typing::tests::Bar","","/std/typing/tests/Bar.html"],["std::typing::tests::Quux","","/std/typing/tests/Quux.html"],["std::typing::tests::Frob","","/std/typing/tests/Frob.html"],["std::typing::tests::test_type_id","","/std/typing/tests/#item.test_type_id"],["std::typing::tests::test_type_name","","/std/typing/tests/#item.test_type_name"],["std::typing::tests::test_dyn","","/std/typing/tests/#item.test_dyn"],["std::typing::tests::test_dyn_multi_protocol","","/std/typing/tests/#item.test_dyn_multi_protocol"],["std::typing::tests::test_dyn_empty_protocol","","/std/typing/tests/#item.test_dyn_empty_protocol"],["std::typing::tests::test_dyn_if_coercion","","/std/typing/tests/#item.test_dyn_if_coercion"],["std::typing::tests::test_dyn_if_coercion_switch","","/std/typing/tests/#item.test_dyn_if_coercion_switch"],["std::typing::tests::Bar::bar","","/std/typing/tests/Bar.html#item.bar"],["std::typing::tests::Foo::foo","","/std/typing/tests/Foo.html#item.foo"],["std::typing::tests::Frob::foo","","/std/typing/tests/Frob.html#item.foo"],["std::typing::tests::Frob::bar","","/std/typing/tests/Frob.html#item.bar"],["std::typing::tests::Quux::foo","","/std/typing/tests/Quux.html#item.foo"],["std::typing::tests::Quux::bar","","/std/typing/tests/Quux.html#item.bar"],["std::util::identity"," Identity function","/std/util/#item.identity"],["std::util::discard"," Take any parameter and discard the result","/std/util/#item.discard"],["std::util::cast"," Cast a value to a different type.","/std/util/#item.cast"],["std::util::coerce"," Coerce a value to a different type without casting","/std/util/#item.coerce"],["std::util::transmute"," Reinterpret the bits of the value as another type.","/std/util/#item.transmute"],["std::util::deref"," Dereference a pointer.","/std/util/#item.deref"],["std::util::unit"," Produce the only value of a unit type out of thin air.","/std/util/#item.unit"],["std::util::apply"," Applies a function on the provided value.","/std/util/#item.apply"],["test::tests"," Quis testabitur ipsos testes","/test/tests/"],["test::TestResult"," Holder for the results of a test case.","/test/TestResult.html"],["test::Args"," Command line arguments for the test runner.","/test/Args.html"],["test::should_fail"," Whether a failure (non-0 exit code) is expected for this test.","/test/#item.should_fail"],["test::ignored"," Whether a test should be ignored.","/test/#item.ignored"],["test::run"," Run a single test case in a forked process and collect output.","/test/#item.run"],["test::print_help_string","","/test/#item.print_help_string"],["test::parse_args"," Parse command line arguments.","/test/#item.parse_args"],["test::filter_tests"," Filter tests based on user-provided criteria (e.g. path prefix).","/test/#item.filter_tests"],["test::main"," Test runner entrypoint.","/test/#item.main"],["test::Args::default","","/test/Args.html#item.default"],["test::TestResult::free","","/test/TestResult.html#item.free"],["test::tests::regular_test","","/test/tests/#item.regular_test"],["test::tests::ignored_test","","/test/tests/#item.ignored_test"],["test::tests::should_fail_test","","/test/tests/#item.should_fail_test"],];
if (typeof window.loadSearchIndex !== "undefined") { window.loadSearchIndex(index); }
