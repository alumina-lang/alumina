// "FFI" interfaces to libc. It assumes glibc on Linux
// Mostly copied/adapted from Rust's libc crate (https://github.com/rust-lang/libc)

use i8 as c_schar;
use u8 as c_uchar;
use i16 as c_short;
use u16 as c_ushort;
use i32 as c_int;
use u32 as c_uint;
use f32 as c_float;
use f64 as c_double;
use i64 as c_longlong;
use u64 as c_ulonglong;
use i64 as intmax_t;
use u64 as uintmax_t;
use usize as size_t;
use isize as ptrdiff_t;
use isize as intptr_t;
use usize as uintptr_t;
use isize as ssize_t;

#[cfg(any(target_os = "macos", target_os = "linux", target_os = "android"))]
{
    use i32 as pid_t;
    use u32 as uid_t;
    use u32 as gid_t;
    use u32 as in_addr_t;
    use u16 as in_port_t;
    use isize as sighandler_t;
}
#[cfg(any(target_os="linux", target_os="android"))]
{
    use c_int as clockid_t;
    use i64 as off64_t;
}

#[cfg(target_os="macos")]
{
    use i8 as c_char;
    use i32 as wchar_t;
    use c_ulong as clock_t;
    use c_long as time_t;
    use u16 as mode_t;
    use i64 as c_long;
    use u64 as c_ulong;
    use c_uint as clockid_t;
    use i64 as off_t;
    use c_uint as nfds_t;
    use u32 as socklen_t;
}

#[cfg(target_os="android")]
{
    use u8 as c_char;
    use u32 as wchar_t;
    use i64 as c_long;
    use u64 as c_ulong;
    use u32 as mode_t;
    use c_long as clock_t;
    use c_long as time_t;
    use c_long as off_t;
    use c_uint as nfds_t;

    #[cfg(target_pointer_width = "32")]
    use i32 as socklen_t;
    
    #[cfg(target_pointer_width = "64")]
    use u32 as socklen_t;
}

#[cfg(target_os="linux")]
{
    #[cfg(target_pointer_width = "32")]
    use i64 as off_t;
    
    #[cfg(target_pointer_width = "64")]
    use i32 as off_t;

    #[cfg(target_arch = "x86")]
    {
        use i32 as c_long;
        use u32 as c_ulong;
        use i8 as c_char;
        use i32 as wchar_t;
        use i32 as clock_t;
        use i32 as time_t;
    }

    #[cfg(target_arch = "arm")]
    {
        use i32 as c_long;
        use u32 as c_ulong;
        use u8 as c_char;
        use u32 as wchar_t;
        use i32 as clock_t;
        use i32 as time_t;
    }

    #[cfg(target_arch = "x86_64")]
    {
        use i8 as c_char;
        use i32 as wchar_t;
        use i64 as clock_t;
        use i64 as time_t;

        #[cfg(target_pointer_width = "32")]
        {
            use i32 as c_long;
            use u32 as c_ulong;
        }

        #[cfg(not(target_pointer_width = "32"))]
        {
            use i64 as c_long;
            use u64 as c_ulong;
        }
    }

    #[cfg(target_arch = "aarch64")]
    {
        use u8 as c_char;
        use u32 as wchar_t;

        #[cfg(target_pointer_width = "32")]
        {
            use i32 as c_long;
            use u32 as c_ulong;
            use i32 as clock_t;
            use i32 as time_t;
        }

        #[cfg(not(target_pointer_width = "32"))]
        {
            use i64 as c_long;
            use u64 as c_ulong;
            use i64 as clock_t;
            use i64 as time_t;
        }
    }

    use u32 as mode_t;
    use u32 as socklen_t;
    use c_ulong as nfds_t;
}

#[cfg(target_os="windows")]
{
    use i8 as c_char;
    use i32 as c_long;
    use u32 as c_ulong;
    use u16 as wchar_t;
}


extern "C" fn free(ptr: &mut void);
extern "C" fn memcpy(dst: &mut void, src: &void, len: size_t) -> &mut void;
extern "C" fn memset(dst: &mut void, ch: c_int, len: size_t) -> &mut void;
extern "C" fn memmove(dst: &mut void, src: &void, len: size_t) -> &mut void;
extern "C" fn memcmp(ptr1: &void, ptr2: &void, len: size_t) -> c_int;
extern "C" fn memchr(ptr: &void, ptr2: c_int, count: size_t) -> &void;
extern "C" fn memmem(haystack: &void, haystacklen: size_t, needle: &void, needle_len: size_t) -> &void;
extern "C" fn malloc(size: size_t) -> &mut void;
extern "C" fn realloc(ptr: &mut void, size: size_t) -> &mut void;
extern "C" fn calloc(num: size_t, size: size_t) -> &mut void;
extern "C" fn exit(ret: c_int) -> !;
extern "C" fn _exit(ret: c_int) -> !;
extern "C" fn strlen(s: &c_char) -> size_t;

#[cfg(any(target_os="linux", target_os="macos", target_os="android"))]
{
    struct timespec {
        tv_sec: time_t,
        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
        tv_nsec: i64,
        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
        tv_nsec: c_long,
    }

    use u16 as sa_family_t;

    struct in_addr {
        s_addr: in_addr_t,
    }

    #[align(4)]
    struct in6_addr {
        s6_addr: [u8; 16],
    }

    struct sockaddr {
        sa_family: sa_family_t,
        sa_data: [c_char; 14],
    }

    struct sockaddr_storage {
        ss_family: sa_family_t,
        __ss_align: size_t,
        
        #[cfg(target_pointer_width = "32")]
        __ss_pad2: [u8; 120],
        #[cfg(target_pointer_width = "64")]
        __ss_pad2: [u8; 112],
    }

    struct sockaddr_in {
        sin_family: sa_family_t,
        sin_port: in_port_t,
        sin_addr: in_addr,
        sin_zero: [u8; 8],
    }

    struct sockaddr_in6 {
        sin6_family: sa_family_t,
        sin6_port: in_port_t,
        sin6_flowinfo: u32,
        sin6_addr: in6_addr,
        sin6_scope_id: u32,
    }

    struct addrinfo {
        ai_flags: c_int,
        ai_family: c_int,
        ai_socktype: c_int,
        ai_protocol: c_int,
        ai_addrlen: socklen_t,

        #[cfg(target_os = "linux")]
        ai_addr: &mut sockaddr,
        ai_canonname: &mut c_char,

        #[cfg(target_os = "android")]
        ai_addr: &mut sockaddr,
        ai_next: &mut addrinfo,
    }

    struct pollfd {
        fd: c_int,
        events: c_short,
        revents: c_short,
    }
    
    #[cfg(any(target_os="linux"))]
    extern "C" fn getrandom(buf: &mut void, buflen: size_t, flags: c_uint) -> ssize_t;
    extern "C" fn write(fd: c_int, buf: &void, len: size_t) -> ssize_t;
    extern "C" fn read(fd: c_int, buf: &mut void, len: size_t) -> ssize_t;
    extern "C" fn open(path: &c_char, oflag: c_int, mode: mode_t) -> c_int;
    extern "C" fn lseek(fd: c_int, offset: off_t, whence: c_int) -> off_t;
    
    #[cfg(not(target_os="macos"))]
    extern "C" fn lseek64(fd: c_int, offset: off64_t, whence: c_int) -> off64_t;

    extern "C" fn close(fd: c_int) -> c_int;
    extern "C" fn fsync(fd: c_int) -> c_int;
    extern "C" fn execv(prog: &c_char, argv: &&c_char) -> c_int;
    extern "C" fn execve(prog: &c_char, argv: &&c_char, envp: &&c_char) -> c_int;
    extern "C" fn kill(pid: pid_t, sig: c_int) -> c_int;
    extern "C" fn sleep(secs: c_uint) -> c_uint;
    extern "C" fn nanosleep(rqtp: &timespec, rmtp: &mut timespec) -> c_int;
    extern "C" fn fork() -> pid_t;
    extern "C" fn pipe(fds: &mut c_int) -> c_int;

    #[cfg(any(target_os="linux", target_os="android"))]
    extern "C" fn pipe2(fds: &mut c_int, flags: c_int) -> c_int;

    extern "C" fn poll(fds: &mut pollfd, nfds: nfds_t, timeout: c_int) -> c_int;

    extern "C" fn dup2(oldfd: c_int, newfd: c_int) -> c_int;
    extern "C" fn waitpid(pid: pid_t, wstatus: &mut c_int, options: c_int) -> pid_t;

    extern "C" fn clock_getres(clk_id: clockid_t, tp: &mut timespec) -> c_int;
    extern "C" fn clock_gettime(clk_id: clockid_t, tp: &mut timespec) -> c_int;

    extern "C" fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t;

    #[cfg(target_os="macos")]
    extern "C" fn ioctl(fd: c_int, request: c_ulong, ...) -> c_int;
    #[cfg(target_os="android")]
    extern "C" fn ioctl(fd: c_int, request: c_int, ...) -> c_int;
    #[cfg(target_os="linux")]
    extern "C" fn ioctl(fd: c_int, request: c_ulong, ...) -> c_int;

    #[codegen(varargs)]
    extern "C" fn fcntl(fd: c_int, cmd: c_int, ...) -> c_int;

    #[cfg(target_os="linux")]
    {
        extern "C" fn __errno_location() -> &mut c_int;
        extern "C" fn __xpg_strerror_r(errnum: c_int, buf: &mut c_char, buflen: size_t) -> c_int;
        use __xpg_strerror_r as strerror_r;
        use __errno_location as __errno;
    }

    #[cfg(target_os="android")]
    {
        extern "C" fn __errno() -> &mut c_int;
        extern "C" fn strerror_r(errnum: c_int, buf: &mut c_char, buflen: size_t) -> c_int;
    }

    #[cfg(target_os="macos")]
    {
        extern "C" fn __error() -> &mut c_int;
        extern "C" fn strerror_r(errnum: c_int, buf: &mut c_char, buflen: size_t) -> c_int;
        use __error as __errno;
    }

    extern "C" fn socket(domain: c_int, ty: c_int, protocol: c_int) -> c_int;
    extern "C" fn connect(socket: c_int, address: &sockaddr, len: socklen_t) -> c_int;
    extern "C" fn listen(socket: c_int, backlog: c_int) -> c_int;
    extern "C" fn accept(socket: c_int, address: &mut sockaddr, address_len: &mut socklen_t) -> c_int;
    extern "C" fn accept4(
        fd: c_int,
        addr: &mut sockaddr,
        len: &mut socklen_t,
        flg: c_int,
    ) -> c_int;

    extern "C" fn setsockopt(
        socket: c_int,
        level: c_int,
        name: c_int,
        value: &void,
        option_len: socklen_t,
    ) -> c_int;
    extern "C" fn recv(socket: c_int, buf: &mut void, len: size_t, flags: c_int) -> ssize_t;
    extern "C" fn send(socket: c_int, buf: &void, len: size_t, flags: c_int) -> ssize_t;
    
    extern "C" fn recvfrom(
        socket: c_int,
        buf: &mut void,
        len: size_t,
        flags: c_int,
        addr: &mut sockaddr,
        addrlen: &mut socklen_t,
    ) -> ssize_t;

    extern "C" fn sendto(
        socket: c_int,
        buf: &void,
        len: size_t,
        flags: c_int,
        addr: &sockaddr,
        addrlen: socklen_t,
    ) -> ssize_t;
    
    extern "C" fn getaddrinfo(
        node: &c_char,
        service: &c_char,
        hints: &addrinfo,
        res: &mut &mut addrinfo,
    ) -> c_int;
    extern "C" fn freeaddrinfo(res: &mut addrinfo);
    extern "C" fn gai_strerror(errcode: c_int) -> &c_char;
    extern "C" fn getpeername(
        socket: c_int,
        address: &mut sockaddr,
        address_len: &mut socklen_t
    ) -> c_int;
    
    extern "C" fn getsockname(
        socket: c_int,
        address: &mut sockaddr,
        address_len: &mut socklen_t
    ) -> c_int;
    extern "C" fn bind(
        socket: c_int, 
        address: &sockaddr, 
        address_len: socklen_t
    ) -> c_int;
    extern "C" fn shutdown(socket: c_int, how: c_int) -> c_int;

    const EXIT_FAILURE: c_int = 1;
    const EXIT_SUCCESS: c_int = 0;

    const STDIN_FILENO: c_int = 0;
    const STDOUT_FILENO: c_int = 1;
    const STDERR_FILENO: c_int = 2;

    
    const SIGHUP: c_int = 1;
    const SIGINT: c_int = 2;
    const SIGQUIT: c_int = 3;
    const SIGILL: c_int = 4;
    const SIGABRT: c_int = 6;
    const SIGFPE: c_int = 8;
    const SIGKILL: c_int = 9;
    const SIGSEGV: c_int = 11;
    const SIGPIPE: c_int = 13;
    const SIGALRM: c_int = 14;
    const SIGTERM: c_int = 15;

    const SIG_DFL: sighandler_t = 0;
    const SIG_IGN: sighandler_t = 1;
    const SIG_ERR: sighandler_t = ~0;

    const SEEK_SET: c_int = 0;
    const SEEK_CUR: c_int = 1;
    const SEEK_END: c_int = 2;
    
    const O_RDONLY: c_int = 0;
    const O_WRONLY: c_int = 1;
    const O_RDWR: c_int = 2;
    const O_ACCMODE: c_int = 3;
    const O_TRUNC: c_int = 512;
    const O_CLOEXEC: c_int = 0x80000;
    const O_APPEND: c_int = 1024;
    const O_CREAT: c_int = 64;
    const O_EXCL: c_int = 128;
    const O_NOCTTY: c_int = 256;
    const O_NONBLOCK: c_int = 2048;
    const O_SYNC: c_int = 1052672;
    const O_RSYNC: c_int = 1052672;
    const O_DSYNC: c_int = 4096;
    const O_FSYNC: c_int = 0x101000;
    const O_NOATIME: c_int = 0x40000;
    const O_PATH: c_int = 0x200000;
    const O_DIRECTORY: c_int = 0x10000;
    const O_TMPFILE: c_int = 0x400000 | O_DIRECTORY;

    const CLOCK_REALTIME: clockid_t = 0;
    const CLOCK_MONOTONIC: clockid_t = 1;
    const CLOCK_PROCESS_CPUTIME_ID: clockid_t = 2;
    const CLOCK_THREAD_CPUTIME_ID: clockid_t = 3;
    const CLOCK_MONOTONIC_RAW: clockid_t = 4;
    const CLOCK_REALTIME_COARSE: clockid_t = 5;
    const CLOCK_MONOTONIC_COARSE: clockid_t = 6;
    const CLOCK_BOOTTIME: clockid_t = 7;
    const CLOCK_REALTIME_ALARM: clockid_t = 8;
    const CLOCK_BOOTTIME_ALARM: clockid_t = 9;
    const CLOCK_TAI: clockid_t = 11;

    const SOCK_STREAM: c_int = 1;
    const SOCK_DGRAM: c_int = 2;

    const EAI_BADFLAGS: c_int = -1;
    const EAI_NONAME: c_int = -2;
    const EAI_AGAIN: c_int = -3;
    const EAI_FAIL: c_int = -4;
    const EAI_NODATA: c_int = -5;
    const EAI_FAMILY: c_int = -6;
    const EAI_SOCKTYPE: c_int = -7;
    const EAI_SERVICE: c_int = -8;
    const EAI_MEMORY: c_int = -10;
    const EAI_SYSTEM: c_int = -11;
    const EAI_OVERFLOW: c_int = -12;

    const EPERM: c_int = 1;
    const ENOENT: c_int = 2;
    const ESRCH: c_int = 3;
    const EINTR: c_int = 4;
    const EIO: c_int = 5;
    const ENXIO: c_int = 6;
    const E2BIG: c_int = 7;
    const ENOEXEC: c_int = 8;
    const EBADF: c_int = 9;
    const ECHILD: c_int = 10;
    const EAGAIN: c_int = 11;
    const ENOMEM: c_int = 12;
    const EACCES: c_int = 13;
    const EFAULT: c_int = 14;
    const ENOTBLK: c_int = 15;
    const EBUSY: c_int = 16;
    const EEXIST: c_int = 17;
    const EXDEV: c_int = 18;
    const ENODEV: c_int = 19;
    const ENOTDIR: c_int = 20;
    const EISDIR: c_int = 21;
    const EINVAL: c_int = 22;
    const ENFILE: c_int = 23;
    const EMFILE: c_int = 24;
    const ENOTTY: c_int = 25;
    const ETXTBSY: c_int = 26;
    const EFBIG: c_int = 27;
    const ENOSPC: c_int = 28;
    const ESPIPE: c_int = 29;
    const EROFS: c_int = 30;
    const EMLINK: c_int = 31;
    const EPIPE: c_int = 32;
    const EDOM: c_int = 33;
    const ERANGE: c_int = 34;
    const EWOULDBLOCK: c_int = EAGAIN;
    const EBFONT: c_int = 59;
    const ENOSTR: c_int = 60;
    const ENODATA: c_int = 61;
    const ETIME: c_int = 62;
    const ENOSR: c_int = 63;
    const ENONET: c_int = 64;
    const ENOPKG: c_int = 65;
    const EREMOTE: c_int = 66;
    const ENOLINK: c_int = 67;
    const EADV: c_int = 68;
    const ESRMNT: c_int = 69;
    const ECOMM: c_int = 70;
    const EPROTO: c_int = 71;
    const EDOTDOT: c_int = 73;

    const POLLIN: c_short = 0x1;
    const POLLPRI: c_short = 0x2;
    const POLLOUT: c_short = 0x4;
    const POLLERR: c_short = 0x8;
    const POLLHUP: c_short = 0x10;
    const POLLNVAL: c_short = 0x20;
    const POLLRDNORM: c_short = 0x040;
    const POLLWRNORM: c_short = 0x004;
    const POLLRDBAND: c_short = 0x080;
    const POLLWRBAND: c_short = 0x100;

    const MSG_OOB: c_int = 1;
    const MSG_PEEK: c_int = 2;
    const MSG_DONTROUTE: c_int = 4;
    const MSG_CTRUNC: c_int = 8;
    const MSG_TRUNC: c_int = 0x20;
    const MSG_DONTWAIT: c_int = 0x40;
    const MSG_EOR: c_int = 0x80;
    const MSG_WAITALL: c_int = 0x100;
    const MSG_FIN: c_int = 0x200;
    const MSG_SYN: c_int = 0x400;
    const MSG_CONFIRM: c_int = 0x800;
    const MSG_RST: c_int = 0x1000;
    const MSG_ERRQUEUE: c_int = 0x2000;
    const MSG_NOSIGNAL: c_int = 0x4000;
    const MSG_MORE: c_int = 0x8000;
    const MSG_WAITFORONE: c_int = 0x10000;
    const MSG_FASTOPEN: c_int = 0x20000000;
    const MSG_CMSG_CLOEXEC: c_int = 0x40000000;

    const F_DUPFD: c_int = 0;
    const F_GETFD: c_int = 1;
    const F_SETFD: c_int = 2;
    const F_GETFL: c_int = 3;
    const F_SETFL: c_int = 4;

    const FD_CLOEXEC: c_int = 0x1;

    #[cfg(target_os = "macos")]
    {
        const FIONBIO: c_ulong = 0x8004667e;
        const FIOCLEX: c_ulong = 0x20006601;
    }
    
    #[cfg(target_os = "android")]
    {
        const FIONBIO: c_int = 0x5421;
        const FIOCLEX: c_int = 0x5451;
    }
    
    #[cfg(target_os = "linux")]
    {
        const FIONBIO: c_ulong = 0x5421;
        const FIOCLEX: c_ulong = 0x5451;
    }

    const AF_UNSPEC: c_int = 0;
    const AF_UNIX: c_int = 1;
    const AF_LOCAL: c_int = 1;
    const AF_INET: c_int = 2;
    const AF_AX25: c_int = 3;
    const AF_IPX: c_int = 4;
    const AF_APPLETALK: c_int = 5;
    const AF_NETROM: c_int = 6;
    const AF_BRIDGE: c_int = 7;
    const AF_ATMPVC: c_int = 8;
    const AF_X25: c_int = 9;
    const AF_INET6: c_int = 10;
    const AF_ROSE: c_int = 11;
    const AF_DECnet: c_int = 12;
    const AF_NETBEUI: c_int = 13;
    const AF_SECURITY: c_int = 14;
    const AF_KEY: c_int = 15;
    const AF_NETLINK: c_int = 16;
    const AF_ROUTE: c_int = AF_NETLINK;
    const AF_PACKET: c_int = 17;
    const AF_ASH: c_int = 18;
    const AF_ECONET: c_int = 19;
    const AF_ATMSVC: c_int = 20;
    const AF_RDS: c_int = 21;
    const AF_SNA: c_int = 22;
    const AF_IRDA: c_int = 23;
    const AF_PPPOX: c_int = 24;
    const AF_WANPIPE: c_int = 25;
    const AF_LLC: c_int = 26;
    const AF_CAN: c_int = 29;
    const AF_TIPC: c_int = 30;
    const AF_BLUETOOTH: c_int = 31;
    const AF_IUCV: c_int = 32;
    const AF_RXRPC: c_int = 33;
    const AF_ISDN: c_int = 34;
    const AF_PHONET: c_int = 35;
    const AF_IEEE802154: c_int = 36;
    const AF_CAIF: c_int = 37;
    const AF_ALG: c_int = 38;

    const SHUT_RD: c_int = 0;
    const SHUT_WR: c_int = 1;
    const SHUT_RDWR: c_int = 2;
}
