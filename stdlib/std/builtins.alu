/// This module holds impl blocks for builtin types all items with #[lang(impl_X)] are
/// treated as X when lowering into IR, so they cannot actually exist as proper structs.

use cmp::{Equatable, Comparable, Ordering, lexicographic_cmp};
use hash::{Hashable, Hasher};
use fmt::{Formatter};

#[lang(impl_void)]
struct _void {}
impl _void {
    mixin Equatable<void>;
    mixin Comparable<void>;

    #[force_inline]
    fn equals(lhs: &void, rhs: &void) -> bool {
        true
    }

    #[force_inline]
    fn compare(lhs: &void, rhs: &void) -> Ordering {
        Ordering::Equal
    }

    #[force_inline]
    fn hash<H: Hasher<H>>(self: &void, hasher: &mut H) {
    }
}

#[lang(impl_bool)]
struct _bool {}
impl _bool {
    #[force_inline]
    fn equals(lhs: &bool, rhs: &bool) -> bool {
        *lhs == *rhs
    }

    #[force_inline]
    fn compare(lhs: &bool, rhs: &bool) -> Ordering {
        if *lhs == *rhs {
            Ordering::Equal
        } else if *rhs {
            Ordering::Less
        } else {
            Ordering::Greater
        }
    }

    fn hash<H: Hasher<H>>(self: &bool, hasher: &mut H) {
        hasher.write(mem::slice::from_raw(self as &u8, 1));
    }

    fn fmt<F: Formatter<F>>(self: &bool, formatter: &mut F) -> Result<(), fmt::Error> {
        formatter.write_str(if *self { "true" } else { "false" })
    }

    mixin Equatable<bool>;
    mixin Comparable<u8>;
}

#[lang(impl_never)]
struct _never {}
impl _never {
    fn equals(lhs: &!, rhs: &!) -> bool {
        std::intrinsics::unreachable()
    }
    
    fn compare(lhs: &!, rhs: &!) -> Ordering {
        std::intrinsics::unreachable()
    }
    
    fn hash<H: Hasher<H>>(self: &!, hasher: &mut H) {
        std::intrinsics::unreachable()
    }
    
    fn fmt<F: Formatter<F>>(self: &!, formatter: &mut F) -> Result<(), fmt::Error> {
        std::intrinsics::unreachable()
    }

    mixin Equatable<bool>;
    mixin Comparable<u8>;
}

// This mixin implements Equatable and Comparable for types that have natively implemented
// equality and comparison operators.
protocol _BuiltinComparable<Self: marker::Numeric> {
    #[force_inline] fn equals(lhs: &Self, rhs: &Self) -> bool { *lhs == *rhs }
    #[force_inline] fn not_equals(lhs: &Self, rhs: &Self) -> bool { *lhs != *rhs }    
    #[force_inline]
    fn compare(lhs: &Self, rhs: &Self) -> Ordering {
        if *lhs < *rhs {
            Ordering::Less
        } else if *lhs == *rhs {
            Ordering::Equal
        } else {
            Ordering::Greater
        }
    }

    #[force_inline] fn less_than(lhs: &Self, rhs: &Self) -> bool { *lhs < *rhs }
    #[force_inline] fn less_than_or_equal(lhs: &Self, rhs: &Self) -> bool { *lhs <= *rhs }
    #[force_inline] fn greater_than(lhs: &Self, rhs: &Self) -> bool { *lhs > *rhs }
    #[force_inline] fn greater_than_or_equal(lhs: &Self, rhs: &Self) -> bool { *lhs >= *rhs }
}

protocol _IntegerParsable<Self: marker::Integer> {
    #[inline]
    fn parse(s: &[u8]) -> Option<Self> {
        string::parse_integer::<Self>(s, 10)
    }

    #[inline]
    fn parse_with_radix(s: &[u8], radix: u16) -> Option<Self> {
        string::parse_integer::<Self>(s, radix)
    }
}

protocol _IntegerFormattable<Self: marker::Integer, F: Formatter<F>> {
    fn fmt(self: &Self, formatter: &mut F) -> Result<(), fmt::Error> {
        fmt::internal::format_integer(*self, 10, 0, formatter)
    }
}

protocol _FloatFormattable<Self: marker::FloatingPoint, F: Formatter<F>> {
    fn fmt(self: &Self, formatter: &mut F) -> Result<(), fmt::Error> {
        fmt::internal::format_float(*self, formatter, 15)
    }
}

protocol _BitOps<Self: marker::Unsigned> {
    #[inline(always)]
    fn rotate_left(self: Self, shift: usize) -> Self {
        (self << shift) | (self >> ((8 * mem::size_of::<Self>()) - shift))
    }

    #[inline(always)]
    fn rotate_right(self: Self, shift: usize) -> Self {
        (self >> shift) | (self << ((8 * mem::size_of::<Self>()) - shift))
    }
}

#[lang(impl_u8)]
struct _u8 {}
impl _u8 {
    mixin _BitOps<u8>;
    mixin _BuiltinComparable<u8>;
    mixin<H: Hasher<H>> Hashable<u8, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<u8, F>;
    mixin _IntegerParsable<u8>;

    #[force_inline]
    fn max_value() -> u8 {
        0xffu8
    }

    #[force_inline]
    fn min_value() -> u8 {
        0u8
    }
}

#[lang(impl_u16)]
struct _u16 {}
impl _u16 {
    mixin _BitOps<u16>;
    mixin _BuiltinComparable<u16>;
    mixin<H: Hasher<H>> Hashable<u16, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<u16, F>;
    mixin _IntegerParsable<u16>;

    #[force_inline]
    fn max_value() -> u16 {
        0xffffu16
    }

    #[force_inline]
    fn min_value() -> u16 {
        0u16
    }
}

#[lang(impl_u32)]
struct _u32 {}
impl _u32 {
    mixin _BitOps<u32>;
    mixin _BuiltinComparable<u32>;
    mixin<H: Hasher<H>> Hashable<u32, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<u32, F>;
    mixin _IntegerParsable<u32>;

    #[force_inline]
    fn max_value() -> u32 {
        0xffffffffu32
    }

    #[force_inline]
    fn min_value() -> u32 {
        0u32
    }
}

#[lang(impl_u64)]
struct _u64 {}
impl _u64 {
    mixin _BitOps<u64>;
    mixin _BuiltinComparable<u64>;
    mixin<H: Hasher<H>> Hashable<u64, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<u64, F>;
    mixin _IntegerParsable<u64>;

    #[force_inline]
    fn max_value() -> u64 {
        0xffffffffffffffffu64
    }

    #[force_inline]
    fn min_value() -> u64 {
        0u64
    }
}

#[lang(impl_u128)]
struct _u128 {}
impl _u128 {
    mixin _BitOps<u128>;
    mixin _BuiltinComparable<u128>;
    mixin<H: Hasher<H>> Hashable<u128, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<u128, F>;
    mixin _IntegerParsable<u128>;

    #[force_inline]
    fn max_value() -> u128 {
        0xffffffffffffffffffffffffffffffffu128
    }

    #[force_inline]
    fn min_value() -> u128 {
        0u128
    }
}

#[lang(impl_usize)]
struct _usize {}
impl _usize {
    mixin _BitOps<usize>;
    mixin _BuiltinComparable<usize>;
    mixin<H: Hasher<H>> Hashable<usize, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<usize, F>;
    mixin _IntegerParsable<usize>;

    #[force_inline]
    fn max_value() -> usize {
        #[cfg(target_pointer_width = "32")]
        {
            u32::max_value() as usize
        }
        #[cfg(target_pointer_width = "64")]
        {
            u64::max_value() as usize
        }        
    }

    #[force_inline]
    fn min_value() -> usize {
        #[cfg(target_pointer_width = "32")]
        {
            u32::min_value() as usize
        }
        #[cfg(target_pointer_width = "64")]
        {
            u64::min_value() as usize
        }   
    }
}

#[lang(impl_i8)]
struct _i8 {}
impl _i8 {
    mixin _BuiltinComparable<i8>;
    mixin<H: Hasher<H>> Hashable<i8, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<i8, F>;
    mixin _IntegerParsable<i8>;

    #[force_inline]
    fn max_value() -> i8 {
        0x7fu8 as i8
    }

    #[force_inline]
    fn min_value() -> i8 {
        0x80u8 as i8
    }
}

#[lang(impl_i16)]
struct _i16 {}
impl _i16 {
    mixin _BuiltinComparable<i16>;
    mixin<H: Hasher<H>> Hashable<i16, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<i16, F>;
    mixin _IntegerParsable<i16>;

    #[force_inline]
    fn max_value() -> i16 {
        0x7fffu16 as i16
    }

    #[force_inline]
    fn min_value() -> i16 {
        0x8000u16 as i16
    }
}

#[lang(impl_i32)]
struct _i32 {}
impl _i32 {
    mixin _BuiltinComparable<i32>;
    mixin<H: Hasher<H>> Hashable<i32, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<i32, F>;
    mixin _IntegerParsable<i32>;

    #[force_inline]
    fn max_value() -> i32 {
        0x7fffffffu32 as i32
    }

    #[force_inline]
    fn min_value() -> i32 {
        0x80000000u32 as i32
    }
}

#[lang(impl_i64)]
struct _i64 {}
impl _i64 {
    mixin _BuiltinComparable<i64>;
    mixin<H: Hasher<H>> Hashable<i64, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<i64, F>;
    mixin _IntegerParsable<i64>;

    #[force_inline]
    fn max_value() -> i64 {
        0x7fffffffffffffffu64 as i64
    }

    #[force_inline]
    fn min_value() -> i64 {
        0x8000000000000000u64 as i64
    }
}

#[lang(impl_i128)]
struct _i128 {}
impl _i128 {
    mixin _BuiltinComparable<i128>;
    mixin<H: Hasher<H>> Hashable<i128, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<i128, F>;
    mixin _IntegerParsable<i128>;

    #[force_inline]
    fn max_value() -> i128 {
        0x7fffffffffffffffffffffffffffffffu128 as i128
    }

    #[force_inline]
    fn min_value() -> i128 {
        0x80000000000000000000000000000000u128 as i128
    }
}

#[lang(impl_isize)]
struct _isize {}
impl _isize {
    mixin _BuiltinComparable<isize>;
    mixin<H: Hasher<H>> Hashable<isize, H>;
    mixin<F: Formatter<F>> _IntegerFormattable<isize, F>;
    mixin _IntegerParsable<isize>;

    #[force_inline]
    fn max_value() -> isize {
        #[cfg(target_pointer_width = "32")]
        {
            i32::max_value() as isize
        }
        #[cfg(target_pointer_width = "64")]
        {
            i64::max_value() as isize
        }
    }

    #[force_inline]
    fn min_value() -> isize {
        #[cfg(target_pointer_width = "32")]
        {
            i32::min_value() as isize
        }
        #[cfg(target_pointer_width = "64")]
        {
            i64::min_value() as isize
        }
    }
}

protocol _FloatOps<Self> {
    #[inline]
    fn nan() -> Self {
        (0.0 as Self) / (0.0 as Self)
    }

    #[inline]
    fn infinity() -> Self {
        (1.0 as Self) / (0.0 as Self)
    }

    #[inline]
    fn neg_infinity() -> Self {
        (-1.0 as Self) / (0.0 as Self)
    }

    #[inline]
    fn is_nan(self: Self) -> bool {
        self != self
    }

    #[inline]
    fn is_infinite(self: Self) -> bool {
        !self.is_nan() && !self.is_finite()
    }

    #[inline]
    fn is_finite(self: Self) -> bool {
        !self.is_nan() && self < Self::infinity() && self > Self::neg_infinity()
    }
}

#[lang(impl_f32)]
struct _f32 {}
impl _f32 {
    mixin _BuiltinComparable<f32>;
    // Not hashable
    mixin<F: Formatter<F>> _FloatFormattable<f32, F>;
    mixin _FloatOps<f32>;

    #[force_inline]
    fn is_sign_negative(self: f32) -> bool {
        let as_bits: u64 = util::transmute(self);
        as_bits & 0x80000000u64 != 0
    }

    #[force_inline]
    fn max_value() -> f32 {
        3.40282347e+38f32
    }

    #[force_inline]
    fn min_value() -> f32 {
        -3.40282347e+38f32
    }

    #[force_inline]
    fn min_positive() -> f32 {
        1.17549435e-38f32
    }

    #[force_inline]
    fn epsilon() -> f32 {
        1.19209290e-07f32
    }

    #[force_inline]
    fn acos(self: f32) -> f32 {
        libm::acosf(self)
    }

    #[force_inline]
    fn asin(self: f32) -> f32 {
        libm::asinf(self)
    }

    #[force_inline]
    fn atan(self: f32) -> f32 {
        libm::atanf(self)
    }

    #[force_inline]
    fn atan2(self: f32, other: f32) -> f32 {
        libm::atan2f(self, other)
    }

    #[force_inline]
    fn atanh(self: f32) -> f32 {
        libm::atanhf(self)
    }

    #[force_inline]
    fn cbrt(self: f32) -> f32 {
        libm::cbrtf(self)
    }

    #[force_inline]
    fn ceil(self: f32) -> f32 {
        libm::ceilf(self)
    }

    #[force_inline]
    fn cos(self: f32) -> f32 {
        libm::cosf(self)
    }

    #[force_inline]
    fn cosh(self: f32) -> f32 {
        libm::coshf(self)
    }

    #[force_inline]
    fn erf(self: f32) -> f32 {
        libm::erff(self)
    }

    #[force_inline]
    fn erfc(self: f32) -> f32 {
        libm::erfcf(self)
    }

    #[force_inline]
    fn exp(self: f32) -> f32 {
        libm::expf(self)
    }


    #[force_inline]
    fn floor(self: f32) -> f32 {
        libm::floorf(self)
    }

    #[force_inline]
    fn frexp(self: f32) -> (f32, i32) {
        let out: i32;
        let val = libm::frexpf(self, &out);
        (val, out)
    }

    #[force_inline]
    fn ldexp(self: f32, exp: i32) -> f32 {
        libm::ldexpf(self, exp)
    }

    #[force_inline]
    fn log(self: f32) -> f32 {
        libm::logf(self)
    }

    #[force_inline]
    fn log2(self: f32) -> f32 {
        libm::log2f(self)
    }

    #[force_inline]
    fn log10(self: f32) -> f32 {
        libm::log10f(self)
    }

    #[force_inline]
    fn modf(self: f32) -> (f32, f32) {
        let out: f32;
        let val = libm::modff(self, &out);
        (out, val)
    }

    #[force_inline]
    fn pow(self: f32, other: f32) -> f32 {
        libm::powf(self, other)
    }

    #[force_inline]
    fn round(self: f32) -> f32 {
        libm::roundf(self)
    }

    #[force_inline]
    fn sin(self: f32) -> f32 {
        libm::sinf(self)
    }

    #[force_inline]
    fn sinh(self: f32) -> f32 {
        libm::sinhf(self)
    }

    #[force_inline]
    fn sqrt(self: f32) -> f32 {
        libm::sqrtf(self)
    }

    #[force_inline]
    fn tan(self: f32) -> f32 {
        libm::tanf(self)
    }

    #[force_inline]
    fn tanh(self: f32) -> f32 {
        libm::tanhf(self)
    }

    #[force_inline]
    fn trunc(self: f32) -> f32 {
        libm::truncf(self)
    }
}

#[lang(impl_f64)]
struct _f64 {}
impl _f64 {
    mixin _BuiltinComparable<f64>;
    // Not hashable
    mixin<F: Formatter<F>> _FloatFormattable<f64, F>;
    mixin _FloatOps<f64>;

    #[force_inline]
    fn is_sign_negative(self: f64) -> bool {
        let as_bits: u64 = util::transmute(self);
        as_bits & 0x8000000000000000u64 != 0
    }

    #[force_inline]
    fn max_value() -> f64 {
        1.7976931348623157e+308f64
    }

    #[force_inline]
    fn min_value() -> f64 {
        -1.7976931348623157e+308f64
    }

    #[force_inline]
    fn min_positive() -> f64 {
        2.2250738585072014e-308f64
    }

    #[force_inline]
    fn epsilon() -> f64 {
        2.2204460492503131e-16f64
    }

    #[force_inline]
    fn acos(self: f64) -> f64 {
        libm::acos(self)
    }

    #[force_inline]
    fn asin(self: f64) -> f64 {
        libm::asin(self)
    }

    #[force_inline]
    fn atan(self: f64) -> f64 {
        libm::atan(self)
    }

    #[force_inline]
    fn atan2(self: f64, other: f64) -> f64 {
        libm::atan2(self, other)
    }

    #[force_inline]
    fn atanh(self: f64) -> f64 {
        libm::atanh(self)
    }

    #[force_inline]
    fn cbrt(self: f64) -> f64 {
        libm::cbrt(self)
    }

    #[force_inline]
    fn ceil(self: f64) -> f64 {
        libm::ceil(self)
    }

    #[force_inline]
    fn cos(self: f64) -> f64 {
        libm::cos(self)
    }

    #[force_inline]
    fn cosh(self: f64) -> f64 {
        libm::cosh(self)
    }

    #[force_inline]
    fn erf(self: f64) -> f64 {
        libm::erf(self)
    }

    #[force_inline]
    fn erfc(self: f64) -> f64 {
        libm::erfc(self)
    }

    #[force_inline]
    fn exp(self: f64) -> f64 {
        libm::exp(self)
    }

    #[force_inline]
    fn floor(self: f64) -> f64 {
        libm::floor(self)
    }

    #[force_inline]
    fn frexp(self: f64) -> (f64, i32) {
        let out: i32;
        let val = libm::frexp(self, &out);
        (val, out)
    }

    #[force_inline]
    fn ldexp(self: f64, exp: i32) -> f64 {
        libm::ldexp(self, exp)
    }

    #[force_inline]
    fn log(self: f64) -> f64 {
        libm::log(self)
    }

    #[force_inline]
    fn log2(self: f64) -> f64 {
        libm::log2(self)
    }

    #[force_inline]
    fn log10(self: f64) -> f64 {
        libm::log10(self)
    }

    #[force_inline]
    fn modf(self: f64) -> (f64, f64) {
        let out: f64;
        let val = libm::modf(self, &out);
        (out, val)
    }

    #[force_inline]
    fn pow(self: f64, other: f64) -> f64 {
        libm::pow(self, other)
    }

    #[force_inline]
    fn round(self: f64) -> f64 {
        libm::round(self)
    }

    #[force_inline]
    fn sin(self: f64) -> f64 {
        libm::sin(self)
    }

    #[force_inline]
    fn sinh(self: f64) -> f64 {
        libm::sinh(self)
    }

    #[force_inline]
    fn sqrt(self: f64) -> f64 {
        libm::sqrt(self)
    }

    #[force_inline]
    fn tan(self: f64) -> f64 {
        libm::tan(self)
    }

    #[force_inline]
    fn tanh(self: f64) -> f64 {
        libm::tanh(self)
    }

    #[force_inline]
    fn trunc(self: f64) -> f64 {
        libm::trunc(self)
    }
}

// hic sunt dracones, this is ugly af, but without variadic generics, this 
// is probably the best way without implementing it all inside the compiler
// Also, who needs Rust-like macros when you have GitHub Copilot?

#[lang(impl_tuple_1)]
struct _tuple_1 {}
impl _tuple_1 {
    #[inline]
    fn equals<T1: Equatable<T1>>(lhs: &(T1,), rhs: &(T1,)) -> bool {
        lhs.0.equals(&rhs.0)
    }

    #[inline]
    fn compare<T1: Comparable<T1>>(lhs: &(T1,), rhs: &(T1,)) -> Ordering {
        lhs.0.compare(&rhs.0)
    }

    #[inline]
    fn hash<T1: Hashable<T1, H>, H: Hasher<H>>(lhs: &(T1,), h: &mut H) {
        lhs.0.hash(h)
    }

    mixin<T1: Equatable<T1>> Equatable<(T1,)>;
    mixin<T1: Comparable<T1>> Comparable<(T1,)>;
}

#[lang(impl_tuple_2)]
struct _tuple_2 {}
impl _tuple_2 {
    #[inline]
    fn equals<
        T1: Equatable<T1>, 
        T2: Equatable<T2>
    >(lhs: &(T1, T2), rhs: &(T1, T2)) -> bool {
        lhs.0.equals(&rhs.0) && lhs.1.equals(&rhs.1)
    }

    #[inline]
    fn compare<
        T1: Comparable<T1>, 
        T2: Comparable<T2>
    >(lhs: &(T1, T2), rhs: &(T1, T2)) -> Ordering {
        lexicographic_cmp!(lhs.0, rhs.0);
        lexicographic_cmp!(lhs.1, rhs.1);
        Ordering::Equal
    }

    #[inline]
    fn hash<
        T1: Hashable<T1, H>, 
        T2: Hashable<T2, H>, 
        H: Hasher<H>
    >(lhs: &(T1, T2), h: &mut H) {
        lhs.0.hash(h);
        lhs.1.hash(h);
    }

    mixin<T1: Equatable<T1>, T2: Equatable<T2>> Equatable<(T1, T2)>;
    mixin<T1: Comparable<T1>, T2: Comparable<T2>> Comparable<(T1, T2)>;
}

#[lang(impl_tuple_3)]
struct _tuple_3 {}
impl _tuple_3 {
    #[inline]
    fn equals<
        T1: Equatable<T1>,
        T2: Equatable<T2>, 
        T3: Equatable<T3>
    >(lhs: &(T1, T2, T3), rhs: &(T1, T2, T3)) -> bool {
        lhs.0.equals(&rhs.0) && lhs.1.equals(&rhs.1) && lhs.2.equals(&rhs.2)
    }

    #[inline]
    fn compare<
        T1: Comparable<T1>, 
        T2: Comparable<T2>, 
        T3: Comparable<T3>
    >(lhs: &(T1, T2, T3), rhs: &(T1, T2, T3)) -> Ordering {
        lexicographic_cmp!(lhs.0, rhs.0);
        lexicographic_cmp!(lhs.1, rhs.1);
        lexicographic_cmp!(lhs.2, rhs.2);
        Ordering::Equal
    }

    #[inline]
    fn hash<
        T1: Hashable<T1, H>, 
        T2: Hashable<T2, H>, 
        T3: Hashable<T3, H>, 
        H: Hasher<H>
    >(lhs: &(T1, T2, T3), h: &mut H) {
        lhs.0.hash(h);
        lhs.1.hash(h);
        lhs.2.hash(h);
    }

    mixin<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>
    > Equatable<(T1, T2, T3)>;

    mixin<
        T1: Comparable<T1>,
        T2: Comparable<T2>,
        T3: Comparable<T3>
    > Comparable<(T1, T2, T3)>;
}

#[lang(impl_tuple_4)]
struct _tuple_4 {}
impl _tuple_4 {
    #[inline]
    fn equals<
        T1: Equatable<T1>,
        T2: Equatable<T2>,
        T3: Equatable<T3>,
        T4: Equatable<T4>
    >(lhs: &(T1, T2, T3, T4), rhs: &(T1, T2, T3, T4)) -> bool {
        lhs.0.equals(&rhs.0) && 
            lhs.1.equals(&rhs.1) && 
            lhs.2.equals(&rhs.2) && 
            lhs.3.equals(&rhs.3)
    }

    #[inline]
    fn compare<
        T1: Comparable<T1>, 
        T2: Comparable<T2>, 
        T3: Comparable<T3>, 
        T4: Comparable<T4>
    >(lhs: &(T1, T2, T3, T4), rhs: &(T1, T2, T3, T4)) -> Ordering {
        lexicographic_cmp!(lhs.0, rhs.0);
        lexicographic_cmp!(lhs.1, rhs.1);
        lexicographic_cmp!(lhs.2, rhs.2);
        lexicographic_cmp!(lhs.3, rhs.3);
        Ordering::Equal
    }

    #[inline]
    fn hash<
        T1: Hashable<T1, H>, 
        T2: Hashable<T2, H>, 
        T3: Hashable<T3, H>,
        T4: Hashable<T4, H>, 
        H: Hasher<H>
    >(lhs: &(T1, T2, T3, T4), h: &mut H) {
        lhs.0.hash(h);
        lhs.1.hash(h);
        lhs.2.hash(h);
        lhs.3.hash(h);
    }

    mixin<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>
    > Equatable<(T1, T2, T3, T4)>;

    mixin<
        T1: Comparable<T1>,
        T2: Comparable<T2>,
        T3: Comparable<T3>,
        T4: Comparable<T4>
    > Comparable<(T1, T2, T3, T4)>;
}

#[lang(impl_tuple_5)]
struct _tuple_5 {}
impl _tuple_5 {
    #[inline]
    fn equals<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>, 
        T5: Equatable<T5>
    >(lhs: &(T1, T2, T3, T4, T5), rhs: &(T1, T2, T3, T4, T5)) -> bool {
        lhs.0.equals(&rhs.0) && 
            lhs.1.equals(&rhs.1) && 
            lhs.2.equals(&rhs.2) && 
            lhs.3.equals(&rhs.3) && 
            lhs.4.equals(&rhs.4)
    }

    #[inline]
    fn compare<
        T1: Comparable<T1>, 
        T2: Comparable<T2>, 
        T3: Comparable<T3>, 
        T4: Comparable<T4>, 
        T5: Comparable<T5>
    >(lhs: &(T1, T2, T3, T4, T5), rhs: &(T1, T2, T3, T4, T5)) -> Ordering {
        lexicographic_cmp!(lhs.0, rhs.0);
        lexicographic_cmp!(lhs.1, rhs.1);
        lexicographic_cmp!(lhs.2, rhs.2);
        lexicographic_cmp!(lhs.3, rhs.3);
        lexicographic_cmp!(lhs.4, rhs.4);
        Ordering::Equal
    }

    #[inline]
    fn hash<
        T1: Hashable<T1, H>, 
        T2: Hashable<T2, H>, 
        T3: Hashable<T3, H>, 
        T4: Hashable<T4, H>, 
        T5: Hashable<T5, H>, 
        H: Hasher<H>
    >(lhs: &(T1, T2, T3, T4, T5), h: &mut H) {
        lhs.0.hash(h);
        lhs.1.hash(h);
        lhs.2.hash(h);
        lhs.3.hash(h);
        lhs.4.hash(h);
    }

    mixin<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>,
        T5: Equatable<T5>
    > Equatable<(T1, T2, T3, T4, T5)>;

    mixin<
        T1: Comparable<T1>,
        T2: Comparable<T2>,
        T3: Comparable<T3>,
        T4: Comparable<T4>,
        T5: Comparable<T5>
    > Comparable<(T1, T2, T3, T4, T5)>;
}

#[lang(impl_tuple_6)]
struct _tuple_6 {}
impl _tuple_6 {
    #[inline]
    fn equals<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>, 
        T5: Equatable<T5>, 
        T6: Equatable<T6>
    >(
        lhs: &(T1, T2, T3, T4, T5, T6), 
        rhs: &(T1, T2, T3, T4, T5, T6)
    ) -> bool {
        lhs.0.equals(&rhs.0) && 
            lhs.1.equals(&rhs.1) && 
            lhs.2.equals(&rhs.2) && 
            lhs.3.equals(&rhs.3) && 
            lhs.4.equals(&rhs.4) && 
            lhs.5.equals(&rhs.5)
    }

    #[inline]
    fn compare<
        T1: Comparable<T1>, 
        T2: Comparable<T2>, 
        T3: Comparable<T3>, 
        T4: Comparable<T4>, 
        T5: Comparable<T5>, 
        T6: Comparable<T6>
    >(
        lhs: &(T1, T2, T3, T4, T5, T6), 
        rhs: &(T1, T2, T3, T4, T5, T6)
    ) -> Ordering {
        lexicographic_cmp!(lhs.0, rhs.0);
        lexicographic_cmp!(lhs.1, rhs.1);
        lexicographic_cmp!(lhs.2, rhs.2);
        lexicographic_cmp!(lhs.3, rhs.3);
        lexicographic_cmp!(lhs.4, rhs.4);
        lexicographic_cmp!(lhs.5, rhs.5);
        Ordering::Equal
    }

    #[inline]
    fn hash<
        T1: Hashable<T1, H>, 
        T2: Hashable<T2, H>, 
        T3: Hashable<T3, H>, 
        T4: Hashable<T4, H>, 
        T5: Hashable<T5, H>, 
        T6: Hashable<T6, H>, 
        H: Hasher<H>
    >(lhs: &(T1, T2, T3, T4, T5, T6), h: &mut H) {
        lhs.0.hash(h);
        lhs.1.hash(h);
        lhs.2.hash(h);
        lhs.3.hash(h);
        lhs.4.hash(h);
        lhs.5.hash(h);
    }

    mixin<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>,
        T5: Equatable<T5>,
        T6: Equatable<T6>
    > Equatable<(T1, T2, T3, T4, T5, T6)>;

    mixin<
        T1: Comparable<T1>,
        T2: Comparable<T2>,
        T3: Comparable<T3>,
        T4: Comparable<T4>,
        T5: Comparable<T5>,
        T6: Comparable<T6>
    > Comparable<(T1, T2, T3, T4, T5, T6)>;
}

#[lang(impl_tuple_7)]
struct _tuple_7 {}
impl _tuple_7 {
    #[inline]
    fn equals<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>, 
        T5: Equatable<T5>, 
        T6: Equatable<T6>, 
        T7: Equatable<T7>
    >(
        lhs: &(T1, T2, T3, T4, T5, T6, T7), 
        rhs: &(T1, T2, T3, T4, T5, T6, T7)
    ) -> bool {
        lhs.0.equals(&rhs.0) && 
            lhs.1.equals(&rhs.1) && 
            lhs.2.equals(&rhs.2) && 
            lhs.3.equals(&rhs.3) && 
            lhs.4.equals(&rhs.4) && 
            lhs.5.equals(&rhs.5) && 
            lhs.6.equals(&rhs.6)
    }

    #[inline]
    fn compare<
        T1: Comparable<T1>, 
        T2: Comparable<T2>, 
        T3: Comparable<T3>, 
        T4: Comparable<T4>, 
        T5: Comparable<T5>, 
        T6: Comparable<T6>, 
        T7: Comparable<T7>
    >(
        lhs: &(T1, T2, T3, T4, T5, T6, T7), 
        rhs: &(T1, T2, T3, T4, T5, T6, T7)
    ) -> Ordering {
        lexicographic_cmp!(lhs.0, rhs.0);
        lexicographic_cmp!(lhs.1, rhs.1);
        lexicographic_cmp!(lhs.2, rhs.2);
        lexicographic_cmp!(lhs.3, rhs.3);
        lexicographic_cmp!(lhs.4, rhs.4);
        lexicographic_cmp!(lhs.5, rhs.5);
        lexicographic_cmp!(lhs.6, rhs.6);
        Ordering::Equal
    }

    #[inline]
    fn hash<
        T1: Hashable<T1, H>, 
        T2: Hashable<T2, H>, 
        T3: Hashable<T3, H>, 
        T4: Hashable<T4, H>, 
        T5: Hashable<T5, H>, 
        T6: Hashable<T6, H>, 
        T7: Hashable<T7, H>, 
        H: Hasher<H>
    >(lhs: &(T1, T2, T3, T4, T5, T6, T7), h: &mut H) {
        lhs.0.hash(h);
        lhs.1.hash(h);
        lhs.2.hash(h);
        lhs.3.hash(h);
        lhs.4.hash(h);
        lhs.5.hash(h);
        lhs.6.hash(h);
    }

    mixin<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>,
        T5: Equatable<T5>,
        T6: Equatable<T6>,
        T7: Equatable<T7>
    > Equatable<(T1, T2, T3, T4, T5, T6, T7)>;

    mixin<
        T1: Comparable<T1>,
        T2: Comparable<T2>,
        T3: Comparable<T3>,
        T4: Comparable<T4>,
        T5: Comparable<T5>,
        T6: Comparable<T6>,
        T7: Comparable<T7>
    > Comparable<(T1, T2, T3, T4, T5, T6, T7)>;
}

#[lang(impl_tuple_8)]
struct _tuple_8 {}
impl _tuple_8 {
    #[inline]
    fn equals<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>, 
        T5: Equatable<T5>, 
        T6: Equatable<T6>, 
        T7: Equatable<T7>, 
        T8: Equatable<T8>
    >(
        lhs: &(T1, T2, T3, T4, T5, T6, T7, T8), 
        rhs: &(T1, T2, T3, T4, T5, T6, T7, T8)
    ) -> bool {
        lhs.0.equals(&rhs.0) && 
            lhs.1.equals(&rhs.1) && 
            lhs.2.equals(&rhs.2) && 
            lhs.3.equals(&rhs.3) && 
            lhs.4.equals(&rhs.4) && 
            lhs.5.equals(&rhs.5) && 
            lhs.6.equals(&rhs.6) && 
            lhs.7.equals(&rhs.7)
    }

    #[inline]
    fn compare<
        T1: Comparable<T1>, 
        T2: Comparable<T2>, 
        T3: Comparable<T3>, 
        T4: Comparable<T4>, 
        T5: Comparable<T5>, 
        T6: Comparable<T6>, 
        T7: Comparable<T7>, 
        T8: Comparable<T8>
    >(
        lhs: &(T1, T2, T3, T4, T5, T6, T7, T8), 
        rhs: &(T1, T2, T3, T4, T5, T6, T7, T8)
    ) -> Ordering {
        lexicographic_cmp!(lhs.0, rhs.0);
        lexicographic_cmp!(lhs.1, rhs.1);
        lexicographic_cmp!(lhs.2, rhs.2);
        lexicographic_cmp!(lhs.3, rhs.3);
        lexicographic_cmp!(lhs.4, rhs.4);
        lexicographic_cmp!(lhs.5, rhs.5);
        lexicographic_cmp!(lhs.6, rhs.6);
        lexicographic_cmp!(lhs.7, rhs.7);
        Ordering::Equal
    }

    #[inline]
    fn hash<
        T1: Hashable<T1, H>, 
        T2: Hashable<T2, H>, 
        T3: Hashable<T3, H>, 
        T4: Hashable<T4, H>, 
        T5: Hashable<T5, H>, 
        T6: Hashable<T6, H>, 
        T7: Hashable<T7, H>, 
        T8: Hashable<T8, H>, 
        H: Hasher<H>
    >(lhs: &(T1, T2, T3, T4, T5, T6, T7, T8), h: &mut H) {
        lhs.0.hash(h);
        lhs.1.hash(h);
        lhs.2.hash(h);
        lhs.3.hash(h);
        lhs.4.hash(h);
        lhs.5.hash(h);
        lhs.6.hash(h);
        lhs.7.hash(h);
    }

    mixin<
        T1: Equatable<T1>, 
        T2: Equatable<T2>, 
        T3: Equatable<T3>, 
        T4: Equatable<T4>,
        T5: Equatable<T5>,
        T6: Equatable<T6>,
        T7: Equatable<T7>,
        T8: Equatable<T8>
    > Equatable<(T1, T2, T3, T4, T5, T6, T7, T8)>;

    mixin<
        T1: Comparable<T1>,
        T2: Comparable<T2>,
        T3: Comparable<T3>,
        T4: Comparable<T4>,
        T5: Comparable<T5>,
        T6: Comparable<T6>,
        T7: Comparable<T7>,
        T8: Comparable<T8>
    > Comparable<(T1, T2, T3, T4, T5, T6, T7, T8)>;
}


#[lang(impl_array)]
struct _array {}
impl _array {
    use marker::ArrayOf;

    // There are not const usize generics, so we cannot generically accept all
    // possible arrays proper in this impl. Instead we accept slice as a self 
    // parameter and rely on automatic slice coercion, which makes this mostly no-op.

    #[force_inline]
    fn as_slice<T, Arr: ArrayOf<T>>(self: &Arr) -> &[T] {
        self
    }

    #[force_inline]
    fn as_slice_mut<T, Arr: ArrayOf<T>>(self: &mut Arr) -> &mut [T] {
        self
    }

    #[force_inline]
    fn iter<T, Arr: ArrayOf<T>>(self: &Arr) -> mem::SliceIterator<&T> {
        self.as_slice().iter()
    }
}

/// The following are "type-operators", pseudo-types, implemented inside the compiler
/// that resolve to other types based on the type of the generic parameters. Ideally,
/// these would be implemented in the standard library, but the infer system is not 
/// yet sufficiently powerful for this.

#[lang(typeop_signed_of)]
struct signed_of<T: marker::Integer> {}

#[lang(typeop_unsigned_of)]
struct unsigned_of<T: marker::Integer> {}

#[lang(typeop_deref_of)]
struct deref_of<T: marker::Pointer> {}

#[lang(typeop_tuple_head_of)]
struct tuple_head_of<T: marker::Tuple> {}

#[lang(typeop_tuple_tail_of)]
struct tuple_tail_of<T: marker::Tuple> {}

#[lang(typeop_return_type_of)]
struct return_type_of<T> {}

#[lang(typeop_arguments_of)]
struct arguments_of<T> {}


#[cfg(all(test, test_std))]
mod tests {
    #[test]
    fn unsigned_num_limits() {
        assert_eq!(u8::max_value() + 1, u8::min_value());
        assert_eq!(u16::max_value() + 1, u16::min_value());
        assert_eq!(u32::max_value() + 1, u32::min_value());
        assert_eq!(u64::max_value() + 1, u64::min_value());
        assert_eq!(usize::max_value() + 1, usize::min_value());
        assert_eq!(u128::max_value() + 1, u128::min_value());
    }

    #[test]
    fn signed_num_limits() {
        // Signed overflow is UB, so we round-trip via unsigned equivalent
        assert_eq!((i8::max_value() as u8 + 1) as i8, i8::min_value());
        assert_eq!((i16::max_value() as u16 + 1) as i16, i16::min_value());
        assert_eq!((i32::max_value() as u32 + 1) as i32, i32::min_value());
        assert_eq!((i64::max_value() as u64 + 1) as i64, i64::min_value());
        assert_eq!((isize::max_value() as usize + 1) as isize, isize::min_value());
        assert_eq!((i128::max_value() as u128 + 1) as i128, i128::min_value());
    }

    #[test]
    fn test_signed_of() {
        use rtti::type_id;
        
        assert_eq!(type_id::<signed_of<u8>>(), type_id::<i8>());
        assert_eq!(type_id::<signed_of<u16>>(), type_id::<i16>());
        assert_eq!(type_id::<signed_of<u32>>(), type_id::<i32>());
        assert_eq!(type_id::<signed_of<u64>>(), type_id::<i64>());
        assert_eq!(type_id::<signed_of<usize>>(), type_id::<isize>());
        assert_eq!(type_id::<signed_of<u128>>(), type_id::<i128>());
     
        assert_eq!(type_id::<signed_of<i8>>(), type_id::<i8>());
        assert_eq!(type_id::<signed_of<i16>>(), type_id::<i16>());
        assert_eq!(type_id::<signed_of<i32>>(), type_id::<i32>());
        assert_eq!(type_id::<signed_of<i64>>(), type_id::<i64>());
        assert_eq!(type_id::<signed_of<isize>>(), type_id::<isize>());
        assert_eq!(type_id::<signed_of<i128>>(), type_id::<i128>());
    }

    #[test]
    fn test_unsigned_of() {
        use rtti::type_id;
        
        assert_eq!(type_id::<unsigned_of<u8>>(), type_id::<u8>());
        assert_eq!(type_id::<unsigned_of<u16>>(), type_id::<u16>());
        assert_eq!(type_id::<unsigned_of<u32>>(), type_id::<u32>());
        assert_eq!(type_id::<unsigned_of<u64>>(), type_id::<u64>());
        assert_eq!(type_id::<unsigned_of<usize>>(), type_id::<usize>());
        assert_eq!(type_id::<unsigned_of<u128>>(), type_id::<u128>());

        assert_eq!(type_id::<unsigned_of<i8>>(), type_id::<u8>());
        assert_eq!(type_id::<unsigned_of<i16>>(), type_id::<u16>());
        assert_eq!(type_id::<unsigned_of<i32>>(), type_id::<u32>());
        assert_eq!(type_id::<unsigned_of<i64>>(), type_id::<u64>());
        assert_eq!(type_id::<unsigned_of<isize>>(), type_id::<usize>());
        assert_eq!(type_id::<unsigned_of<i128>>(), type_id::<u128>());
    }

    #[test]
    fn test_deref_of() {
        use rtti::type_id;
        
        assert_eq!(type_id::<deref_of<&u8>>(), type_id::<u8>());
        assert_eq!(type_id::<deref_of<&mut u8>>(), type_id::<u8>());

        assert_eq!(type_id::<deref_of<deref_of<&&u8>>>(), type_id::<u8>());
        assert_eq!(type_id::<deref_of<deref_of<&&mut u8>>>(), type_id::<u8>());
        assert_eq!(type_id::<deref_of<deref_of<&mut &mut u8>>>(), type_id::<u8>());
        assert_eq!(type_id::<deref_of<deref_of<&mut &u8>>>(), type_id::<u8>());
    }
}
