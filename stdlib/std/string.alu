use std::option::Option;

fn is_whitespace(c: u8) -> bool {
    c == 0x20 || c == 0x85 || c == 0xa0 || (c >= 0x09 && c <= 0x0D)
}

fn starts_with(self: &[u8], prefix: &[u8]) -> bool {
    if self.len < prefix.len {
        return false;
    }
    self[..prefix.len] == prefix
}

fn ends_with(self: &[u8], suffix: &[u8]) -> bool {
    if self.len < suffix.len {
        return false;
    }
    self[self.len - suffix.len..] == suffix
}

fn find(self: &[u8], needle: &[u8]) -> Option<usize> {
    if needle.len == 0 {
        return Option::some(0usize);
    }

    if self.len == 0 {
        return Option::none();
    }

    let ret = libc::memmem(
        self.ptr as &void,
        self.len,
        needle.ptr as &void,
        needle.len
    )

    if ret == null {
        Option::none()
    } else {
        Option::some(((ret as &u8) - self.ptr) as usize)
    }
}

fn contains(self: &[u8], needle: &[u8]) -> bool {
    self.find(needle).is_some
}

fn trim_start(self: &[u8]) -> &[u8] {
    let i = 0usize;
    while i < self.len && self[i].is_whitespace() {
        i += 1;
    }
    self[i..]
}

fn trim_end(self: &[u8]) -> &[u8] {
    let i = self.len;
    while i > 0 && self[i - 1].is_whitespace() {
        i -= 1;
    }
    self[..i]
}

fn trim(self: &[u8]) -> &[u8] {
    self.trim_start().trim_end()
}

struct SplitIterator {
    data: &[u8],
    sep: &[u8],
    done: bool
}

impl SplitIterator {
    fn new(data: &[u8], sep: &[u8]) -> SplitIterator {
        SplitIterator {
            data: data,
            sep: sep,
            done: false
        }
    }

    fn next(self: &mut SplitIterator) -> Option<&[u8]> {
        if self.done {
            return Option::none();
        }

        let pos = self.data.find(self.sep);
        if !pos.is_some {
            self.done = true;
            return Option::some(self.data);
        }

        let pos = pos.unwrap();
        let ret = Option::some(self.data[..pos]);
        self.data = self.data[pos + self.sep.len..];

        ret
    }

    fn iter(self: &mut SplitIterator) -> SplitIterator {
        *self
    }
}

fn split(self: &[u8], sep: &[u8]) -> SplitIterator {
    SplitIterator::new(self, sep)
}

fn join<T: iter::Iterator<T, &[u8]>>(self: &[u8], iter: &mut T) -> collections::Vector<u8> {
    let ret: collections::Vector<u8> = collections::Vector::new();
    let first = true;

    loop {
        let item = iter.next();
        if item.is_some {
            if first {
                first = false;
            } else {
                ret.extend_from_slice(self);
            }
            ret.extend_from_slice(item.inner);
        } else {
            break;
        }
    }

    ret
}

fn parse_integer<T: proto::Integer>(s: &[u8]) -> Option<T> {
    use builtins::unsigned_of;

    if s.len == 0 {
        return Option::none();
    }

    let negative = if s[0] == '-' {
        when T: proto::Signed {
            s = s[1..];
            true
        } else {
            return Option::none();
        }
    } else {
        false
    };

    let result: unsigned_of<T> = 0;
    for ch in s {
        if ch >= '0' && ch <= '9' {
            let a = result * 10;
            if a / 10 != result {
                return Option::none();
            } 
            let b = a + ((ch - '0') as unsigned_of<T>);
            if b < a {
                return Option::none();
            }
            result = b;
        } else {
            return Option::none();
        }
    }

    when T: proto::Signed {
        // We only need to check for unsigned-to-signed conversion overflow, other
        // cases have already been handled.
        if negative {
            if result > (T::max_value() as unsigned_of<T>) + 1 {
                Option::none()
            } else {
                Option::some(-(result as T))
            }
        } else {
            if result > T::max_value() as unsigned_of<T> {
                Option::none()
            } else {
                Option::some(result as T)
            }
        }
    } else {
        Option::some(result)
    }
}


#[cfg(test)]
mod tests {
    use std::{assert, assert_eq, assert_ne};

    #[test]
    fn test_trim1() {
        parse_integer::<u8>("123");
    }

    #[test]
    fn starts_with_positive() {
        assert!("".starts_with(""))
        assert!("hello world".starts_with("hello world"))
        assert!("hello world".starts_with("hello"))
        assert!("hello world".starts_with(""))
    }

    #[test]
    fn starts_with_negative() {
        assert!(!"".starts_with("world"))
        assert!(!"hello world".starts_with("world"))
        assert!(!"hello world".starts_with("hello world hello world"))
    }

    #[test]
    fn find_positive() {
        assert_eq!("needle".find("needle"), Option::some(0usize));
        assert_eq!("needle".find("dle"), Option::some(3usize));
        assert_eq!("needle".find(""), Option::some(0usize));
        assert_eq!("".find(""), Option::some(0usize));
    }

    #[test]
    fn find_negative() {
        assert_eq!("needle".find("weedle"), Option::none());
        assert_eq!("needle".find("superlongstring"), Option::none());
    }

    #[test]
    fn test_parse_integer() {
        assert_eq!(parse_integer::<usize>("0"), Option::some(0usize));
        assert_eq!(parse_integer::<isize>("0"), Option::some(0isize));
        
        assert_eq!(parse_integer::<usize>("-0"), Option::none());
        assert_eq!(parse_integer::<isize>("-0"), Option::some(0isize));

        assert_eq!(parse_integer::<usize>("24601"), Option::some(24601usize));
        assert_eq!(parse_integer::<isize>("-24601"), Option::some(-24601isize));

        assert_eq!(parse_integer::<usize>(""), Option::none());
        assert_eq!(parse_integer::<usize>("abcdes"), Option::none());
        assert_eq!(parse_integer::<usize>("-243"), Option::none());  

        // Unsigned overflow
        assert_eq!(parse_integer::<u8>("256"), Option::none());
        assert_eq!(parse_integer::<u8>("255"), Option::some(255u8));

        assert_eq!(parse_integer::<u16>("65535"), Option::some(0xffffu16));
        assert_eq!(parse_integer::<u16>("65536"), Option::none());

        // Signed overflow
        assert_eq!(parse_integer::<i8>("127"), Option::some(127i8));  
        assert_eq!(parse_integer::<i8>("128"), Option::none());  
        assert_eq!(parse_integer::<i8>("-128"), Option::some(-128i8));  
        assert_eq!(parse_integer::<i8>("-129"), Option::none());  
        assert_eq!(
            parse_integer::<i128>("170141183460469231731687303715884105727"),
            Option::some(170141183460469231731687303715884105727i128)
        );
        assert_eq!(
            parse_integer::<i128>("170141183460469231731687303715884105728"),
            Option::none()
        );
    }

    #[test]
    fn test_trim_start() {
        assert_eq!("".trim_start(), "")
        assert_eq!("hello world".trim_start(), "hello world")
        assert_eq!("  hello world".trim_start(), "hello world")
        assert_eq!("\t\t\thello world".trim_start(), "hello world")
        assert_eq!("\n\n\nhello world".trim_start(), "hello world")
        assert_eq!("\r\r\rhello world".trim_start(), "hello world")
    }

    #[test]
    fn test_trim_end() {
        assert_eq!("".trim_end(), "")
        assert_eq!("hello world".trim_end(), "hello world")
        assert_eq!("hello world  ".trim_end(), "hello world")
        assert_eq!("hello world\t\t\t".trim_end(), "hello world")
        assert_eq!("hello world\n\n\n".trim_end(), "hello world")
        assert_eq!("hello world\r\r\r".trim_end(), "hello world")
    }

    #[test]
    fn test_trim() {
        assert_eq!("".trim(), "")
        assert_eq!("hello world".trim(), "hello world")
        assert_eq!("  hello world   ".trim(), "hello world")
        assert_eq!("\t\t\thello world \n\t ".trim(), "hello world")
        assert_eq!("\n\n\nhello world".trim(), "hello world")
        assert_eq!("\r\r\rhello world".trim(), "hello world")
    }

    #[test]
    fn test_split() {
        let iter = "".split(".");
        assert_eq!(iter.next(), Option::some(""));
        assert_eq!(iter.next(), Option::none());

        let iter = "192.168.0.1".split(".");
        assert_eq!(iter.next(), Option::some("192"));
        assert_eq!(iter.next(), Option::some("168"));
        assert_eq!(iter.next(), Option::some("0"));
        assert_eq!(iter.next(), Option::some("1"));
        assert_eq!(iter.next(), Option::none());

        let iter = "192.168.0.1".split("%");
        assert_eq!(iter.next(), Option::some("192.168.0.1"));
        assert_eq!(iter.next(), Option::none());

        let iter = "192.168.0.1".split("");
        assert_eq!(iter.next(), Option::some(""));
        assert_eq!(iter.next(), Option::some(""));
        assert_eq!(iter.next(), Option::some(""));
        // ...

        let iter = "  ab c ".split(" ");
        assert_eq!(iter.next(), Option::some(""));
        assert_eq!(iter.next(), Option::some(""));
        assert_eq!(iter.next(), Option::some("ab"));
        assert_eq!(iter.next(), Option::some("c"));
        assert_eq!(iter.next(), Option::some(""));
        assert_eq!(iter.next(), Option::none());
        // ...
    }

    #[test]
    fn test_join() {
        let vec = ".".join(&["192", "168", "0", "1"].iter());
        defer vec.free();
        assert_eq!(vec.as_slice(), "192.168.0.1");

        let vec = "".join(&["192", "168", "0", "1"].iter());
        defer vec.free();
        assert_eq!(vec.as_slice(), "19216801");

        let vec = "%".join(&["192.168.0.1"].iter());
        defer vec.free();
        assert_eq!(vec.as_slice(), "192.168.0.1");
    }
}
