use fmt::{BufferedFormatter, write, writeln};

// We use a single static buffer for convenience stdio formatting macros.
// Once we have multi-threading, stdio formatting will have to be synchronized.
// Having a static buffer is also a concern if the macros recurse, as the buffer
// will be overwritten. Currently this only happens during a panic, which should
// be fine.
static FMT_BUF: [u8; 128];

macro print($fmt_str, $arg...) {
    let fmt = FileFormatter::new(&stdout);
    let fmt = BufferedFormatter::new(&FMT_BUF, &fmt);
    write!(&fmt, $fmt_str, $arg...);
    fmt.flush();
}
macro println($fmt_str, $arg...) {
    let fmt = FileFormatter::new(&stdout);
    let fmt = BufferedFormatter::new(&FMT_BUF, &fmt);
    writeln!(&fmt, $fmt_str, $arg...);
    fmt.flush();
}
macro eprint($fmt_str, $arg...) {
    let fmt = FileFormatter::new(&stderr);
    let fmt = BufferedFormatter::new(&FMT_BUF, &fmt);
    write!(&fmt, $fmt_str, $arg...);
    fmt.flush();
}
macro eprintln($fmt_str, $arg...) {
    let fmt = FileFormatter::new(&stderr);
    let fmt = BufferedFormatter::new(&FMT_BUF, &fmt);
    writeln!(&fmt, $fmt_str, $arg...);
    fmt.flush();
}

struct FileFormatter {
    file: &mut File,
}

impl FileFormatter {
    fn new(file: &mut File) -> FileFormatter {
        FileFormatter {
            file: file
        }
    }

    fn write_str(self: &mut FileFormatter, buf: &[u8]) {
        self.file.write_all(buf);
    }

    mixin fmt::Formatter<FileFormatter>;
}


enum ErrorKind {
    UnexpectedEof,
    Os
}

struct Error {
    kind: ErrorKind,
    errno: libc::c_int,
}

impl Error {
    use fmt::Formatter;

    fn from_errno() -> Error {
        Error {
            kind: ErrorKind::Os,
            errno: *libc::__errno(),
        }
    }

    fn eof() -> Error {
        Error {
            kind: ErrorKind::UnexpectedEof,
            errno: 0,
        }
    }

    fn fmt<F: Formatter<F>>(self: &Error, f: &mut F) {
        switch self.kind {
            ErrorKind::UnexpectedEof => f.write_str("unexpected end of file"),
            ErrorKind::Os => {
                let buf: [u8; 128];
                let buf = buf.as_slice_mut();

                if libc::strerror_r(self.errno, buf.ptr as &mut libc::c_char, 128) < 0 {
                    panic!("strerror_r failed");
                }

                let len = 0usize;
                while len < 128 && buf[len] != 0 {
                    len += 1;
                }

                f.write_str("os error: ");
                f.write_str(buf[0..len]);
            }
        }

    }
}

struct OpenOptions {
    _read: bool,
    _write: bool,
    _append: bool,
    _truncate: bool,
    _create: bool,
    _create_new: bool,
    _custom_flags: i32,
    _mode: libc::mode_t,
}

impl OpenOptions {
    fn new() -> OpenOptions {
        OpenOptions {
            _read: false,
            _write: false,
            _append: false,
            _truncate: false,
            _create: false,
            _create_new: false,
            _custom_flags: 0,
            _mode: 0o666,
        }
    }

    fn read(self: &mut OpenOptions, read: bool) -> &mut OpenOptions {
        self._read = read;
        self
    }
    fn write(self: &mut OpenOptions, write: bool) -> &mut OpenOptions {
        self._write = write;
        self
    }
    fn append(self: &mut OpenOptions, append: bool) -> &mut OpenOptions {
        self._append = append;
        self
    }
    fn truncate(self: &mut OpenOptions, truncate: bool) -> &mut OpenOptions {
        self._truncate = truncate;
        self
    }
    fn create(self: &mut OpenOptions, create: bool) -> &mut OpenOptions {
        self._create = create;
        self
    }
    fn create_new(self: &mut OpenOptions, create_new: bool) -> &mut OpenOptions {
        self._create_new = create_new;
        self
    }
    fn custom_flags(self: &mut OpenOptions, flags: i32) -> &mut OpenOptions {
        self._custom_flags = flags;
        self
    }
    fn mode(self: &mut OpenOptions, mode: u32) -> &mut OpenOptions {
        self._mode = mode as libc::mode_t;
        self
    }

    fn get_access_mode(self: &OpenOptions) -> libc::c_int {
        switch (self._read, self._write, self._append) {
            (true, false, false) => libc::O_RDONLY,
            (false, true, false) => libc::O_WRONLY,
            (true, true, false) => libc::O_RDWR,
            (false, true, true), (false, false, true)  => libc::O_WRONLY | libc::O_APPEND,
            (true, true, true), (true, false, true) => libc::O_RDWR | libc::O_APPEND,
            _ => -1
        }
    }

    fn get_creation_mode(self: &OpenOptions) -> libc::c_int {
        switch (self._write, self._append) {
            (true, false) => {}
            (false, false) => {
                if self._truncate || self._create || self._create_new {
                    return -1;
                }
            }
            (true, true), (false, true) => {
                if self._truncate && !self._create_new {
                    return -1;
                }
            }
        }

        switch (self._create, self._truncate, self._create_new) {
            (false, false, false) => 0,
            (true, false, false) => libc::O_CREAT,
            (false, true, false) => libc::O_TRUNC,
            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,
            _ => libc::O_CREAT | libc::O_EXCL,
        }
    }
}

macro error_check($ret) {
    let ret = $ret;
    if ret == -1 {
        return result::Result::err(Error::from_errno());
    }
    ret
}

struct File {
    fd: libc::c_int,
}

impl File {
    use result::{Result, try};
    use ffi::CString;

    /// Opens file in read-only mode.
    fn open(path: &[u8]) -> Result<File, Error> {
        open_with(path, OpenOptions::new().read(true))
    }

    /// Creates a new file for writing (truncating it if it already exists).
    fn create(path: &[u8]) -> Result<File, Error> {
        open_with(path, OpenOptions::new().write(true).create(true).truncate(true))
    }

    /// Opens file with custom options.
    fn open_with(path: &[u8], opts: &OpenOptions) -> Result<File, Error> {
        let path = CString::new(path);
        defer path.free();

        let flags = libc::O_CLOEXEC
            | opts.get_access_mode()
            | opts.get_creation_mode()
            | (opts._custom_flags as libc::c_int & ~libc::O_ACCMODE);

        let fd = error_check!(libc::open(
            path.ptr,
            flags,
            opts._mode as libc::mode_t
        ));

        Result::ok(File { fd: fd })
    }

    fn read_to_string(path: &[u8]) -> Result<collections::Vector<u8>, Error> {
        use std::io::copy_to;

        let string = collections::Vector::new::<u8>();
        defer string.free();

        let file = try!(File::open(path));
        defer file.close();

        let ret = try!(file.read_to_end(&string));

        Result::ok(string.move())
    }

    fn from_fd(fd: libc::c_int) -> File {
        File { fd: fd }
    }

    fn read(self: &mut File, buf: &mut [u8]) -> Result<usize, Error> {
        let ret = error_check!(libc::read(self.fd, buf.ptr as &mut void, buf.len));
        Result::ok(ret as usize)
    }

    fn write(self: &mut File, buf: &[u8]) -> Result<usize, Error> {
        let ret = error_check!(libc::write(self.fd, buf.ptr as &void, buf.len));
        Result::ok(ret as usize)
    }

    fn flush(self: &mut File) -> Result<(), Error> {
        let ret = libc::fsync(self.fd);
        // Some files (notably stdout) do not support fsync,
        // this is not an error.
        if ret == -1 && *libc::__errno() != libc::EINVAL {
            return Result::err(Error::from_errno());
        }
        Result::ok(())
    }

    fn close(self: &mut File) -> Result<(), Error> {
        error_check!(libc::close(self.fd));
        result::Result::ok(())
    }

    mixin Readable<File>;
    mixin Writable<File>;
}

fn anonymous_pipe() -> result::Result<(File, File), Error> {
    let fds: [libc::c_int; 2];

    #[cfg(target_os = "linux")]
    error_check!(libc::pipe2(&fds[0], libc::O_CLOEXEC));
    #[cfg(not(target_os = "linux"))]
    error_check!(libc::pipe(&fds[0]));

    // TODO: add fcntl to O_CLOEXEC

    result::Result::ok((File::from_fd(fds[0]), File::from_fd(fds[1])))
}

static stdout : File = File::from_fd(libc::STDOUT_FILENO);
static stderr : File = File::from_fd(libc::STDERR_FILENO);
static stdin  : File = File::from_fd(libc::STDIN_FILENO);
