use fmt::{BufferedFormatter, write, writeln};

// We use a single small static buffer for convenience stdio formatting macros.
// This buffer has limited purpose (if you need larger buffer, use io::stdX directly),
// but since many formats write individual characters, doing a syscall for every one
// would be a performance killer.
// Once we have multi-threading, stdio formatting will have to be synchronized.
// Having a static buffer is also a concern if the macros recurse, as the buffer
// will be overwritten. Currently this only happens during a panic, which should
// be fine.
static FMT_BUF: [u8; 128];

macro print($fmt_str, $arg...) {
    let fmt = BufferedWriter::from_slice(&stdout, &FMT_BUF);
    write!(&fmt, $fmt_str, $arg...).unwrap();
    fmt.flush().unwrap();
}
macro println($fmt_str, $arg...) {
    let fmt = BufferedWriter::from_slice(&stdout, &FMT_BUF);
    writeln!(&fmt, $fmt_str, $arg...).unwrap();
    fmt.flush().unwrap();
}
macro eprint($fmt_str, $arg...) {
    let fmt = BufferedWriter::from_slice(&stderr, &FMT_BUF);
    write!(&fmt, $fmt_str, $arg...).unwrap();
    fmt.flush().unwrap();
}
macro eprintln($fmt_str, $arg...) {
    let fmt = BufferedWriter::from_slice(&stderr, &FMT_BUF);
    writeln!(&fmt, $fmt_str, $arg...).unwrap();
    fmt.flush().unwrap();
}

enum ErrorKind {
    UnexpectedEof,
    Os,
    GetAddrInfo,
    UserDefined
}

union ErrorInner {
    errno: libc::c_int,
    gai_err: libc::c_int,
    message: &[u8]
}

struct Error {
    kind: ErrorKind,
    inner: ErrorInner,
}

impl Error {
    use fmt::Formatter;

    fn from_errno() -> Error {
        Error {
            kind: ErrorKind::Os,
            inner: ErrorInner { errno: *libc::__errno() },
        }
    }

    fn from_gai(gai_err: libc::c_int) -> Error {
        Error {
            kind: ErrorKind::GetAddrInfo,
            inner: ErrorInner { gai_err: gai_err },
        }
    }

    fn custom(message: &[u8]) -> Error {
        Error {
            kind: ErrorKind::UserDefined,
            inner: ErrorInner { message: message },
        }
    }

    fn eof() -> Error {
        Error {
            kind: ErrorKind::UnexpectedEof
        }
    }

    fn as_errno(self: &Error) -> Option<libc::c_int> {
        if self.kind == ErrorKind::Os {
            Option::some(self.inner.errno)
        } else {
            Option::none()
        }
    }

    fn fmt<F: Formatter<F>>(self: &Error, f: &mut F) -> Result<(), fmt::Error> {
        switch self.kind {
            ErrorKind::UnexpectedEof => f.write_str("unexpected end of file"),
            ErrorKind::GetAddrInfo => {
                try!(f.write_str("failed to lookup address information: "));
                f.write_str(ffi::CString::as_slice(libc::gai_strerror(self.inner.gai_err)))
            }
            ErrorKind::UserDefined => {
                f.write_str(self.inner.message)
            }
            ErrorKind::Os => {
                let buf: [u8; 128];
                let buf = buf.as_slice_mut();

                if libc::strerror_r(self.inner.errno, buf.ptr as &mut libc::c_char, 128) < 0 {
                    panic!("strerror_r failed");
                }

                let len = 0usize;
                while len < 128 && buf[len] != 0 {
                    len += 1;
                }

                try!(f.write_str("os error: "));
                try!(f.write_str(buf[0..len]));

                Result::ok(())
            }
            _ => unreachable!()
        }

    }
}

struct OpenOptions {
    _read: bool,
    _write: bool,
    _append: bool,
    _truncate: bool,
    _create: bool,
    _create_new: bool,
    _custom_flags: i32,
    _mode: libc::mode_t,
}

impl OpenOptions {
    fn new() -> OpenOptions {
        OpenOptions {
            _read: false,
            _write: false,
            _append: false,
            _truncate: false,
            _create: false,
            _create_new: false,
            _custom_flags: 0,
            _mode: 0o666,
        }
    }

    fn read(self: &mut OpenOptions, read: bool) -> &mut OpenOptions {
        self._read = read;
        self
    }
    fn write(self: &mut OpenOptions, write: bool) -> &mut OpenOptions {
        self._write = write;
        self
    }
    fn append(self: &mut OpenOptions, append: bool) -> &mut OpenOptions {
        self._append = append;
        self
    }
    fn truncate(self: &mut OpenOptions, truncate: bool) -> &mut OpenOptions {
        self._truncate = truncate;
        self
    }
    fn create(self: &mut OpenOptions, create: bool) -> &mut OpenOptions {
        self._create = create;
        self
    }
    fn create_new(self: &mut OpenOptions, create_new: bool) -> &mut OpenOptions {
        self._create_new = create_new;
        self
    }
    fn custom_flags(self: &mut OpenOptions, flags: i32) -> &mut OpenOptions {
        self._custom_flags = flags;
        self
    }
    fn mode(self: &mut OpenOptions, mode: u32) -> &mut OpenOptions {
        self._mode = mode as libc::mode_t;
        self
    }

    fn get_access_mode(self: &OpenOptions) -> libc::c_int {
        switch (self._read, self._write, self._append) {
            (true, false, false) => libc::O_RDONLY,
            (false, true, false) => libc::O_WRONLY,
            (true, true, false) => libc::O_RDWR,
            (false, true, true), (false, false, true)  => libc::O_WRONLY | libc::O_APPEND,
            (true, true, true), (true, false, true) => libc::O_RDWR | libc::O_APPEND,
            _ => -1
        }
    }

    fn get_creation_mode(self: &OpenOptions) -> libc::c_int {
        switch (self._write, self._append) {
            (true, false) => {}
            (false, false) => {
                if self._truncate || self._create || self._create_new {
                    return -1;
                }
            }
            (true, true), (false, true) => {
                if self._truncate && !self._create_new {
                    return -1;
                }
            }
        }

        switch (self._create, self._truncate, self._create_new) {
            (false, false, false) => 0,
            (true, false, false) => libc::O_CREAT,
            (false, true, false) => libc::O_TRUNC,
            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,
            _ => libc::O_CREAT | libc::O_EXCL,
        }
    }
}

macro errno_try($ret) {
    let ret = $ret;
    if ret == -1 {
        return result::Result::err(Error::from_errno());
    }
    ret
}

protocol FdReadWrite<Self: AsFileDescriptor<Self>> {
    fn read(self: &mut Self, buf: &mut [u8]) -> Result<usize, Error> {
        let ret = errno_try!(libc::read(self.as_fd().value, buf.ptr as &mut void, buf.len));
        Result::ok(ret as usize)
    }

    fn write(self: &mut Self, buf: &[u8]) -> Result<usize, Error> {
        let ret = errno_try!(libc::write(self.as_fd().value, buf.ptr as &void, buf.len));
        Result::ok(ret as usize)
    }
}

struct FileDescriptor {
    value: libc::c_int
}

impl FileDescriptor {
    fn new(value: libc::c_int) -> FileDescriptor {
        FileDescriptor { value: value }
    }

    fn close(self: &mut FileDescriptor) -> Result<(), Error> {
        if self.value != -1 {
            errno_try!(libc::close(self.value));
        }
        result::Result::ok(())
    }

    #[cfg(target_os = "linux")]
    fn set_nonblocking(self: &mut FileDescriptor, nonblocking: bool) -> Result<(), Error> {
        let nonblocking =  if nonblocking { 1 as libc::c_int } else { 0 as libc::c_int };
        errno_try!(libc::ioctl(self.value, libc::FIONBIO, &nonblocking));

        result::Result::ok(())
    }

    #[cfg(not(target_os = "linux"))]
    fn set_nonblocking(self: &mut FileDescriptor, nonblocking: bool) -> Result<(), Error> {
        let previous = errno_try!(libc::fcntl(self.value, libc::F_GETFL));
        let new = if nonblocking {
            previous | libc::O_NONBLOCK
        } else {
            previous & ~libc::O_NONBLOCK
        };

        if new != previous {
            errno_try!(libc::fcntl(self.value, libc::F_SETFL, new));
        }

        result::Result::ok(())
    }

    #[cfg(not(target_os = "linux"))]
    fn set_cloexec(self: &mut FileDescriptor) -> Result<(), Error> {
        errno_try!(libc::ioctl(self.value, libc::FIOCLEX));

        result::Result::ok(())
    }

    #[cfg(target_os = "linux")]
    fn set_cloexec(self: &mut FileDescriptor) -> Result<(), Error> {
        let previous = errno_try!(libc::fcntl(self.value, libc::F_GETFD));
        let new = previous | libc::FD_CLOEXEC;

        if new != previous {
            errno_try!(libc::fcntl(self.value, libc::F_SETFD, new));
        }

        result::Result::ok(())
    }

    fn move(self: &mut FileDescriptor) -> FileDescriptor {
        let ret = *self;
        self.value = -1;
        ret
    }
}

struct StdioStream {
    fd: FileDescriptor
}

impl StdioStream {
    fn from_fd(fd: FileDescriptor) -> StdioStream {
        StdioStream { fd: fd }
    }

    fn as_fd(self: &StdioStream) -> FileDescriptor {
        self.fd
    }

    fn close(self: &mut StdioStream) -> Result<(), Error> {
        self.fd.close()
    }

    fn move(self: &mut StdioStream) -> StdioStream {
        StdioStream { fd: self.fd.move() }
    }    

    mixin FdReadWrite<StdioStream>;
    mixin Readable<StdioStream>;
    mixin Writable<StdioStream>;
}

struct File {
    fd: FileDescriptor
}

impl File {
    use ffi::CString;

    /// Opens file in read-only mode.
    fn open(path: &[u8]) -> Result<File, Error> {
        open_with(path, OpenOptions::new().read(true))
    }

    /// Creates a new file for writing (truncating it if it already exists).
    fn create(path: &[u8]) -> Result<File, Error> {
        open_with(path, OpenOptions::new().write(true).create(true).truncate(true))
    }

    /// Opens file with custom options.
    fn open_with(path: &[u8], opts: &OpenOptions) -> Result<File, Error> {
        let path = CString::new(path);
        defer path.free();

        let flags = libc::O_CLOEXEC
            | opts.get_access_mode()
            | opts.get_creation_mode()
            | (opts._custom_flags as libc::c_int & ~libc::O_ACCMODE);

        let fd = errno_try!(libc::open(
            path.ptr,
            flags,
            opts._mode as libc::mode_t
        ));

        Result::ok(File { fd: FileDescriptor::new(fd) })
    }

    fn from_fd(fd: FileDescriptor) -> File {
        File { fd: fd }
    }

    fn as_fd(self: &File) -> FileDescriptor {
        self.fd
    }

    fn read_to_string(path: &[u8]) -> Result<collections::Vector<u8>, Error> {
        use std::io::copy;

        let string = collections::Vector::new::<u8>();
        defer string.free();

        let file = try!(File::open(path));
        defer file.close();

        let ret = try!(file.read_to_end(&string));

        Result::ok(string.move())
    }

    fn seek(self: &mut File, whence: SeekFrom, offset: i64) -> Result<i64, Error> {
        #[cfg(not(target_os = "macos"))]
        let ret = errno_try!(libc::lseek64(self.fd.value, offset, whence as libc::c_int));
        #[cfg(target_os = "macos")]
        let ret = errno_try!(libc::lseek(self.fd.value, offset, whence as libc::c_int));

        Result::ok(ret as i64)
    }

    fn flush(self: &mut File) -> Result<(), Error> {
        let ret = errno_try!(libc::fsync(self.fd.value));
        Result::ok(())
    }

    fn close(self: &mut File) -> Result<(), Error> {
        self.fd.close()
    }

    fn move(self: &mut File) -> File {
        File { fd: self.fd.move() }
    }

    mixin FdReadWrite<File>;
    mixin Readable<File>;
    mixin Writable<File>;
    mixin Seekable<File>;
}

struct Pipe {
    fd: FileDescriptor
}

impl Pipe {
    fn anonymous() -> result::Result<(Pipe, Pipe), Error> {
        let fds: [libc::c_int; 2];
    
        #[cfg(target_os = "linux")]
        errno_try!(libc::pipe2(&fds[0], libc::O_CLOEXEC));
        
        #[cfg(not(target_os = "linux"))]
        errno_try!(libc::pipe(&fds[0]));

        let rx = FileDescriptor::new(fds[0]);
        let tx = FileDescriptor::new(fds[1]);

        #[cfg(not(target_os = "linux"))]
        {
            try!(rx.set_cloexec());
            try!(tx.set_cloexec());
        }

        result::Result::ok((Pipe::from_fd(rx), Pipe::from_fd(tx)))
    }

    fn from_fd(fd: FileDescriptor) -> Pipe {
        Pipe { fd: fd }
    }

    fn as_fd(self: &Pipe) -> FileDescriptor {
        self.fd
    }

    fn close(self: &mut Pipe) -> Result<(), Error> {
        self.fd.close()
    }

    fn move(self: &mut Pipe) -> Pipe {
        Pipe { fd: self.fd.move() }
    }

    mixin FdReadWrite<Pipe>;
    mixin Readable<Pipe>;
    mixin Writable<Pipe>;
}

static stdout : StdioStream = StdioStream::from_fd(FileDescriptor::new(libc::STDOUT_FILENO));
static stderr : StdioStream = StdioStream::from_fd(FileDescriptor::new(libc::STDERR_FILENO));
static stdin  : StdioStream = StdioStream::from_fd(FileDescriptor::new(libc::STDIN_FILENO));

#[cfg(test)]
mod test {
    use collections::Vector;
    static BUF: [u8; 1024];
    static BUF1: [u8; 1024];

    fn mktemp() -> Vector<u8> {
        use fmt::{hex, pad, format};
        format!("/tmp/{}.dat", random::DEFAULT_RNG.next_u64().hex().zero_pad(16)).unwrap()
    }

    #[test]
    fn test_open() {
        let filename = mktemp();
        let buf = BUF.as_slice_mut();
        defer filename.free();

        let file = File::create(filename.as_slice()).unwrap();

        file.write_all("Hello, world!").unwrap();
        file.close().unwrap();

        let file = File::open(filename.as_slice()).unwrap();
        defer file.close();

        let read = file.read(buf).unwrap();
        assert_eq!(buf[..read] as &[u8], "Hello, world!");
        
        file.seek(SeekFrom::Beginning, 7).unwrap();

        let read = file.read(buf).unwrap();
        assert_eq!(buf[..read] as &[u8], "world!");

        file.close().unwrap();
    }
}
