use fmt::{BufferedFormatter, write, writeln};

// We use a single static buffer for convenience stdio formatting macros.
// Once we have multi-threading, stdio formatting will have to be synchronized.
// Having a static buffer is also a concern if the macros recurse, as the buffer
// will be overwritten. Currently this only happens during a panic, which should
// be fine.
static FMT_BUF: [u8; 128];

macro print(fmt_str, arg...) { 
    let fmt = FileFormatter::new(&stdout);
    let fmt = BufferedFormatter::new(&FMT_BUF, &fmt);
    write!(&fmt, fmt_str, arg...);
    fmt.flush();
}
macro println(fmt_str, arg...) { 
    let fmt = FileFormatter::new(&stdout);
    let fmt = BufferedFormatter::new(&FMT_BUF, &fmt);
    writeln!(&fmt, fmt_str, arg...);
    fmt.flush();
}
macro eprint(fmt_str, arg...) { 
    let fmt = FileFormatter::new(&stderr);
    let fmt = BufferedFormatter::new(&FMT_BUF, &fmt);
    write!(&fmt, fmt_str, arg...);
    fmt.flush();
}
macro eprintln(fmt_str, arg...) { 
    let fmt = FileFormatter::new(&stderr);
    let fmt = BufferedFormatter::new(&FMT_BUF, &fmt);
    writeln!(&fmt, fmt_str, arg...);
    fmt.flush();
}

struct FileFormatter {
    file: &mut File,
}

impl FileFormatter {
    fn new(file: &mut File) -> FileFormatter {
        FileFormatter {
            file: file
        }
    }
    
    fn write_str(self: &mut FileFormatter, buf: &[u8]) {
        self.file.write(buf);
    }

    mixin fmt::Formatter<FileFormatter>;
}


enum ErrorKind {
    UnexpectedEof,
    Os
} 

struct Error {
    kind: ErrorKind,
    errno: libc::c_int,
}

impl Error {
    use fmt::Formatter;

    fn from_errno() -> Error {
        Error {
            kind: ErrorKind::Os,
            errno: *libc::__errno_location(),
        }
    }

    fn eof() -> Error {
        Error {
            kind: ErrorKind::UnexpectedEof,
            errno: 0,
        }
    }

    fn fmt<F: Formatter<F>>(self: &Error, f: &mut F) {
        switch self.kind {
            ErrorKind::UnexpectedEof => f.write_str("unexpected end of file"),
            ErrorKind::Os => {
                let buf: [u8; 128];
                let buf = buf.as_slice_mut();
                
                if libc::strerror_r(self.errno, buf.ptr as &mut libc::c_char, 128) < 0 {
                    panic!("strerror_r failed");
                }
                
                let len = 0usize;
                while len < 128 && buf[len] != 0 {
                    len += 1;
                }

                f.write_str("os error: ");
                f.write_str(buf[0..len]);
            }
        }
        
    }
}

struct OpenOptions {
    _read: bool,
    _write: bool,
    _append: bool,
    _truncate: bool,
    _create: bool,
    _create_new: bool,
    _custom_flags: i32,
    _mode: libc::mode_t,
}

impl OpenOptions {
    fn new() -> OpenOptions {
        OpenOptions {
            _read: false,
            _write: false,
            _append: false,
            _truncate: false,
            _create: false,
            _create_new: false,
            _custom_flags: 0,
            _mode: 0o666,
        }
    }

    fn read(self: &mut OpenOptions, read: bool) -> &mut OpenOptions {
        self._read = read;
        self
    }
    fn write(self: &mut OpenOptions, write: bool) -> &mut OpenOptions {
        self._write = write;
        self
    }
    fn append(self: &mut OpenOptions, append: bool) -> &mut OpenOptions {
        self._append = append;
        self
    }
    fn truncate(self: &mut OpenOptions, truncate: bool) -> &mut OpenOptions {
        self._truncate = truncate;
        self
    }
    fn create(self: &mut OpenOptions, create: bool) -> &mut OpenOptions {
        self._create = create;
        self
    }
    fn create_new(self: &mut OpenOptions, create_new: bool) -> &mut OpenOptions {
        self._create_new = create_new;
        self
    }
    fn custom_flags(self: &mut OpenOptions, flags: i32) -> &mut OpenOptions {
        self._custom_flags = flags;
        self
    }
    fn mode(self: &mut OpenOptions, mode: u32) -> &mut OpenOptions {
        self._mode = mode as libc::mode_t;
        self
    }

    fn get_access_mode(self: &OpenOptions) -> libc::c_int {
        switch (self._read, self._write, self._append) {
            (true, false, false) => libc::O_RDONLY,
            (false, true, false) => libc::O_WRONLY,
            (true, true, false) => libc::O_RDWR,
            (false, true, true), (false, false, true)  => libc::O_WRONLY | libc::O_APPEND,
            (true, true, true), (true, false, true) => libc::O_RDWR | libc::O_APPEND,
            _ => -1
        }
    }

    fn get_creation_mode(self: &OpenOptions) -> libc::c_int {
        switch (self._write, self._append) {
            (true, false) => {}
            (false, false) => {
                if self._truncate || self._create || self._create_new {
                    return -1;
                }
            }
            (true, true), (false, true) => {
                if self._truncate && !self._create_new {
                    return -1;
                }
            }
        }

        switch (self._create, self._truncate, self._create_new) {
            (false, false, false) => 0,
            (true, false, false) => libc::O_CREAT,
            (false, true, false) => libc::O_TRUNC,
            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,
            _ => libc::O_CREAT | libc::O_EXCL,
        }
    }
}

macro error_check(ret) {
    let ret = ret;
    if ret == -1 {
        return result::Result::err(Error::from_errno());
    }
    ret
}

struct File {
    fd: libc::c_int,
}

impl File {
    use result::Result;
    use ffi::CString;

    /// Opens file in read-only mode.
    fn open(path: &[u8]) -> Result<File, Error> {
        open_with(path, OpenOptions::new().read(true))
    }

    /// Creates a new file for writing (truncating it if it already exists).
    fn create(path: &[u8]) -> Result<File, Error> {
        open_with(path, OpenOptions::new().write(true).create(true).truncate(true))
    }

    /// Opens file with custom options.
    fn open_with(path: &[u8], opts: &OpenOptions) -> Result<File, Error> {
        let path = CString::new(path);
        defer path.free();
        
        let flags = libc::O_CLOEXEC
            | opts.get_access_mode()
            | opts.get_creation_mode()
            | (opts._custom_flags as libc::c_int & ~libc::O_ACCMODE);

        let fd = error_check!(libc::open(
            path.ptr, 
            flags,
            opts._mode as libc::mode_t
        ));

        Result::ok(File { fd: fd })
    }

    fn from_fd(fd: libc::c_int) -> File {
        File { fd: fd }
    }

    fn read(self: &mut File, buf: &mut [u8]) -> Result<usize, Error> {
        let ret = error_check!(libc::read(self.fd, buf.ptr as &mut void, buf.len));
        Result::ok(ret as usize)
    }

    fn write(self: &mut File, buf: &[u8]) -> Result<usize, Error> {
        let ret = error_check!(libc::write(self.fd, buf.ptr as &void, buf.len));
        Result::ok(ret as usize)
    }

    fn flush(self: &mut File) -> Result<(), Error> {
        let ret = libc::fsync(self.fd);
        // Some files (notably stdout) do not support fsync,
        // this is not an error.
        if ret == -1 && *libc::__errno_location() != libc::EINVAL {
            return Result::err(Error::from_errno());
        }
        Result::ok(())        
    }

    fn close(self: &mut File) -> Result<(), Error> {
        error_check!(libc::close(self.fd));
        result::Result::ok(())
    }

    mixin Readable<File>;
    mixin Writable<File>;
}

static stdout : File = File::from_fd(libc::STDOUT_FILENO);
static stderr : File = File::from_fd(libc::STDERR_FILENO);
static stdin  : File = File::from_fd(libc::STDIN_FILENO);
