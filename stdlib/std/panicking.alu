

macro panic($reason, $args...) {
    internal::panic_impl(
        concat!($reason), 
        file!(), 
        line!(), 
        column!(),
        &[internal::FormatArg::new(&$args)...]
    )
}

mod internal {
    use fmt::internal::{printf, FormatArg};

    // Small formatter with as few dependencies as possible. No buffering, etc.
    struct PanicFormatter {}
    impl PanicFormatter {
        #[inline]
        fn write_str(self: &mut PanicFormatter, buf: &[u8]) {
            libc::write(libc::STDERR_FILENO, buf.ptr as &void, buf.len);
        }
        #[inline]
        fn write_char(self: &mut PanicFormatter, byte: u8) {
            libc::write(libc::STDERR_FILENO, &byte as &void, 1);
        }
    }
    
    static PANICKING: bool = false;

    #[cold]
    #[no_inline]
    fn panic_impl(
        fmt_str: &[u8], 
        file: &[u8], 
        line: i32, 
        column: i32, 
        args: &[FormatArg<PanicFormatter>]
    ) -> ! {
        if PANICKING {
            intrinsics::trap();
        }
        PANICKING = true;

        let formatter = PanicFormatter {};
        printf(
            "panic at {}:{}:{}: ", 
            &[FormatArg::new(&file), FormatArg::new(&line), FormatArg::new(&column)], 
            &formatter
        );
        printf(fmt_str, args, &formatter);
        formatter.write_char('\n');

        libc::_exit(-1);
    }
}
