use std::proto::{Unsigned, Integer};

struct Pcg32  {
    state: u64,
    increment: u64,
}

impl Pcg32 {
    #[inline]
    fn step(self: &mut Pcg32) {
        const MUTLIPLIER = 6364136223846793005u64;
        self.state = self.state * MUTLIPLIER + self.increment;
    }

    fn from_seed(seed: &[u8; 16]) -> Pcg32 {
        let pcg = Pcg32 {
            state: *(&(*seed)[0] as &u64),
            increment: *(&(*seed)[8] as &u64) | 1
        };

        pcg.state = pcg.state + pcg.increment;
        pcg.step();
        pcg
    }

    #[inline]
    fn next_u32(self: &mut Pcg32) -> u32 {
        let state = self.state;
        self.step();

        const ROTATE: u32 = 59;
        const XSHIFT: u32 = 18;
        const SPARE: u32 = 27;

        let rot = (state >> ROTATE) as usize;
        let xsh = (((state >> XSHIFT) ^ state) >> SPARE) as u32;

        xsh.rotate_right(rot)
    }

    mixin RandomNumberGenerator<Pcg32>;
}

static DEFAULT_RNG: Pcg32 = {
    let seed: [u8; 16];
    #[cfg(any(target_os = "linux", target_os="android"))]
    libc::getrandom(&seed[0] as &mut void, 16, 0);
    #[cfg(not(any(target_os = "linux", target_os="android")))]
    compile_fail!("DEFAULT_RNG is not supported");

    Pcg32::from_seed(&seed)
};

protocol RandomNumberGenerator<Self> {
    // One of these two has to be implemented, otherwise we have infinite recursio
    #[inline]
    fn next_u32(self: &mut Self) -> u32 {
        self.next_u64() as u32
    }

    #[inline]
    fn next_u64(self: &mut Self) -> u64 {
        (self.next_u32() as u64) << 32 | (self.next_u32() as u64)
    }
}

fn uniform<Rng: RandomNumberGenerator<Rng>>(rng: &mut Rng, range: u32) -> u32 {
    let t: u32 = (~range + 1) % range;
    let m = loop {
        let m = (rng.next_u32() as u64) * (range as u64);
        if t <= m as u32 {
            break m
        }
    };
    (m >> 32) as u32
}

fn range<Rng: RandomNumberGenerator<Rng>, T: Integer>(rng: &mut Rng, lower: T, upper: T) -> T {
    assert!(lower < upper);
    lower + (rng.uniform((upper - lower) as u32) as T)
}

fn shuffle<Rng: RandomNumberGenerator<Rng>, T>(rng: &mut Rng, slice: &mut [T]) {
    use std::mem::swap;

    let i = 0usize;
    while i < slice.len {
        let j = rng.range(i, slice.len) as usize;
        swap(&slice[i], &slice[j]);
        i += 1;
    }
}
