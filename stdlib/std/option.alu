macro try($opt) {
    let opt = $opt;
    if opt.is_some {
        opt.inner
    } else {
        return Option::none()
    }
}

struct Option<T> {
    is_some: bool,
    inner: T
}

impl Option<T> {
    #[force_inline]
    fn some(inner: T) -> Option<T> {
        Option::<T> {
            is_some: true, 
            inner: inner
        }
    }

    #[force_inline]
    fn none() -> Option<T> {
        Option::<T> {
            is_some: false
        }
    }

    fn as_result<E>(self: Option<T>, err: E) -> result::Result<T, E> {
        if self.is_some {
            result::Result::ok(self.inner)
        } else {
            result::Result::err(err)
        }
    }

    fn unwrap(self: Option<T>) -> T {
        if self.is_some {
            self.inner
        } else {
            panic!("unwrap on a none value")
        }
    }

    fn unwrap_or(self: Option<T>, val: T) -> T {
        if self.is_some {
            self.inner
        } else {
            val
        }
    }

    fn iter(self: &Option<T>) -> Option<T> {
        *self
    }

    fn next(self: &mut Option<T>) -> Option<T> {
        std::mem::replace(self, Option::none())
    }

    
}

impl Option {
    use std::cmp::{Equatable, Comparable, Ordering};
    use std::fmt::{write, Formatter, Formattable};
    use std::mem::{Freeable, Movable};
    
    #[inline]
    fn equals<T: Equatable<T>>(lhs: &Option<T>, rhs: &Option<T>) -> bool {
        if lhs.is_some {
            if rhs.is_some {
                lhs.inner.equals(&rhs.inner)
            } else {
                false
            }
        } else {
            !rhs.is_some
        }
    }

    #[inline]
    fn compare<T: Comparable<T>>(lhs: &Option<T>, rhs: &Option<T>) -> Ordering {
        if lhs.is_some {
            if rhs.is_some {
                lhs.inner.compare(&rhs.inner)
            } else {
                Ordering::Greater
            }
        } else {
            Ordering::Less
        }
    }

    fn fmt<T: Formattable<T, F>, F: Formatter<F>>(self: &Option<T>, formatter: &mut F) {
        if self.is_some {
            write!(formatter, "some({})", self.inner)
        } else {
            write!(formatter, "none")
        }
    }

    fn move<T: Movable<T>>(self: &mut Option<T>) -> Option<T> {
        if self.is_some {
            Option::some(self.inner.move())
        } else {
            Option::none()
        }
    }

    fn free<T: Freeable<T>>(self: &mut Option<T>) {
        if self.is_some {
            self.inner.free();
        }
    }

    mixin<T: Equatable<T>> Equatable<Option<T>;
    mixin<T: Comparable<T>> Comparable<Option<T>;
}

#[cfg(test)]
mod tests {
    #[test]
    fn option_ok() {
        let opt = Option::some(42);
        assert!(opt.unwrap() == 42);
    }
}
