#[cfg(any(target_os="linux", target_os="macos", target_os="android"))]
use unix::{
    TcpStream,
    TcpListener,
    NameLookup,
    Shutdown,
    Socket
};

enum AddrKind {
    V6,
    #[deprecated] V4, // booya!
}

struct Ipv6Addr {
    inner: libc::in6_addr,
}

impl Ipv6Addr {
    fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {
        use internal::htons;

        let addr: libc::in6_addr;
        let as_u16 = &addr.s6_addr as &mut [u16; 8];

        (*as_u16)[0] = htons(a);
        (*as_u16)[1] = htons(b);
        (*as_u16)[2] = htons(c);
        (*as_u16)[3] = htons(d);
        (*as_u16)[4] = htons(e);
        (*as_u16)[5] = htons(f);
        (*as_u16)[6] = htons(g);
        (*as_u16)[7] = htons(h);

        Ipv6Addr { inner: addr }
    }

    fn localhost() -> Ipv6Addr {
        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)
    }

    fn unspecified() -> Ipv6Addr {
        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)
    }

    fn from_libc(addr: libc::in6_addr) -> Ipv6Addr {
        Ipv6Addr { inner: addr }
    }

    fn to_segments(self: &Ipv6Addr) -> [u16; 8] {
        use internal::htons;

        let as_u16 = &self.inner.s6_addr as &[u16; 8];
        
        [
            htons((*as_u16)[0]),
            htons((*as_u16)[1]),
            htons((*as_u16)[2]),
            htons((*as_u16)[3]),
            htons((*as_u16)[4]),
            htons((*as_u16)[5]),
            htons((*as_u16)[6]),
            htons((*as_u16)[7]),
        ]
    }
    
    fn to_ipv4(self: &Ipv6Addr) -> Option<Ipv4Addr> {
        let segments = self.to_segments();
        if segments[0] == 0 && segments[1] == 0 && segments[2] == 0 && segments[3] == 0 &&
           segments[4] == 0 && (segments[5] == 0xffff || segments[5] == 0)  {
            let a = (segments[6] >> 8) as u8;
            let b = segments[6] as u8;
            let c = (segments[7] >> 8) as u8;
            let d = segments[7] as u8;

            Option::some(Ipv4Addr::new(a, b, c, d))
        } else {
            Option::none()
        }
    }

    fn fmt<F: fmt::Formatter<F>>(self: &Ipv6Addr, f: &mut F) -> Result<(), fmt::Error> {
        use fmt::{hex, zero_pad, write};
 
        // IPv4-compatible formats
        let segments = self.to_segments();
        if *self != Ipv6Addr::localhost() && *self != Ipv6Addr::unspecified() {
            let mapped_v4 = self.to_ipv4();
            if mapped_v4.is_some {
                if segments[5] == 0xffff {
                    return write!(f, "::ffff:{}", mapped_v4.unwrap());
                } else {
                    return write!(f, "::{}", mapped_v4.unwrap());
                }
            }
        }
        
        // Find first longest consecutive sequence of zero segments.
        let longest: Option<(usize, usize)> = Option::none();
        let current: Option<(usize, usize)> = Option::none();
    
        for i in range(0usize, 8) {
            if segments[i] == 0 {
                if !current.is_some {
                    current = Option::some((i, 1usize));
                } else {
                    current.inner.1 += 1;
                }

                if !longest.is_some || (longest.inner.1 < current.inner.1) {
                    longest = current;
                }
            } else {
                current = Option::none();
            }
        }

        let first = true;
        let i = 0usize;
        while i < 8 {
            if longest.is_some && i == longest.inner.0 && longest.inner.1 > 1 {
                try!(write!(f, "::"));
                i += longest.inner.1;
                first = true;
            } else {
                if first {
                    try!(write!(f, "{}", segments[i].hex()));
                    first = false;
                } else {
                    try!(write!(f, ":{}", segments[i].hex()));
                }
                i += 1;
            }
        }

        Result::ok(())
    }

    fn equals(self: &Ipv6Addr, other: &Ipv6Addr) -> bool {
        self.inner.s6_addr.as_slice() == other.inner.s6_addr.as_slice()
    }

    mixin cmp::Equatable<Ipv6Addr>;
}

struct Ipv4Addr {
    inner: libc::in_addr,
}

impl Ipv4Addr {
    fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {
        let as_int = a as u32 |
            (b as u32) << 8 |
            (c as u32) << 16 |
            (d as u32) << 24;

        Ipv4Addr { inner: libc::in_addr { s_addr: as_int } }
    }

    fn localhost() -> Ipv4Addr {
        Ipv4Addr::new(127, 0, 0, 1)
    }

    fn unspecified() -> Ipv4Addr {
        Ipv4Addr::new(0, 0, 0, 0)
    }

    fn broadcast() -> Ipv4Addr {
        Ipv4Addr::new(255, 255, 255, 255)
    }

    fn from_libc(addr: libc::in_addr) -> Ipv4Addr {
        Ipv4Addr { inner: addr }
    }

    fn to_octets(self: &Ipv4Addr) -> [u8; 4] {
        let as_int = self.inner.s_addr;
        [
            as_int as u8,
            (as_int >> 8) as u8,
            (as_int >> 16) as u8,
            (as_int >> 24) as u8,
        ]
    }

    fn to_ipv6_compatible(self: &Ipv4Addr) -> Ipv6Addr {
        let ip = self.to_octets();
        let x = ip[1] as u16 | ((ip[0] as u16) << 8);
        let y = ip[3] as u16 | ((ip[2] as u16) << 8);
        Ipv6Addr::new(0, 0, 0, 0, 0, 0, x, y)
    }

    fn to_ipv6_mapped(self: &Ipv4Addr) -> Ipv6Addr {
        let ip = self.to_octets();
        let x = ip[1] as u16 | ((ip[0] as u16) << 8);
        let y = ip[3] as u16 | ((ip[2] as u16) << 8);
        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, x, y)
    }

    fn fmt<F: fmt::Formatter<F>>(self: &Ipv4Addr, f: &mut F) -> Result<(), fmt::Error> {
        use fmt::{hex, zero_pad, write};
        
        let octets = self.to_octets();
        write!(f, 
            "{}.{}.{}.{}", 
            octets[0], 
            octets[1], 
            octets[2], 
            octets[3]
        )
    }

    fn equals(self: &Ipv4Addr, other: &Ipv4Addr) -> bool {
        self.inner.s_addr == other.inner.s_addr
    }

    mixin cmp::Equatable<Ipv4Addr>;
}

union IpAddrInner {
    v6: Ipv6Addr,    
    v4: Ipv4Addr,
}

struct IpAddr {
    kind: AddrKind,
    inner: IpAddrInner
}

impl IpAddr {
    fn v6(ip: Ipv6Addr) -> IpAddr {
        IpAddr { kind: AddrKind::V6, inner: IpAddrInner { v6: ip } }
    }

    fn v4(ip: Ipv4Addr) -> IpAddr {
        IpAddr { kind: AddrKind::V4, inner: IpAddrInner { v4: ip } }
    }

    fn fmt<F: fmt::Formatter<F>>(self: &IpAddr, f: &mut F) -> Result<(), fmt::Error> {
        switch self.kind {
            AddrKind::V6 => self.inner.v6.fmt(f),
            AddrKind::V4 => self.inner.v4.fmt(f),
            _ => unreachable!()
        }
    }
}

union SocketAddrInner {
    v6: libc::sockaddr_in6,    
    v4: libc::sockaddr_in,
}

struct SocketAddr {
    kind: AddrKind,
    inner: SocketAddrInner
}

impl SocketAddr {
    fn new(addr: IpAddr, port: u16) -> SocketAddr {
        let inner = switch addr.kind {
            AddrKind::V6 => {
                return with_flowinfo_and_scope(addr.inner.v6, port, 0, 0);
            }
            AddrKind::V4 => {
                let sockaddr = mem::zeroed::<libc::sockaddr_in>();
                sockaddr.sin_family = libc::AF_INET as libc::sa_family_t;
                sockaddr.sin_port = internal::htons(port);
                sockaddr.sin_addr = addr.inner.v4.inner;

                SocketAddrInner { v4: sockaddr }
            },
            _ => unreachable!()
        }

        SocketAddr { 
            kind: addr.kind, 
            inner: inner 
        }
    }

    fn with_flowinfo_and_scope(addr: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddr {
        let sockaddr = mem::zeroed::<libc::sockaddr_in6>();
        sockaddr.sin6_family = libc::AF_INET6 as libc::sa_family_t;
        sockaddr.sin6_port = internal::htons(port);
        sockaddr.sin6_addr = addr.inner;
        sockaddr.sin6_flowinfo = flowinfo;
        sockaddr.sin6_scope_id = scope_id;
        
        SocketAddr { 
            kind: AddrKind::V6, 
            inner: SocketAddrInner { v6: sockaddr }
        }
    }

    fn set_port(self: &mut SocketAddr, port: u16) {
        switch self.kind {
            AddrKind::V6 => {
                self.inner.v6.sin6_port = internal::htons(port);
            }
            AddrKind::V4 => {
                self.inner.v4.sin_port = internal::htons(port);
            }
        }
    }

    fn port(self: &SocketAddr) -> u16 {
        switch self.kind {
            AddrKind::V6 => internal::htons(self.inner.v6.sin6_port),
            AddrKind::V4 => internal::htons(self.inner.v4.sin_port),
            _ => unreachable!()
        }
    }

    fn ip(self: &SocketAddr) -> IpAddr {
        switch self.kind {
            AddrKind::V6 => IpAddr::v6(Ipv6Addr::from_libc(self.inner.v6.sin6_addr)),
            AddrKind::V4 => IpAddr::v4(Ipv4Addr::from_libc(self.inner.v4.sin_addr)),
            _ => unreachable!()
        }
    }

    fn fmt<F: fmt::Formatter<F>>(self: &SocketAddr, f: &mut F) -> Result<(), fmt::Error> {
        use fmt::write;

        switch self.kind {
            AddrKind::V6 => {
                if self.inner.v6.sin6_scope_id != 0 {
                    write!(f, "[{}%{}]:{}", self.ip(), self.inner.v6.sin6_scope_id, self.port())
                } else {   
                    write!(f, "[{}]:{}", self.ip(), self.port())
                }
            }
            AddrKind::V4 => {
                write!(f, "{}:{}", self.ip(), self.port())
            }
            _ => unreachable!()
        }
    }
}

/// Create a buffered reader/writer pair for a socket.
fn buffered(self: &mut TcpStream, read_buf_size: usize, write_buf_size: usize) 
    -> (io::BufferedReader<TcpStream>, io::BufferedWriter<TcpStream>) {
    let reader = io::BufferedReader::new(self, read_buf_size);
    let writer = io::BufferedWriter::new(self, write_buf_size);

    (reader, writer)
}

mod internal {
    fn htons(i: u16) -> u16 {
        ((i & 0x00ff) << 8) | ((i & 0xff00) >> 8)
    }
}

mod tests {
    use fmt::format_in;
    static BUF: [u8; 1024];

    macro fmt($args...) {
        format_in!(&BUF, $args...).unwrap()
    }

    macro fmt_ipv6($args...) {
        let addr = Ipv6Addr::new($args...);
        format_in!(&BUF, "{}", addr).unwrap()
    }

    #[test]
    fn test_addr() {
        assert_eq!(fmt_ipv6!(0, 0, 0, 0, 0, 0, 0, 0), "::");
        assert_eq!(fmt_ipv6!(0, 0, 0, 0, 0, 0, 0, 1), "::1");
        assert_eq!(fmt_ipv6!(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), "2001:db8::1");
        assert_eq!(fmt_ipv6!(8, 9, 10, 11, 12, 13, 14, 15), "8:9:a:b:c:d:e:f");
        assert_eq!(
            fmt_ipv6!(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888), 
            "1111:2222:3333:4444:5555:6666:7777:8888"
        );
        assert_eq!(fmt_ipv6!(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304), "ae::ffff:102:304");
        assert_eq!(fmt_ipv6!(1, 2, 3, 4, 5, 6, 0, 8), "1:2:3:4:5:6:0:8");
        assert_eq!(fmt_ipv6!(0, 0, 0, 0, 0, 0, 0, 0), "::");
        assert_eq!(fmt_ipv6!(0, 0, 0, 0, 0, 0, 0, 1), "::1");
        assert_eq!(fmt_ipv6!(1, 0, 0, 0, 0, 0, 0, 0), "1::");
        assert_eq!(fmt_ipv6!(1, 0, 0, 4, 0, 0, 0, 8), "1:0:0:4::8");
        assert_eq!(fmt_ipv6!(1, 0, 0, 4, 5, 0, 0, 8), "1::4:5:0:0:8");
    }

    #[test]
    fn test_addr_mapped() {
        let addr = Ipv4Addr::new(192,168,201,1);

        assert_eq!(fmt!("{}", addr.to_ipv6_mapped()), "::ffff:192.168.201.1");
        assert_eq!(fmt!("{}", addr.to_ipv6_compatible()), "::192.168.201.1");
    }

    #[test]
    fn test_ipv4_addr() {
        let addr = Ipv4Addr::new(127, 0, 0, 1);

        assert_eq!(fmt!("{}", addr), "127.0.0.1");
    }

    #[test]
    fn test_socket_addr() {
        let addr = Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1);
        let addr = SocketAddr::new(IpAddr::v6(addr), 80);
        
        assert_eq!(fmt!("{}", addr), "[2001:db8::1]:80");
    }

    #[test]
    fn test_socket_addr_with_scope_id() {
        let addr = SocketAddr::with_flowinfo_and_scope(
            Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 
            80,
            0,
            1337
        );
        
        assert_eq!(fmt!("{}", addr), "[2001:db8::1%1337]:80");
    }

    #[test]
    fn test_ipv4_socket_addr() {
        let addr = Ipv4Addr::new(127, 0, 0, 1);
        let addr = SocketAddr::new(IpAddr::v4(addr), 80);

        assert_eq!(fmt!("{}", addr), "127.0.0.1:80");
    }
}
