use std::hash::{Hashable, Hasher, DefaultHash, hash_of};
use std::option::{Option, try};
use std::cmp::Equatable;
use std::iter::{Iterator, Iterable};

const INITIAL_SIZE: usize = 4;

enum State {
    Vacant = 0u8,
    Occupied = 1,
    Deleted = 2,
}

struct HashItem<T> {
    state: State,
    item: T
}

struct HashMap<K: Hashable<K, H> + Equatable<K>, V, H: Hasher<H> = DefaultHash> {
    _buckets: &mut [HashItem<(K, V)>],
    _length: usize,
}

struct HashMapIterator<K, V> {
    _buckets: &[HashItem<(K, V)>],
    _index: usize,
}

impl HashMapIterator<K, V> {
    fn next(self: &mut HashMapIterator<K, V>) -> Option<(K, V)> {
        while self._index < self._buckets.len {
            let item = &self._buckets[self._index];
            self._index += 1;
            if item.state == State::Occupied {
                return Option::some(item.item);
            }
        }
        Option::none()
    }
}

impl HashMap<K: Hashable<K, H> + Equatable<K>, V, H: Hasher<H> = DefaultHash> {
    use std::mem::alloc_zeroed;

    fn new() -> HashMap<K, V, H> {
        with_capacity(0)
    }

    fn with_capacity(capacity: usize) -> HashMap<K, V, H> {
        HashMap::<K, V, H> {
            _buckets: alloc_zeroed::<HashItem<(K, V)>>(capacity),
            _length: 0,
        }
    }

    fn rehash(self: &mut HashMap<K, V, H>, new_capacity: usize) {
        let new_map = with_capacity::<K, V, H>(new_capacity);
        for item in self {
            new_map.insert(item);
        }

        self.free();
        self._buckets = new_map._buckets;
    }

    fn _grow_if_needed(self: &mut HashMap<K, V, H>, new_length: usize) -> bool {            
        if new_length * 3 > self._buckets.len * 2 { 
            self.rehash(self._buckets.len * 2);
            return true;
        }

        return false;
    }

    fn _insert(self: &mut HashMap<K, V, H>, item: (K, V), grow: bool) -> Option<V> {
        let initial_index = (hash_of::<K, H>(item.0) as usize) % self._buckets.len; 
        let index = initial_index;

        loop {
            switch self._buckets[index].state {
                State::Vacant => {
                    if grow && self._grow_if_needed(self._length + 1) {
                        return self._insert(item, false);
                    }
                    self._length += 1;
                    self._buckets[index].state = State::Occupied;
                    self._buckets[index].item = item;
                    return Option::none();
                }
                State::Occupied => {
                    if self._buckets[index].item.0 == item.0 {
                        return Option::some(std::mem::replace(&self._buckets[index].item.1, item.1));
                    }
                }
            }
            index = (index + 1) % self._buckets.len;
            if index == initial_index {
                assert!(grow);

                // We wrapped around because of deleted items, we don't
                // need to grow the hashmap, but we need to get rid of the
                // tombstones by rehashing.
                self.rehash(self._buckets.len);
                return self._insert(item, false);
            }
        }
    }

    fn _get_slot(self: &HashMap<K, V, H>, key: K) -> Option<&mut HashItem<(K, V)>> {
        if self._length == 0 {
            return Option::none();
        }

        let initial_index = (hash_of::<K, H>(key) as usize) % self._buckets.len; 
        let index = initial_index;

        loop {
            switch self._buckets[index].state {
                State::Vacant => {
                    return Option::none();
                }
                State::Occupied => {
                    if self._buckets[index].item.0 == key {
                        return Option::some(&self._buckets[index]);
                    }
                }
            }
            index = (index + 1) % self._buckets.len;
            if index == initial_index {
                // We can wrap around if all the buckets are Occupied or Deleted
                return Option::none();
            }
        }
    }

    fn insert(self: &mut HashMap<K, V, H>, item: (K, V)) -> Option<V> {
        if self._buckets.len == 0 {
            self.rehash(INITIAL_SIZE);
        }

        self._insert(item, true)
    }

    fn get(self: &HashMap<K, V, H>, key: K) -> Option<V> {
        let item = try!(self._get_slot(key));
        Option::some(item.item.1)
    }

    fn get_mut(self: &mut HashMap<K, V, H>, key: K) -> Option<&mut V> {
        let item = try!(self._get_slot(key));
        Option::some(&item.item.1)
    }

    fn remove(self: &mut HashMap<K, V, H>, key: K) -> Option<V> {
        let item = try!(self._get_slot(key));
        self._length -= 1;
        item.state = State::Deleted;
        Option::some(item.item.1)
    }

    #[inline]
    fn len(self: &HashMap<K, V, H>) -> usize {
        self._length
    }

    #[inline]
    fn empty(self: &HashMap<K, V, H>) -> bool {
        self._length == 0
    }

    fn clear(self: &mut HashMap<K, V, H>) {
        for i in std::iter::range(0usize, self._buckets.len) {
            self._buckets[i].state = State::Vacant;
        }
        self._length = 0;
    }

    fn iter(self: &HashMap<K, V, H>) -> HashMapIterator<K, V> {
        HashMapIterator::<K, V> {
            _buckets: self._buckets,
            _index: 0,
        }
    }

    fn free(self: &mut HashMap<K, V, H>) {
        use std::mem::free;
        self._buckets.free();
    }
}

impl HashMap<
    K: Hashable<K, H> + Equatable<K>, 
    V,
    I: Iterator<I, (K, V)>, 
    H: Hasher<H> = DefaultHash
> {
    fn from_iter(iter: I) -> HashMap<K, V, H> {
        let map = HashMap::new::<K, V, H>();
        map.extend(iter);
        map
    }

    fn extend(self: &mut HashMap<K, V, H>, iter: I) {
        for item in iter {
            self.insert(item);
        }
    }
}
