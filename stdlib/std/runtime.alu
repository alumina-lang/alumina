#[cfg(not(output_type = "library"))]
mod internal {
    use std::intrinsics::{aligned_alloca, size_of, align_of};
    use std::mem::slice;
    use std::proto::Callable;

    #[cfg(test)]
    {
        // Minimal support for testing in the compiler. During AST construction, compiler will collect 
        // all the methods with #[test] attribute and make them available via this intrinsic. Function
        // actually returns a non-zero-sized array, but we cannot really express it in the signature, as
        // the number of returned items will vary.
        extern "intrinsic" fn test_cases() -> [TestCaseMeta; 0];

        #[lang(test_case_meta)]
        struct TestCaseMeta { 
            path: &[u8],
            name: &[u8],
            test: fn(),
        }

        impl TestCaseMeta {
            #[lang(test_case_meta_new)]
            fn new(path: &[u8], name: &[u8], test: fn()) -> TestCaseMeta {
                TestCaseMeta {
                    path: path,
                    name: name,
                    test: test,
                }
            }
        }
    }

    macro argc_argv_to_slice($argc, $argv) {
        let argc = $argc as usize;
        let argv = $argv as &&u8;
        let args = aligned_alloca(size_of::<&[u8]>() * (argc), align_of::<&[u8]>() * 8) as &mut &[u8];
        let args_ptr = args;
        while *argv != null {
            *args_ptr = slice::from_raw(*argv, libc::strlen(*argv as &libc::c_char) as usize);
            argv += 1;
            args_ptr += 1;
        }
        slice::from_raw(args as &&[u8], argc)
    }

    #[export]
    #[codegen(c_main)]
    #[lang(entrypoint_glue)]
    fn main<UserMain>(argc: libc::c_int, argv: &&libc::c_char) -> libc::c_int {
        let func: UserMain;
        when UserMain: Callable<(&[&[u8]]), i32> {
            func(argc_argv_to_slice!(argc, argv)) as libc::c_int
        } else when UserMain: Callable<(&[&[u8]]), void> {
            func(argc_argv_to_slice!(argc, argv));
            0
        } else when UserMain: Callable<(), i32> {
            func() as libc::c_int
        } else when UserMain: Callable<(), void> {
            func();
            0
        } else {
            compile_fail!("invalid signature for the main function")
        }
    }
}
