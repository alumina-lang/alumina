#[cfg(not(output_type = "library"))]
mod internal {
    use std::intrinsics::{aligned_alloca, size_of, align_of};
    use std::mem::slice;
    use std::proto::Callable;

    macro argc_argv_to_slice($argc, $argv) {
        let argc = $argc as usize;
        let argv = $argv as &&u8;
        let args = aligned_alloca(size_of::<&[u8]>() * (argc), align_of::<&[u8]>() * 8) as &mut &[u8];
        let args_ptr = args;
        while *argv != null {
            *args_ptr = slice::from_raw(*argv, libc::strlen(*argv as &libc::c_char) as usize);
            argv += 1;
            args_ptr += 1;
        }
        slice::from_raw(args as &&[u8], argc)
    }

    #[export]
    #[codegen(c_main)]
    #[lang(entrypoint_glue)]
    fn main<UserMain>(argc: libc::c_int, argv: &&libc::c_char) -> libc::c_int {
        let func: UserMain;
        when UserMain: Callable<(&[&[u8]]), i32> {
            func(argc_argv_to_slice!(argc, argv)) as libc::c_int
        } else when UserMain: Callable<(&[&[u8]]), void> {
            func(argc_argv_to_slice!(argc, argv));
            0
        } else when UserMain: Callable<(), i32> {
            func() as libc::c_int
        } else when UserMain: Callable<(), void> {
            func();
            0
        } else {
            compile_fail!("invalid signature for the main function")
        }
    }
}
