use proto::Integer;
use option::Option;

protocol Iterator<Self, T> {
    fn next(self: &mut Self) -> Option<T>;

    fn size_hint(self: &Self) -> Option<usize> {
        Option::none()
    }
}

protocol Iterable<Self, It: Iterator<It, T>, T> {
    fn iter(self: &Self) -> It;
}

struct Range<T: Integer> {
    lower: T,
    upper: T,
}

impl Range<T: Integer> {
    #[force_inline]
    fn iter(self: &Range<T>) -> RangeIter<T> {
        RangeIter {
            current: self.lower,
            upper: self.upper,
        }
    }

    fn len(self: &Range<T>) -> T {
        self.upper - self.lower
    }
}

struct RangeIter<T: Integer> {
    current: T,
    upper: T,
}

impl RangeIter<T: Integer> {
    #[force_inline]
    fn next(self: &mut RangeIter<T>) -> Option<T> {
        if self.current < self.upper {
            let current = self.current;
            self.current += 1;
            Option::some(current)
        } else {
            Option::none()
        }
    }

    fn size_hint(self: &RangeIter<T>) -> Option<usize> {
        if self.current < self.upper {
            Option::some(self.upper - self.current)
        } else {
            Option::some(0)
        }
    }
    
    mixin<T: Integer> Iterator<RangeIter<T>, T>;
}

#[force_inline]
fn range<T: Integer>(lower: T, upper: T) -> Range<T> {
    Range {
        lower: lower,
        upper: upper,
    }
}
