//! Ranges and iterators.

use marker::Integer;
use option::Option;
use marker::Callable;

#[lang(proto_iterator)]
protocol Iterator<Self, T> {
    fn next(self: &mut Self) -> Option<T>;
    
    fn size_hint(self: &Self) -> Option<usize> {
        Option::none()
    }
}

protocol Iterable<Self, It: Iterator<It, T>, T> {
    fn iter(self: &Self) -> It;
}

protocol IterableRef<Self, It: Iterator<It, &T>, T> {
    fn iter_ref(self: &Self) -> It;
}

protocol IterableMut<Self, It: Iterator<It, &mut T>, T> {
    fn iter_mut(self: &mut Self) -> It;
}


struct MapIterator<It: Iterator<It, T>, F: Callable<(T), U>, T, U> {
    it: &mut It,
    fun: F,
}

impl MapIterator<It: Iterator<It, T>, F: Callable<(T), U>, T, U> {
    fn next(self: &mut MapIterator<It, F, T, U>) -> Option<U> {
        self.it.next().map(|=self, x: T| -> U { self.fun(x) })
    }

    fn size_hint(self: &MapIterator<It, F, T, U>) -> Option<usize> {
        self.it.size_hint()
    }

    mixin Iterator<MapIterator<It, F, T, U>, U>;
    mixin IteratorExt<MapIterator<It, F, T, U>, U>;
}

struct TakeWhileIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    it: &mut It,
    fun: F,
}

impl TakeWhileIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    fn next(self: &mut TakeWhileIterator<It, F, T>) -> Option<T> {
        self.it.next().and_then(|=self, x: T| -> Option<T> {
            if self.fun(x) {
                Option::some(x)
            } else {
                Option::none()
            }
        })
    }

    mixin Iterator<TakeWhileIterator<It, F, T>, T>;
    mixin IteratorExt<TakeWhileIterator<It, F, T>, T>;
}

struct SkipWhileIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    it: &mut It,
    fun: F,
    finished: bool,
}

impl SkipWhileIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    fn next(self: &mut SkipWhileIterator<It, F, T>) -> Option<T> {
        loop {
            let v = self.it.next();
            if self.finished || !v.is_some {
                return v;
            } else if self.fun(v.inner) {
                continue
            } else {
                self.finished = true;
                return v
            }
        }
    }

    mixin Iterator<SkipWhileIterator<It, F, T>, T>;
    mixin IteratorExt<SkipWhileIterator<It, F, T>, T>;
}

struct FilterMapIterator<It: Iterator<It, T>, F: Callable<(T), Option<U>>, T, U> {
    it: &mut It,
    fun: F,
}

impl FilterMapIterator<It: Iterator<It, T>, F: Callable<(T), Option<U>>, T, U> {
    fn next(self: &mut FilterMapIterator<It, F, T, U>) -> Option<U> {
        use option::try;

        loop {
            let value = self.it.next()?;
            let mapped = self.fun(value);

            if mapped.is_some {
                return mapped
            }
        }
    }

    mixin Iterator<FilterMapIterator<It, F, T, U>, U>;
    mixin IteratorExt<FilterMapIterator<It, F, T, U>, U>;
}

struct FilterIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    it: &mut It,
    fun: F,
}

impl FilterIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    fn next(self: &mut FilterIterator<It, F, T>) -> Option<T> {
        use option::try;

        loop {
            let value = self.it.next()?;
            if self.fun(value) {
                return Option::some(value)
            }
        }
    }

    mixin Iterator<FilterIterator<It, F, T>, T>;
    mixin IteratorExt<FilterIterator<It, F, T>, T>;
}

struct SkipIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    n: usize,
}

impl SkipIterator<It: Iterator<It, T>, T> {
    fn next(self: &mut SkipIterator<It, T>) -> Option<T> {
        while self.n > 0 {
            self.n -= 1;
            if !self.it.next().is_some {
                return Option::none();
            }
        }

        self.it.next()
    }

    fn size_hint(self: &SkipIterator<It, T>) -> Option<usize> {
        self.it.size_hint().map(|=self, v: usize| -> usize { 
            if self.n > v {
                0
            } else {
                v - self.n
            }
        })
    }

    mixin Iterator<SkipIterator<It, T>, T>;
    mixin IteratorExt<SkipIterator<It, T>, T>;
}

struct StepByIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    n: usize,
    index: usize,
}

impl StepByIterator<It: Iterator<It, T>, T> {
    fn next(self: &mut StepByIterator<It, T>) -> Option<T> {
        use option::try;
        loop {
            self.index = (self.index + 1) % self.n;
            if self.index > 0 {
                self.it.next()?;
            } else {
                break;
            }
        }
        self.it.next()
    }

    fn size_hint(self: &StepByIterator<It, T>) -> Option<usize> {
        self.it.size_hint().map(|=self, v: usize| -> usize { 
            (v + self.index) / self.n
        })
    }

    mixin Iterator<StepByIterator<It, T>, T>;
    mixin IteratorExt<StepByIterator<It, T>, T>;
}


struct TakeIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    n: usize,
}

impl TakeIterator<It: Iterator<It, T>, T> {
    fn next(self: &mut TakeIterator<It, T>) -> Option<T> {
        if self.n == 0 {
            return Option::none();
        }

        self.n -= 1;
        self.it.next()
    }

    fn size_hint(self: &TakeIterator<It, T>) -> Option<usize> {
        self.it.size_hint().map(|=self, v: usize| -> usize {
            math::min(v, self.n)
        })
    }

    mixin Iterator<TakeIterator<It, T>, T>;
    mixin IteratorExt<TakeIterator<It, T>, T>;
}

struct EnumerateIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    n: usize,
}

impl EnumerateIterator<It: Iterator<It, T>, T> {
    fn next(self: &mut EnumerateIterator<It, T>) -> Option<(usize, T)> {
        use option::try;
        
        let val = self.it.next()?;
        let res = (self.n, val);
        self.n += 1;
        Option::some(res)
    }

    fn size_hint(self: &EnumerateIterator<It, T>) -> Option<usize> {
        self.it.size_hint()
    }

    mixin Iterator<EnumerateIterator<It, T>, (usize, T)>;
    mixin IteratorExt<EnumerateIterator<It, T>, (usize, T)>;
}

struct ChainIterator<It1: Iterator<It1, T>, It2: Iterator<It2, T>, T> {
    first_done: bool,
    it1: &mut It1,
    it2: &mut It2,
}

impl ChainIterator<It1: Iterator<It1, T>, It2: Iterator<It2, T>, T> {
    fn next(self: &mut ChainIterator<It1, It2, T>) -> Option<T> {
        if self.first_done {
            self.it2.next()
        } else {
            let v = self.it1.next();
            if !v.is_some {
                self.first_done = true;
                self.it2.next()
            } else {
                v
            }
        }
    }

    fn size_hint(self: &ChainIterator<It1, It2, T>) -> Option<usize> {
        if self.first_done {
            self.it2.size_hint()
        } else {
            let h1 = self.it1.size_hint();
            let h2 = self.it2.size_hint();

            if h1.is_some && h2.is_some {
                Option::some(h1.inner + h2.inner)
            } else {
                Option::none()
            }
        }
    }

    mixin Iterator<ChainIterator<It1, It2, T>, T>;
    mixin IteratorExt<ChainIterator<It1, It2, T>, T>;
}


struct InspectIterator<It: Iterator<It, T>, F: Callable<(T), ()>, T> {
    it: &mut It,
    func: F,
}

impl InspectIterator<It: Iterator<It, T>, F: Callable<(T), ()>, T> {
    fn next(self: &mut InspectIterator<It, F, T>) -> Option<T> {
        let v = self.it.next();
        if v.is_some {
            self.func(v.inner);
        }
        v
    }

    fn size_hint(self: &InspectIterator<It, F, T>) -> Option<usize> {
        self.it.size_hint()
    }

    mixin Iterator<InspectIterator<It, F, T>, T>;
    mixin IteratorExt<InspectIterator<It, F, T>, T>;
}

struct Grouping<It: Iterator<It, T>, F: Callable<(T), K>, T, K: cmp::Equatable<K>> {
    parent: &mut GroupByIterator<It, F, T, K>,
    key: K
}

impl Grouping<It: Iterator<It, T>, F: Callable<(T), K>, T, K: cmp::Equatable<K>> {
    fn next(self: &mut Grouping<It, F, T, K>) -> Option<T> {
        use option::try;

        let v = self.parent.it.peek();
        if !v.is_some {
            self.parent.last_group = Option::none();
            return self.parent.it.next();
        }

        if self.key != self.parent.func(v.inner) {
            self.parent.last_group = Option::none();
            Option::none()
        } else {
            self.parent.it.next()
        }
    }

    mixin Iterator<Grouping<It, F, T, K>, T>;
    mixin IteratorExt<Grouping<It, F, T, K>, T>;
}

struct GroupByIterator<It: Iterator<It, T>, F: Callable<(T), K>, T, K: cmp::Equatable<K>> {
    it: PeekableIterator<It, T>,
    last_group: Option<Grouping<It, F, T, K>>,
    func: F
}

impl GroupByIterator<It: Iterator<It, T>, F: Callable<(T), K>, T, K: cmp::Equatable<K>> {
    fn next(self: &mut GroupByIterator<It, F, T, K>) -> Option<Grouping<It, F, T, K>> {
        let needs_drain = self.last_group.move();
        if needs_drain.is_some {
            for _ in needs_drain.inner {
            }
        }

        let v = self.it.peek();
        if !v.is_some {
            self.it.next();
            return Option::none();
        }

        self.last_group = Option::some(Grouping::<It, F, T, K> {
            parent: self,
            key: self.func(v.inner)
        });

        self.last_group
    }

    mixin Iterator<GroupByIterator<It, F, T, K>, Grouping<It, F, T, K>>;
    mixin IteratorExt<GroupByIterator<It, F, T, K>, Grouping<It, F, T, K>>;
}

struct PeekableIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    peeked: Option<T>,
}

impl PeekableIterator<It: Iterator<It, T>, T> {
    fn next(self: &mut PeekableIterator<It, T>) -> Option<T> {
        if self.peeked.is_some {
            self.peeked.move()
        } else {
            self.it.next()
        }
    }
    
    fn peek(self: &mut PeekableIterator<It, T>) -> Option<T> {
        if !self.peeked.is_some {
            self.peeked = self.it.next();
        }
        self.peeked
    }
    
    fn size_hint(self: &PeekableIterator<It, T>) -> Option<usize> {
        self.it.size_hint().map(|=self, x: usize| -> usize {
            if self.peeked.is_some {
                x + 1
            } else {
                x
            }
        })
    }
    
    mixin Iterator<PeekableIterator<It, T>, T>;
    mixin IteratorExt<PeekableIterator<It, T>, T>;
}

protocol IteratorExt<Self: Iterator<Self, T>, T> {
    fn iter(self: &mut Self) -> &mut Self {
        self
    }

    fn chain<Other: Iterator<Other, T>>(self: &mut Self, other: &mut Other) -> ChainIterator<Self, Other, T> {
        ChainIterator {
            first_done: false,
            it1: self,
            it2: other
        }
    }

    fn skip(self: &mut Self, n: usize) -> SkipIterator<Self, T> {
        SkipIterator {
            it: self,
            n: n,
        }
    }

    fn step_by(self: &mut Self, n: usize) -> StepByIterator<Self, T> {
        assert!(n > 0);

        StepByIterator {
            it: self,
            index: n - 1,
            n: n,
        }
    }

    fn take(self: &mut Self, n: usize) -> TakeIterator<Self, T> {
        TakeIterator {
            it: self,
            n: n,
        }
    }

    fn enumerate(self: &mut Self) -> EnumerateIterator<Self, T> {
        EnumerateIterator {
            it: self,
            n: 0,
        }
    }

    fn last(self: &mut Self) -> Option<T> {
        let value: Option<T> = Option::none();
        loop {
            let next = self.next();
            if next.is_some {
                value = next;
            } else {
                return value;
            }
        }
    }

    fn nth(self: &mut Self, n: usize) -> Option<T> {
        use option::try;
        for i in 0usize..n {
            self.next()?;
        }
        self.next()
    }

    fn count(self: &mut Self) -> usize {
        let n = 0usize;
        loop {
            if !self.next().is_some {
                return n;
            }
            n += 1;
        }
    }

    fn inspect<F: Callable<(T), ()>>(it: &mut Self, func: F) -> InspectIterator<Self, F, T> {
        InspectIterator {
            it: it,
            func: func,
        }
    }
    
    fn take_while<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> TakeWhileIterator<Self, F, T> {
        TakeWhileIterator { it: iter, fun: fun }
    }
    
    fn skip_while<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> SkipWhileIterator<Self, F, T> {
        SkipWhileIterator { it: iter, fun: fun, finished: false }
    }
    
    fn map<U, F: Callable<(T), U>>(iter: &mut Self, fun: F) -> MapIterator<Self, F, T, U> {
        MapIterator { it: iter, fun: fun }
    }
    
    fn foreach<F: Callable<(T), ()>>(iter: &mut Self, fun: F) {
        loop {
            let val = iter.next();
            if val.is_some {
                fun(val.inner);
            } else {
                break;
            }
        }
    }
    
    fn filter<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> FilterIterator<Self, F, T> {
        FilterIterator { it: iter, fun: fun }
    }
    
    fn filter_map<U, F: Callable<(T), Option<U>>>(iter: &mut Self, fun: F) -> FilterMapIterator<Self, F, T, U> {
        FilterMapIterator { it: iter, fun: fun }
    }
    
    fn reduce<U, F: Callable<(U, T), U>>(iter: &mut Self, initial: U, func: F) -> U {
        loop {
            let next = iter.next();
            if !next.is_some {
                break
            }
            initial = func(initial, next.inner);
        }
        initial
    }
    
    fn all<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> bool {
        loop {
            let next = iter.next();
            if !next.is_some {
                break
            }
            if !fun(next.inner) {
                return false
            }
        }
        true
    }
    
    fn any<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> bool {
        loop {
            let next = iter.next();
            if !next.is_some {
                break
            }
            if fun(next.inner) {
                return true
            }
        }
        false
    }

    fn to_vector(self: &mut Self) -> collections::Vector<T> {
        collections::Vector::from_iter::<T, Self>(self)
    }

    fn fill_slice(self: &mut Self, slice: &mut [T]) -> usize {
        let index = 0usize;
        loop {
            if slice.len <= index {
                break;
            }
            let next = self.next();
            if !next.is_some {
                break;
            }
            slice[index] = next.inner;
            index += 1;
        }

        index
    }

    fn peekable(self: &mut Self) -> PeekableIterator<Self, T> {
        PeekableIterator {
            it: self,
            peeked: Option::none(),
        }
    }

    
    fn group_by<F: Callable<(T), K>, K: cmp::Equatable<K>>(self: &mut Self, func: F) -> GroupByIterator<Self, F, T, K> {
        GroupByIterator {
            it: self.peekable(),
            last_group: Option::none(),    
            func: func
        }
    }
}

struct EmptyIterator<T> {}

impl EmptyIterator<T> {
    fn next(self: &mut EmptyIterator<T>) -> Option<T> {
        Option::none()
    }

    fn size_hint(self: &EmptyIterator<T>) -> Option<usize> {
        Option::some(0usize)
    }

    mixin Iterator<EmptyIterator<T>, T>;
    mixin IteratorExt<EmptyIterator<T>, T>;
}

fn empty<T>() -> EmptyIterator<T> {
    EmptyIterator::<T> {}
}

struct RepeatIterator<T> {
    value: T
}

impl RepeatIterator<T> {
    fn next(self: &mut RepeatIterator<T>) -> Option<T> {
        Option::some(self.value)
    }

    fn size_hint(self: &RepeatIterator<T>) -> Option<usize> {
        Option::some(usize::max_value())
    }

    mixin Iterator<RepeatIterator<T>, T>;
    mixin IteratorExt<RepeatIterator<T>, T>;
}

fn repeat<T>(value: T) -> RepeatIterator<T> {
    RepeatIterator { value: value }
}

struct OnceIterator<T> {
    value: Option<T>
}

impl OnceIterator<T> {
    fn next(self: &mut OnceIterator<T>) -> Option<T> {
        self.value.next()
    }

    fn size_hint(self: &OnceIterator<T>) -> Option<usize> {
        if self.value.is_some {
            Option::some(1usize)
        } else {
            Option::some(0usize)
        }
    }

    mixin Iterator<OnceIterator<T>, T>;
    mixin IteratorExt<OnceIterator<T>, T>;
}

fn once<T>(value: T) -> OnceIterator<T> {
    OnceIterator { value: Option::some(value) }
}


#[lang(range_full)]
struct RangeFull<T: Integer> {

}

#[lang(range_from)]
struct RangeFrom<T: Integer> {
    lower: T,
}

#[lang(range_to)]
struct RangeTo<T: Integer> {
    upper: T,
}

#[lang(range)]
struct Range<T: Integer> {
    lower: T,
    upper: T,
}


impl Range<T: Integer> {
    #[force_inline]
    #[lang(range_new)]
    fn new(lower: T, upper: T) -> Range<T> {
        Range {
            lower: lower,
            upper: upper,
        }
    }

    #[force_inline]
    fn iter(self: &Range<T>) -> RangeIter<T> {
        RangeIter {
            current: self.lower,
            upper: self.upper,
        }
    }

    fn len(self: &Range<T>) -> T {
        self.upper - self.lower
    }
}

impl RangeFrom<T: Integer> {
    #[force_inline]
    #[lang(range_from_new)]
    fn new(lower: T) -> RangeFrom<T> {
        RangeFrom {
            lower: lower,
        }
    }

    #[force_inline]
    fn iter(self: &RangeFrom<T>) -> RangeIter<T> {
        RangeIter {
            current: self.lower,
            upper: T::max_value(),
        }
    }

    fn len(self: &RangeFrom<T>) -> T {
        T::max_value() - self.lower
    }
}

impl RangeTo<T: Integer> {
    #[force_inline]
    #[lang(range_to_new)]
    fn new(upper: T) -> RangeTo<T> {
        RangeTo {
            upper: upper,
        }
    }

    #[force_inline]
    fn iter(self: &RangeTo<T>) -> RangeIter<T> {
        RangeIter {
            current: T::min_value(),
            upper: self.upper,
        }
    }

    fn len(self: &RangeTo<T>) -> T {
        self.upper - T::min_value()
    }
}

impl RangeFull<T: Integer> {
    #[force_inline]
    #[lang(range_full_new)]
    fn new() -> RangeFull<T> {
        RangeFull {}
    }

    #[force_inline]
    fn iter(self: &RangeFull<T>) -> RangeIter<T> {
        RangeIter {
            current: T::min_value(),
            upper: T::max_value(),
        }
    }

    fn len(self: &RangeFull<T>) -> T {
        T::max_value() - T::min_value()
    }
}

struct RangeIter<T: Integer> {
    current: T,
    upper: T,
}

impl RangeIter<T: Integer> {
    #[force_inline]
    fn next(self: &mut RangeIter<T>) -> Option<T> {
        if self.current < self.upper {
            let current = self.current;
            self.current += 1;
            Option::some(current)
        } else {
            Option::none()
        }
    }

    fn size_hint(self: &RangeIter<T>) -> Option<usize> {
        if self.current < self.upper {
            Option::some(self.upper as usize - self.current as usize)
        } else {
            Option::some(0usize)
        }
    }
    
    mixin Iterator<RangeIter<T>, T>;
    mixin IteratorExt<RangeIter<T>, T>;

}

#[force_inline]
fn range<T: Integer>(lower: T, upper: T) -> Range<T> {
    Range {
        lower: lower,
        upper: upper,
    }
}


#[cfg(all(test, test_std))]
mod tests {
    #[test]
    fn test_range() {
        let range = (0..5).iter();
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_map() {
        let range = (0..5).iter().map(|x: i32| -> i32 { x * 2 });
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(6));
        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter() {
        let range = (0..5).iter().filter(|x: i32| -> bool { x % 2 == 0 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter_map() {
        let range = (0..5).iter().filter_map(|x: i32| -> Option<i32> {
            if x % 2 == 0 {
                Option::some(x * 2)
            } else {
                Option::none()
            }
        });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_reduce() {
        let range = (0..5).iter().reduce(0, |acc: i32, x: i32| -> i32 {
            acc + x
        });
        assert_eq!(range, 10);
    }

    #[test]
    fn test_empty() {
        let range = empty::<()>();
        assert_eq!(range.size_hint(), Option::some(0usize));

        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_all() {
        assert_eq!(empty::<i32>().all(|v: i32| -> bool { v > 10 }), true)
        assert_eq!((0..5).iter().all(|v: i32| -> bool { v > 10 }), false);
        assert_eq!((0..5).iter().all(|v: i32| -> bool { v >= 0 }), true);
    }

    #[test]
    fn test_any() {
        assert_eq!(empty::<i32>().any(|v: i32| -> bool { v > 10 }), false)
        assert_eq!((0..5).iter().any(|v: i32| -> bool { v > 3 }), true);
        assert_eq!((0..5).iter().any(|v: i32| -> bool { v > 10 }), false);
    }

    #[test]
    fn test_repeat() {
        let range = repeat(1);
        assert_eq!(range.size_hint(), Option::some(usize::max_value()));

        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        // ...
    }

    #[test]
    fn test_skip() {
        let range = (0..5).iter().skip(2);
        assert_eq!(range.size_hint(), Option::some(3usize));

        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
        // ...
    }

    #[test]
    fn test_take() {
        let range = (0..5).iter().take(2);
        assert_eq!(range.size_hint(), Option::some(2usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_count() {
        assert_eq!((0..5).iter().count(), 5usize);
    }

    #[test]
    fn test_last() {
        assert_eq!((0..5).iter().last(), Option::some(4));
        assert_eq!(empty::<i32>().last(), Option::none());
    }

    #[test]
    fn test_chain() {
        let range = (0..5).iter().chain(&(10..15).iter());
        assert_eq!(range.size_hint(), Option::some(10usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(10));
        assert_eq!(range.next(), Option::some(11));
        assert_eq!(range.next(), Option::some(12));
        assert_eq!(range.next(), Option::some(13));
        assert_eq!(range.next(), Option::some(14));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_enumerate() {
        let range = (10..15).iter().enumerate();
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some((0usize, 10)));
        assert_eq!(range.next(), Option::some((1usize, 11)));
        assert_eq!(range.next(), Option::some((2usize, 12)));
        assert_eq!(range.next(), Option::some((3usize, 13)));
        assert_eq!(range.next(), Option::some((4usize, 14)));    
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_foreach() {
        let sum = 0;
        (0..5).iter().foreach(|&sum, x: i32| {
            sum += x;
        });

        assert_eq!(sum, 10);
    }

    #[test]
    fn test_inspect() {
        let sum1 = 0;
        let sum2 = 0;
        let sum3 = 0;
        let count = (0..5)
            .iter()
            .inspect(|&sum1, x: i32| { sum1 += x })
            .inspect(|&sum2, x: i32| { sum2 += x * x })
            .inspect(|&sum3, x: i32| { sum3 += x * x * x })
            .count();

        assert_eq!(sum1, 10);
        assert_eq!(sum2, 30);
        assert_eq!(sum3, 100);
    }

    #[test]
    fn test_to_vector() {
        let vec = (0..5).iter().to_vector();
        assert_eq!(vec.as_slice(), &[0, 1, 2, 3, 4]);
    }

    #[test]
    fn test_take_while() {
        let range = (0..5).iter().take_while(|x: i32| -> bool { x < 3 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_skip_while() {
        let range = (0..5).iter().skip_while(|x: i32| -> bool { x < 3 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_step_by() {
        let range = (0..5).iter().step_by(2);
        assert_eq!(range.size_hint(), Option::some(3usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_nth() {
        assert_eq!((0..5).iter().nth(0), Option::some(0));
        assert_eq!((0..5).iter().nth(1), Option::some(1));
        assert_eq!((0..5).iter().nth(10), Option::none());
    }

    #[test]
    fn test_once() {
        let range = once(0);
        assert_eq!(range.size_hint(), Option::some(1usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn fill_slice() {
        let buf: [i32; 10];
        let slice = buf.as_slice_mut();

        let written = (0..5).iter().fill_slice(slice);
        assert_eq!(written, 5);
        assert_eq!(slice[..5], &[0, 1, 2, 3, 4]);

        let written = (10..200).iter().fill_slice(slice);
        assert_eq!(written, 10);
        assert_eq!(slice, &[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);
    }

    #[test]
    fn test_peekable() {
        let range = (0..3).iter().peekable();
        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.peek(), Option::some(0));
        
        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_group_by() {
        let values: &[(i32, i32)] = &[
            (0, 0),
            (1, 0),
            (1, 1),
            (2, 0),
            (2, 1),
            (2, 2)
        ];

        let groups = values.iter().group_by(|v: (i32, i32)| -> i32 { v.0 });

        assert_eq!(groups.size_hint(), Option::none());
        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((0, 0)));
        assert_eq!(group.next(), Option::none());

        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((1, 0)));
        assert_eq!(group.next(), Option::some((1, 1)));
        assert_eq!(group.next(), Option::none());

        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((2, 0)));
        assert_eq!(group.next(), Option::some((2, 1)));
        assert_eq!(group.next(), Option::some((2, 2)));
        assert_eq!(group.next(), Option::none());

        assert!(!groups.next().is_some);
    }

    #[test]
    fn test_group_by_draining() {
        let values: &[(i32, i32)] = &[
            (0, 0),
            (1, 0),
            (1, 1),
            (2, 0),
            (2, 1),
            (2, 2)
        ];

        let groups = values.iter().group_by(|v: (i32, i32)| -> i32 { v.0 });

        assert_eq!(groups.size_hint(), Option::none());
        let group = groups.next().unwrap();
        let group = groups.next().unwrap();
        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((2, 0)));
        assert_eq!(group.next(), Option::some((2, 1)));
        assert_eq!(group.next(), Option::some((2, 2)));
        assert_eq!(group.next(), Option::none());

        assert!(!groups.next().is_some);
    }
}
