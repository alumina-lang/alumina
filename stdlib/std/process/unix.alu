use io::{Error, Pipe};
use io::unix::errno_try;

struct Command {
    _name: option::Option<&[u8]>,
    _args: &[&[u8]],
    _stdin: Stdio,
    _stdout: Stdio,
    _stderr: Stdio
}

struct Output {
    status: i32,
    stdout: collections::Vector<u8>,
    stderr: collections::Vector<u8>,
}

impl Output {
    fn move(self: &mut Output) -> Output {
        Output {
            status: self.status,
            stdout: self.stdout.move(),
            stderr: self.stderr.move()
        }
    }

    fn free(self: &mut Output) {
        self.stdout.free();
        self.stderr.free();
    }
}

struct Child {
    pid: libc::pid_t,
    stdin: option::Option<io::Pipe>,
    stdout: option::Option<io::Pipe>,
    stderr: option::Option<io::Pipe>,
}

impl Child {
    use collections::Vector;

    fn from_pid(pid: libc::pid_t) -> Child {
        Child {
            pid: pid,
            stdin: Option::none(),
            stdout: Option::none(),
            stderr: Option::none()
        }
    }

    fn wait_with_output(self: &mut Child) -> Result<Output, Error> {
        let stdin = self.stdin.move();
        if stdin.is_some {
            try!(stdin.inner.close());
        }

        let stdout : Vector<u8> = Vector::new();
        defer stdout.free();

        let stderr : Vector<u8> = Vector::new();
        defer stderr.free();

        if self.stdout.is_some && self.stderr.is_some {
            try!(std::io::read_to_end_2(
                &self.stdout.inner,
                &stdout,
                &self.stderr.inner,
                &stderr
            ));
        } else if self.stdout.is_some {
            try!(self.stdout.inner.read_to_end(&stdout));
        } else if self.stderr.is_some {
            try!(self.stderr.inner.read_to_end(&stderr));
        }

        // Close all the pipes if we were able to read them
        // to end. If any of the try!'s above bailed early, 
        // we leave them open, as it may have been something
        // transient and a retry might succeed.
        self.close();

        let status: libc::c_int = 0;
        errno_try!(libc::waitpid(self.pid, &status, 0));

        let res = Output {
            status: status as i32,
            stdout: stdout.move(),
            stderr: stderr.move()
        };

        Result::ok(res)
    }

    fn wait(self: &mut Child) -> Result<i32, Error> {
        let stdin = self.stdin.move();
        if stdin.is_some {
            try!(stdin.inner.close());
        }

        let status: libc::c_int = 0;
        errno_try!(libc::waitpid(self.pid, &status, 0));

        Result::ok(status as i32)
    }

    fn kill(self: &mut Child) -> Result<(), Error> {
        let ret = errno_try!(libc::kill(self.pid, libc::SIGKILL));
        Result::ok(())
    }

    fn close(self: &mut Child) -> Result<(), Error> {
        let stdin = self.stdin.move();
        if stdin.is_some {
            try!(stdin.inner.close());
        }

        let stdout = self.stdout.move();
        if stdout.is_some {
            try!(stdout.inner.close());
        }

        let stderr = self.stderr.move();
        if stderr.is_some {
            try!(stderr.inner.close());
        }

        Result::ok(())
    }
}

struct IoRedirection {
    kind: Stdio,
    pair: Option<(Pipe, Pipe)>
}

impl IoRedirection {
    fn new(is_stdin: bool, kind: Stdio) -> Result<IoRedirection, Error> {
        let pair: Option<(Pipe, Pipe)> = if kind == Stdio::Piped {
            let (rx, tx) = try!(Pipe::anonymous());

            if is_stdin {
                Option::some((tx, rx))
            } else {
                Option::some((rx, tx))
            }
        } else {
            Option::none()
        };

        let res = IoRedirection {
            pair: pair,
            kind: kind
        };

        Result::ok(res)
    }

    fn close(self: &mut IoRedirection) -> Result<(), Error> {
        if self.pair.is_some {
            try!(self.pair.inner.0.close());
            try!(self.pair.inner.1.close());
        } 
            
        Result::ok(())
    }

    fn install(self: &mut IoRedirection, fd: libc::c_int) -> Result<(), Error> {
        use std::io::{File, OpenOptions};

        switch self.kind {
            Stdio::Piped => {
                let (_, tgt) = self.pair.unwrap();

                errno_try!(libc::dup2(tgt.fd.value, fd));
            },
            Stdio::Null => {
                let dev_zero = try!(File::open_with("/dev/null", OpenOptions::new().read(true).write(true)));
                defer dev_zero.close();

                errno_try!(std::libc::dup2(dev_zero.fd.value, fd));
            },
            _ => {}
        };

        Result::ok(())
    }

    fn into_inner(self: &mut IoRedirection) -> Option<Pipe> {
        if self.pair.is_some {
            Option::some(self.pair.inner.0.move())
        } else {
            Option::none()
        }
    }
}

impl Command {
    use io::{File, OpenOptions};
    use ffi::CString;
    use collections::{Vector, free_all};

    fn new(name: &[u8]) -> Command {
        Command {
            _name: Option::some(name),
            _args: mem::slice::empty(),
            _stdin: Stdio::Inherit,
            _stdout: Stdio::Inherit,
            _stderr: Stdio::Inherit
        }
    }

    fn fork() -> Command {
        Command {
            _name: Option::none(),
            _args: mem::slice::empty(),
            _stdin: Stdio::Inherit,
            _stdout: Stdio::Inherit,
            _stderr: Stdio::Inherit
        }
    }

    fn args(self: &mut Command, args: &[&[u8]]) -> &mut Command {
        self._args = args;
        self
    }

    fn stdin(self: &mut Command, stdin: Stdio) -> &mut Command {
        self._stdin = stdin;
        self
    }

    fn stdout(self: &mut Command, stdout: Stdio) -> &mut Command {
        self._stdout = stdout;
        self
    }

    fn stderr(self: &mut Command, stderr: Stdio) -> &mut Command {
        self._stderr = stderr;
        self
    }

    fn _exec(self: &Command) -> Result<!, Error> {
        let name = CString::new(self._name.unwrap());
        defer name.free();

        let argv : Vector<CString> = Vector::with_capacity(self._args.len + 2);
        defer argv.free_all();

        argv.push(CString::new(self._name.unwrap()));
        for arg in self._args {
            argv.push(CString::new(arg));
        }
        argv.push(CString::null());

        errno_try!(libc::execv(name.ptr as &libc::c_char, argv.as_slice().ptr as &&libc::c_char));
        unreachable!()
    }

    fn _after_fork(
        self: &Command,
        stdin: &mut IoRedirection,
        stdout: &mut IoRedirection,
        stderr: &mut IoRedirection
    ) -> Result<(), Error> {
        try!(stdin.install(libc::STDIN_FILENO));
        try!(stdout.install(libc::STDOUT_FILENO));
        try!(stderr.install(libc::STDERR_FILENO));

        if self._name.is_some {
            try!(self._exec())
        }

        Result::ok(())
    }

    fn spawn(self: &Command) -> Result<Option<Child>, Error> {
        let stdin = try!(IoRedirection::new(true, self._stdin));
        defer stdin.close();

        let stdout = try!(IoRedirection::new(false, self._stdout));
        defer stdout.close();

        let stderr = try!(IoRedirection::new(false, self._stderr));
        defer stderr.close();

        let (fail_rx, fail_tx) = try!(Pipe::anonymous());
        defer fail_rx.close();

        let pid = errno_try!(std::libc::fork());
        if pid == 0 {
            let res = self._after_fork(&stdin, &stdout, &stderr);

            // Since we are already in the child process, we can't just bail here, we need to
            // send the error to the parent process via the pipe.
            if !res.is_ok {
                let msg = mem::slice::from_raw(&res.inner.err as &u8, mem::size_of::<Error>());
                fail_tx.write_all(msg).unwrap();
                libc::_exit(1);
            } else {
                fail_tx.close().unwrap();
            }

            // We have forked
            Result::ok(Option::none())
        } else {
            fail_tx.close().unwrap();

            let exec_err: Error;
            if fail_rx.read_exact(
                mem::slice::from_raw(&exec_err as &mut u8, mem::size_of::<Error>())
            ).is_ok {
                return Result::err(exec_err);
            }

            Result::ok(Option::some(Child {
                pid: pid,
                stdin: stdin.into_inner(),
                stdout: stdout.into_inner(),
                stderr: stderr.into_inner(),
            }))
        }
    }
}


#[cfg(test)]
mod test {
    #[test]
    fn test_spawn() {
        let child = Command::new("/bin/echo")
            .args(&["Hello, World!"])
            .stdout(Stdio::Piped)
            .stderr(Stdio::Piped)
            .spawn()
            .unwrap()
            .unwrap();

        let output = child.wait_with_output().unwrap();
        defer output.free();

        assert_eq!(output.status, 0);
        assert_eq!(output.stdout.as_slice(), "Hello, World!\n");
        assert_eq!(output.stderr.as_slice(), &[]);
    }

    #[test]
    fn spawn_fails_on_exec_failure() {
        let child = Command::new("some nonexistent program hopefully")
            .stdout(Stdio::Piped)
            .stderr(Stdio::Piped)
            .spawn();

        assert!(!child.is_ok);
        assert_eq!(child.unwrap_err().inner.errno, libc::ENOENT);
    }

    #[cfg(any(target_os = "linux"))]
    #[test]
    fn test_kill() {
        let child = Command::new("/bin/sleep")
            .args(&["10000"])
            .spawn()
            .unwrap()
            .unwrap();

        child.kill().unwrap();

        let status = child.wait().unwrap();
        assert_eq!(status, libc::SIGKILL);
    }


    #[test]
    fn test_fork() {
        let child = Command::fork()
            .stdout(Stdio::Piped)
            .stderr(Stdio::Piped)
            .spawn()
            .unwrap();

        if !child.is_some {
            print!("Hello");
            eprint!("World");
            exit(123);
        } else {
            let output = child.inner.wait_with_output().unwrap();
            defer output.free();

            assert_eq!((output.status & 0xff00) >> 8, 123);
            assert_eq!(output.stdout.as_slice(), "Hello");
            assert_eq!(output.stderr.as_slice(), "World");
        }
    }

    #[test]
    fn test_fork_starvation() {
        use fmt::repeat;

        let child = Command::fork()
            .stdout(Stdio::Piped)
            .stderr(Stdio::Piped)
            .spawn()
            .unwrap();

        if !child.is_some {
            // Write to both pipes and fill up the buffer. Naive implementation would
            // block on write eventually when the pipe capacity is reached. But our's
            // don't!
            for i in range(0, 1024) {
                print!("{}", "A".repeat(1024));
                eprint!("{}", "B".repeat(1024));
            }
            exit(123);
        } else {
            let output = child.inner.wait_with_output().unwrap();
            defer output.free();

            assert_eq!((output.status & 0xff00) >> 8, 123);
            assert_eq!(output.stdout.len(), 1024 * 1024);
            assert_eq!(output.stderr.len(), 1024 * 1024);
        }
    }
}
