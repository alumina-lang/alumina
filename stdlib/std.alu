//! This is the standard library for the Alumina language.
//! It is a collection of functions, macros, protocols and types that are essential for writing portable code. 

macro compile_fail($reason) {
    intrinsics::compile_fail($reason);
}

macro assert($cond) {
    if !$cond {
        panic!("assertion failed");
    }
}

macro assert_eq($lhs, $rhs) {
    internal::assert_eq(file!(), line!(), column!(), $lhs, $rhs);
}

macro assert_ne($lhs, $rhs) {
    internal::assert_ne(file!(), line!(), column!(), $lhs, $rhs);
}

macro debug_assert($cond) { #[cfg(debug)] assert!($cond); }
macro debug_assert_eq($lhs, $rhs) { #[cfg(debug)] assert_eq!($lhs, $rhs); }
macro debug_assert_ne($lhs, $rhs) { #[cfg(debug)] assert_ne!($lhs, $rhs); }

/// Satisy the typechecker if the code is unreachable. Note that when compiled 
/// in release mode, this will cause UB if ever reached.
macro unreachable() {
    #[cfg(debug)]
    panic!("reached unreachable code");
    #[cfg(not(debug))]
    std::intrinsics::unreachable();
}

/// Returns the line in the source code at which the macro was invoked. If used within a macro, this will return the line of the outermost invocation.
#[builtin] macro line() {  }

/// Returns the column in the source code at which the macro was invoked. If used within a macro, this will return the column of the outermost invocation.
#[builtin] macro column() {  }

/// Returns the file in the source code at which the macro was invoked. If used within a macro, this will return the file of the outermost invocation. 
#[builtin] macro file() {  }

/// Returns the value of an environment variable during compilation.
#[builtin] macro env($s) {  }

#[builtin] macro include_bytes($file) {  }
#[builtin] macro concat($parts...) {  }

macro dbg($fmt, $args...) {
    let f = panicking::internal::PanicFormatter {};
    fmt::writeln!(&f,
        concat!("[{}:{}:{}] ", $fmt),
        file!(), 
        line!(), 
        column!(),
        $args...
    )
}

mod internal {
    use panicking::internal::{panic_impl, PanicFormatter};
    use fmt::{Formattable, internal::FormatArg};

    // These are in a function instead of a macro so we can typecheck and display a nice
    // error message if the argument is Formattable.

    fn assert_eq<T>(file: &[u8], line: i32, column: i32, lhs: T, rhs: T)  {
        if !(lhs == rhs) {
            when T: Formattable<T> {
                panic_impl("assertion failed ({} != {}))", file, line, column, &[
                    FormatArg::new(&lhs),
                    FormatArg::new(&rhs)
                ])
            }
            else {
                panic_impl("assertion failed (does not equal))", file, line, column, &[])
            }

        }
    }

    fn assert_ne<T>(file: &[u8], line: i32, column: i32, lhs: T, rhs: T)  {
        if lhs == rhs {
            when T: Formattable<T> {
                panic_impl("assertion failed ({} == {}))", file, line, column, &[
                    FormatArg::new(&lhs),
                    FormatArg::new(&rhs)
                ])
            }
            else {
                panic_impl("assertion failed (equals))", file, line, column, &[])
            }
        }
    }
}

/// Contains various utility functions that are useful in the generic context where the type operated on is 
/// not easily expressible.
mod util {
    #[force_inline] fn identity<T>(t: T) -> T { t }
    #[force_inline] fn discard<T>(_: T) { }
    #[force_inline] fn cast<T1, T2>(t: T1) -> T2 { t as T2 }
    #[force_inline] fn transmute<T1, T2>(t: T1) -> T2 { *(&t as &T2) }
    #[force_inline] fn deref<T>(v: &T) -> T { *v }
}
