//! Run time glue code (program entrypoint, tests, ...)

/// Returns `true` when evaluated in a const context and `false` otherwise.
///
/// ## Example
/// ```
/// use std::runtime::in_const_context;
///
/// const IN_CONST_CONTEXT: bool = in_const_context();
///
/// assert!(IN_CONST_CONTEXT);
/// assert!(!in_const_context());
/// ```
#[inline(ir)]
fn in_const_context() -> bool {
    intrinsics::in_const_context()
}

/// Returns `true` when the argument is an expression that can be evaluated
/// at compile time.
///
/// ## Example
/// ```
/// use std::runtime::is_const_evaluable;
/// use std::libc::abort;
///
/// assert!(is_const_evaluable!(1 + 1));
/// assert!(!is_const_evaluable!(abort()));
/// ```
macro is_const_evaluable($arg) {
    intrinsics::is_const_evaluable($arg)
}

/// Forces the evaluation of the argument at compile time.
///
/// ## Example
/// ```
/// use std::runtime::const_eval;
///
/// assert_eq!(const_eval!(1 + 1), 2);
/// ```
/// ```compile_fail
/// use std::runtime::const_eval;
/// use std::libc::abort;
///
/// const_eval!(abort()); // compile error
/// ```
macro const_eval($arg) {
    intrinsics::const_eval($arg)
}

#[lang(generator)]
struct Generator<T> {
    _coro: &mut minicoro::mco_coro
}

/// A generator that yields values of type `T`.
///
/// This is the return type
impl Generator<T> {
    use internal::minicoro_check;
    use mem::size_of;

    /// @ iter::Iterator::next
    fn next(self: &mut Generator<T>) -> Option<T> {
        use minicoro::mco_state;
        minicoro::mco_resume(self._coro).minicoro_check!();

        switch minicoro::mco_status(self._coro) {
            mco_state::MCO_DEAD => {
                Option::none()
            }
            mco_state::MCO_SUSPENDED => {
                when !typing::is_zero_sized::<T>() {
                    let value: T;
                    minicoro::mco_pop(self._coro, &value as &mut (), size_of::<T>()).minicoro_check!();
                    Option::some(value)
                } else {
                    Option::some(std::util::unit::<()>())
                }
            }
            _ => unreachable!()
        }
    }

    /// @ iter::Iterator::size_hint
    fn size_hint(self: &Generator<T>) -> Option<usize> {
        Option::none()
    }

    /// Closes the generator
    ///
    /// This method can be used to gracefully close the generator early, allowing any `defer` statements
    /// in it to run.
    ///
    /// It is still necessary to call [free] to free the generator's resources after it has been closed.
    fn close(self: &mut Generator<T>) {
        switch minicoro::mco_status(self._coro) {
            minicoro::mco_state::MCO_DEAD => {}
            minicoro::mco_state::MCO_SUSPENDED => {
                self._coro.user_data = std::mem::dangling();
                minicoro::mco_resume(self._coro).minicoro_check!();
            }
        }
    }

    /// @ mem::Freeable::free
    fn free(self: &mut Generator<T>) {
        if self._coro != null {
            minicoro::mco_destroy(self._coro).minicoro_check!();
        }
    }

    // @ mem::Movable::move
    fn move(self: &mut Generator<T>) -> Generator<T> {
        let ret = *self;
        self._coro = null;
        ret
    }

    mixin iter::Iterator<Generator<T>, T>;
    mixin iter::IteratorExt<Generator<T>, T>;
}

#[cfg(not(output_type = "library"))]
mod internal {
    use builtins::{return_type_of, arguments_of, NamedFunction};
    use mem::{slice, size_of};

    macro minicoro_check($result) {
        let result = $result;
        if result != minicoro::mco_result::MCO_SUCCESS {
            panic!("{}", ffi::CString::from_raw(minicoro::mco_result_description(result))[..]);
        }
    }

    #[lang(generator_new)]
    #[inline(always)]
    fn generator_new<Func: NamedFunction, Args: builtins::Tuple, YieldType>(args: Args) -> Generator<YieldType> {
        fn _coro_entry<Fun, Args>(coro: &mut minicoro::mco_coro) {
            let f = std::util::unit::<Fun>();
            let args: Args;
            when !typing::is_zero_sized::<Args>() {
                minicoro::mco_pop(coro, &args as &mut (), size_of::<Args>()).minicoro_check!();
            }
            std::util::invoke(f, args);
        }

        let coro: &mut minicoro::mco_coro;
        minicoro::mco_create(&coro, &minicoro::mco_desc_init(
            _coro_entry::<Func, Args>,
            0
        )).minicoro_check!();

        when !typing::is_zero_sized::<YieldType>() {
            minicoro::mco_push(coro, &args as &(), size_of::<Args>()).minicoro_check!();
        }
        Generator::<YieldType> {
            _coro: coro
        }
    }

    #[lang(generator_yield)]
    #[inline(always)]
    fn generator_yield<T>(value: &T) -> bool {
        let running = minicoro::mco_running();
        when !typing::is_zero_sized::<T>() {
            minicoro::mco_push(running, value as &(), size_of::<T>()).minicoro_check!();
        }
        minicoro::mco_yield(running).minicoro_check!();
        return running.user_data == std::mem::dangling();
    }

    #[cfg(all(test))]
    {
        /// Discovered unit test cases.
        ///
        /// `test_cases()` call can be lowered at at any point during the IR lowering processed, ensure
        /// it is called during static initialization, which happens last so that all test cases will have
        /// been discovered.
        const TEST_CASES = intrinsics::test_cases();

        /// Test case metadata
        ///
        /// Contains the module path, name, attributes and the function pointer
        /// to invoke the test.
        #[lang(test_case_meta)]
        struct TestCaseMeta {
            path: &[u8],
            name: &[u8],
            attributes: &[u8],
            test: fn(),
        }

        impl TestCaseMeta {
            #[lang(test_case_meta_new)]
            #[inline(ir)]
            fn new(path: &[u8], name: &[u8], attributes: &[u8], test: fn()) -> TestCaseMeta {
                TestCaseMeta {
                    path: path,
                    name: name,
                    attributes: attributes,
                    test: test,
                }
            }
        }
    }

    /// Maximum number of program arguments that can be stack-allocated.
    ///
    /// See [allocate_args] for details.
    const STACK_ARGS_MAX: usize = 1024;

    /// Allocates the space for program arguments
    ///
    /// It allocates the memory for the slice on the stack, hence a macro. This is done to avoid
    /// a dependency on `malloc` for simple programs, but it is potentially problematic if a large
    /// number of arguments is passed as a significant portion of the stack space will be consumed.
    /// The size of the slice is `argc * sizeof(usize) * 2` as only the pointers and lengths are
    /// stored in the slice, the contents of the arguments stays in the memory region pointed to by
    /// `argv`.
    ///
    /// If number of arguments exceeds [STACK_ARGS_MAX], the function will fall back to using malloc.
    ///
    /// This is not great and probably a reason why Rust has `env::args()` instead of an argument
    /// to the `main` function, but I kind of like the C-style arguments to main, so for now this
    /// is the approach.
    macro allocate_args($argc) {
        let argc = $argc as usize;

        if argc > STACK_ARGS_MAX {
            mem::stack_alloc::<&[u8]>(argc)
        } else {
            mem::slice::alloc::<&[u8]>(argc)
        }
    }

    #[cfg(not(custom_entrypoint))]
    {
        /// Program entrypoint glue.
        ///
        /// This is equivalent to C's `main`, not `_start` as we still want to use the C runtime for
        /// invoking the static constructors.
        ///
        /// It converts the `argc` and `argv` arguments to a slice of strings, initializes the main thread
        /// associated data (if threading is enabled) and then invokes the user-defined `main` function.
        #[export]
        #[cfg_attr(target_os="macos", link_name("_main"))]
        #[cfg_attr(not(target_os="macos"), link_name("main"))]
        #[lang(entrypoint_glue)]
        fn entrypoint<UserMain: NamedFunction>(argc: libc::c_int, argv: &&libc::c_char) -> libc::c_int {
            let func = std::util::unit::<UserMain>();

            #[cfg(threading)]
            std::thread::internal::threading_init();

            let ret = when typing::matches::<arguments_of<UserMain>, (&[&[u8]])>() {
                let args = allocate_args!(argc);
                for i in 0usize..(argc as usize) {
                    #[allow(unnecessary_cast)]
                    args[i] = slice::from_raw(*(argv + i) as &u8, util::cast(libc::strlen(*(argv + i))));
                }

                func(args)
            } else when typing::matches::<arguments_of<UserMain>, ()>() {
                func()
            } else {
                compile_fail!("invalid signature for the main function")
            };


            when ret is ! {
                std::intrinsics::unreachable()
            } else when ret is void {
                libc::EXIT_SUCCESS
            } else when ret is builtins::Integer {
                ret as libc::c_int
            } else {
                compile_fail!("invalid signature for the main function")
            }
        }
    }
}


#[cfg(all(test, test_std))]
#[docs(hide)]
mod tests {
    #[test]
    fn test_in_const_context() {
        assert!(!in_const_context());
    }

    #[test]
    fn test_is_const_evaluable() {
        assert!(is_const_evaluable!(1 + 1));
        assert!(!is_const_evaluable!(libc::abort()));
    }

    #[test]
    fn test_const_eval() {
        assert_eq!(const_eval!(1 + 1), 2);
    }
}
