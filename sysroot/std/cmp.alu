//! Equality and comparison 

/// Types that can be compared for equality.
///
/// 
protocol Equatable<Self> {
    /// Returns `true` if arguments are equal, `false` otherwise
    ///
    /// See [Equatable] for details.
    fn equals(lhs: &Self, rhs: &Self) -> bool;

    /// Returns `false` if arguments are equal, `true` otherwise
    #[force_inline]
    fn not_equals(lhs: &Self, rhs: &Self) -> bool {
        !Self::equals(lhs, rhs)
    }
}

enum Ordering {
    Less = -1i8,
    Equal = 0i8,
    Greater = 1i8,
}

/// Types that have a total order.
protocol Comparable<Self: Equatable<Self>> {
    /// Compare the value
    ///
    /// See [Comparable] for details.
    fn compare(lhs: &Self, rhs: &Self) -> Ordering;
    
    /// Returns `true` if `lhs` is strictly less than `rhs`, `false` otherwise
    #[force_inline]
    fn less_than(lhs: &Self, rhs: &Self) -> bool {
        Self::compare(lhs, rhs) == Ordering::Less
    }

    /// Returns `true` if `lhs` is less or equal to `rhs`, `false` otherwise
    #[force_inline]
    fn less_than_or_equal(lhs: &Self, rhs: &Self) -> bool {
        Self::compare(lhs, rhs) != Ordering::Greater
    }

    /// Returns `true` if `lhs` strictly greater than `rhs`, `false` otherwise
    #[force_inline]
    fn greater_than(lhs: &Self, rhs: &Self) -> bool {
        Self::compare(lhs, rhs) == Ordering::Greater
    }

    /// Returns `true` if `lhs` greater than or equal `rhs`, `false` otherwise
    #[force_inline]
    fn greater_than_or_equal(lhs: &Self, rhs: &Self) -> bool {
        Self::compare(lhs, rhs) != Ordering::Less
    }
}

/// Helper macro for implementing a lexicographic order.
///
/// The macro will short-ciricuit the enclosuing function if `lhs` and `rhs` are not equal
/// and continue if they are.
///
/// # Example
/// ```
/// struct IPv4 {
///     a: u8,
///     b: u8,
///     c: u8,
///     d: u8,
/// }
/// 
/// impl IPv4 {
///     fn compare(lhs: &IPv4, rhs: &IPv4) -> Ordering {
///         lexicographic_cmp!(lhs.a, rhs.a);
///         lexicographic_cmp!(lhs.b, rhs.b);
///         lexicographic_cmp!(lhs.c, rhs.c);
///         lexicographic_cmp!(lhs.d, rhs.d);
///         Ordering::Equal
///     }
///
///     mixin Comparable<IPv4>;
/// }
/// ```
macro lexicographic_cmp($lhs, $rhs) {
    let cmp = $lhs.compare(&$rhs);
    if cmp != Ordering::Equal {
        return cmp;
    }
}

/// Returns the greater of the two arguments.
#[inline]
fn max<T: Comparable<T>>(a: T, b: T) -> T {
    if a < b {
        b
    } else {
        a
    }
}

/// Returns the least of the two arguments.
#[inline]
fn min<T: Comparable<T>>(a: T, b: T) -> T {
    if a < b {
        a
    } else {
        b
    }
}

/// This module contains the target functions for operator overloading 
mod internal {
    #[force_inline]
    #[lang(operator_eq)]
    fn operator_eq<T: Equatable<T>>(lhs: &T, rhs: &T) -> bool {
        lhs.equals(rhs)
    }

    #[force_inline]
    #[lang(operator_neq)]
    fn operator_neq<T: Equatable<T>>(lhs: &T, rhs: &T) -> bool {
        lhs.not_equals(rhs)
    }

    #[force_inline]
    #[lang(operator_lt)]
    fn operator_lt<T: Comparable<T>>(lhs: &T, rhs: &T) -> bool {
        lhs.less_than(rhs)
    }

    #[force_inline]
    #[lang(operator_lte)]
    fn operator_lte<T: Comparable<T>>(lhs: &T, rhs: &T) -> bool {
        lhs.less_than_or_equal(rhs)
    }

    #[force_inline]
    #[lang(operator_gt)]
    fn operator_gt<T: Comparable<T>>(lhs: &T, rhs: &T) -> bool {
        lhs.greater_than(rhs)
    }

    #[force_inline]
    #[lang(operator_gte)]
    fn operator_gte<T: Comparable<T>>(lhs: &T, rhs: &T) -> bool {
        lhs.greater_than_or_equal(rhs)
    }
} 

