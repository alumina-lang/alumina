//! String formatting

type Result = ::Result<(), Error>;

/// Error that can occur during a string formatting operation.
///
/// This error can signal many different things - either the value is somehow
/// invalid and cannot be formatted, or there is an I/O error if the formatter is performing
/// I/O operations.
struct Error {}

impl Error {
    fn new() -> Error {
        Error {}
    }

    fn fmt<F: Formatter<F>>(self: &Error, f: &mut F) -> Result {
        f.write_str("error occurred during formatting")
    }

    fn from<T>(_: T) -> Error {
        Error {}
    }
}


protocol Formatter<Self> {
    fn write_str(self: &mut Self, buf: &[u8]) -> Result;
    fn write_char(self: &mut Self, byte: u8) -> Result {
        self.write_str(mem::slice::from_raw(&byte, 1))
    }
}

/// Types that can be formatted.
protocol Formattable<Self, F: Formatter<F> = internal::NullFormatter> {
    fn fmt(self: &Self, f: &mut F) -> Result;
}


/// Write a formatted string into a given formatter.
/// 
/// # Example
/// ```
/// use std::fmt::{write, SliceFormatter};
/// let buf: [u8; 64];
/// let fmt = SliceFormatter::new(buf.as_slice_mut());
///     
/// write!(&fmt, "{} + {} = {}", 1, 2, 3);
/// 
/// assert_eq!(fmt.as_slice()[0..9], "1 + 2 = 3");
/// ``` 
macro write($fmt, $fmt_str, $arg...) {
    internal::printf(
        concat!($fmt_str), 
        &[internal::FormatArg::new(&$arg)...], 
        $fmt
    )
}

/// Write a formatted string and a newline into a given formatter.
macro writeln($fmt, $fmt_str, $arg...) {
    internal::printf(
        concat!($fmt_str, "\n"), 
        &[internal::FormatArg::new(&$arg)...], 
        $fmt
    )
}

/// Format a string into a `StringBuf`.
///
/// # Example
/// ```
/// use std::fmt::format;
///
/// let s: StringBuf = format!("{} + {} = {}", 1, 2, 3);
/// defer s.free()
///
/// assert_eq!(s.as_slice(), "1 + 2 = 3");
/// ```
macro format($fmt_str, $arg...) { 
    let vec = collections::Vector::with_capacity::<u8>($fmt_str.len);
    let ret = fmt::write!(&vec, $fmt_str, $arg...);
    if ret.is_ok {
        Result::ok::<string::StringBuf, Error>(vec)
    } else {
        vec.free();
        Result::err::<string::StringBuf, Error>(Error::new())
    }
}

/// Format a string into a preexisting buffer.
///
/// Returns an error if the buffer is not large enough.
///
/// # Example
/// ```
/// use std::fmt::format_in;
///
/// let buf: [u8; 64];
/// let f = format_in!(&buf, "{} + {} = {}", 1, 2, 3).unwrap();
///
/// assert_eq!(f, "1 + 2 = 3");
/// ```
macro format_in($buf, $fmt_str, $arg...) { 
    let fmt = SliceFormatter::new($buf);
    let ret = fmt::write!(&fmt, $fmt_str, $arg...);
    if ret.is_ok {
        Result::ok::<&[u8], Error>(fmt.get())
    } else {
        Result::err::<&[u8], Error>(Error::new())
    }
}

struct SliceFormatter {
    buf: &mut [u8],
    buf_pos: usize
}

impl SliceFormatter {
    fn new(buf: &mut [u8]) -> SliceFormatter {
        SliceFormatter {
            buf: buf,
            buf_pos: 0
        }
    }

    #[inline]
    fn write_str(self: &mut SliceFormatter, buf: &[u8]) -> Result {
        use mem::copy;
        if self.buf_pos + buf.len > self.buf.len {
            return Result::err(Error::new());
        }
        buf.copy(&self.buf[self.buf_pos]);
        self.buf_pos += buf.len;

        Result::ok(())
    }

    #[inline]
    fn write_char(self: &mut SliceFormatter, byte: u8) -> Result {
        if self.buf_pos >= self.buf.len {
            return Result::err(Error::new());
        }
        self.buf[self.buf_pos] = byte;
        self.buf_pos += 1;

        Result::ok(())
    }

    #[inline]
    fn get(self: &SliceFormatter) -> &[u8] {
        self.buf[..self.buf_pos]
    }
}

mod internal {
    struct NullFormatter {}
    impl NullFormatter {
        fn write_str(self: &mut NullFormatter, buf: &[u8]) -> Result {
            Result::ok(())
        }
        fn write_char(self: &mut NullFormatter, byte: u8) -> Result {
            Result::ok(())
        }
    }

    /// Type-erased wrapper of a formattable object
    struct FormatArg<F: Formatter<F>> {
        inner: &void,
        format_func: fn(&void, &mut F) -> Result
    }

    impl FormatArg {
        fn new<F: Formatter<F>, T: Formattable<T, F>>(inner: &T) -> FormatArg<F> {
            FormatArg::<F> {
                inner: inner as &void,
                format_func: |ptr: &void, fmt: &mut F| -> Result {
                    T::fmt(ptr as &T, fmt)
                }
            }
        }

        fn fmt<F: Formatter<F>>(self: &FormatArg<F>, f: &mut F) -> Result {
            self.format_func(self.inner, f)
        }
    }

    fn format_integer<T: marker::Integer, F: Formatter<F>>(val: T, radix: u16, pad: usize, fmt: &mut F) -> Result {
        assert!(radix >= 2 && radix <= 36);
        
        let buf: [u8; 128];
        let buf = buf.as_slice_mut();
        
        when T: marker::Signed {
            if val < 0 {
                fmt.write_char('-')?;
            }
        }

        let val_u = math::widening_abs(val);

        let i: usize = 0;
        loop {
            buf[buf.len - i - 1] = string::RADIX_DIGITS[(val_u % (radix as builtins::unsigned_of<T>)) as usize];
            val_u /= radix as builtins::unsigned_of<T>;
            
            if val_u == 0 {
                while i + 1 < pad {
                    fmt.write_char('0')?;
                    pad -= 1;
                }
                fmt.write_str(buf[(buf.len - i - 1)..])?;
                break;
            }
            i += 1;
        }

        Result::ok(())
    }

    fn format_float<T: marker::FloatingPoint, F: Formatter<F>>(val: T, fmt: &mut F, precision: u16) -> Result {
        // TODO: this is very very VERY bad, replace with Grisu3 or Dragon4 or alike. Correct float parsing
        // and formatting is a complicated thing. Using libc instead is an option, but that has a
        // host of other problems: locale-awareness (ideally, Alumina's stdlib is locale-invariant), 
        // use of C-strings, varargs, etc. etc.

        debug_assert!(precision <= 18);

        if val.is_nan() {
            return fmt.write_str("NaN")
        }
        if val.is_sign_negative() {
            fmt.write_char('-')?;
        }
        val = math::abs(val);

        if val.is_infinite() {
            return fmt.write_str("Inf");
        }

        let (integral, frac) = val.modf();
        
        let steps = 0usize;
        while integral >= 1.0e18 {
            integral /= 1.0e18;
            steps += 1;
        }

        let pad = 0usize;
        while steps > 0 {
            let part = integral as u64;
            format_integer(part, 10, pad, fmt)?;
            integral = (integral - (part as T)) * 1.0e18;
            steps -= 1;
            pad = 18;
        }

        let frac_i = 1u64;
        for i in 0u16..precision {
            frac *= 10.0;
            frac_i *= 10;
        }

        let rounded = (frac + 0.5) as u64;
        if rounded == frac_i {
            format_integer(integral as u64 + 1, 10, pad, fmt)?;
            fmt.write_char('.')?;
            format_integer(0, 10, precision as usize, fmt)?;
        } else {
            format_integer(integral as u64, 10, pad, fmt)?;
            fmt.write_char('.')?;
            format_integer(rounded, 10, precision as usize, fmt)?;
        }

        Result::ok(())
    }

    enum State {
        NORMAL,
        BRACE_OPEN,
        BRACE_CLOSE,
    }
    
    fn printf<F: Formatter<F>>(fmt_str: &[u8], args: &[FormatArg<F>], fmt: &mut F) -> Result {
        let i = 0usize;

        let state = State::NORMAL;
        while i < fmt_str.len {
            let ch = fmt_str[i];
            state = switch state {
                State::NORMAL => {
                    switch ch {
                        '{' => State::BRACE_OPEN,
                        '}' => State::BRACE_CLOSE,
                        _ => {
                            fmt.write_char(ch)?;
                            State::NORMAL
                        }
                    }
                }
                State::BRACE_CLOSE => {
                    switch ch {
                        '}' => fmt.write_char(ch)?,
                        _ => panic!("invalid format string {}", fmt_str)
                    };
                    State::NORMAL
                }
                State::BRACE_OPEN => {
                    switch ch {
                        '}' => {
                            if args.len == 0 {
                                panic!("too few arguments");
                            }
                            args[0].fmt(fmt)?;
                            args = args[1..];
                        },
                        '{' => fmt.write_char(ch)?,
                        _ => panic!("invalid format string {}", fmt_str)
                    };
                    State::NORMAL
                }
                _ => std::intrinsics::unreachable()
            };
            i += 1;
        }

        if state != State::NORMAL {
            panic!("invalid format string {}", fmt_str);
        }

        if args.len > 0 {
            panic!("too many arguments");
        }

        Result::ok(())
    }

    struct NumFormatAdapter<T: marker::Integer> {
        radix: u16,
        _pad: usize,
        value: T
    }

    impl NumFormatAdapter<T: marker::Integer> {
        fn fmt<F: Formatter<F>>(self: &NumFormatAdapter<T>, fmt: &mut F) -> Result {
            format_integer(self.value, self.radix, self._pad, fmt)
        }

        fn hex(self: NumFormatAdapter<T>) -> NumFormatAdapter<T> {
            NumFormatAdapter { radix: 16, _pad: self._pad, value: self.value }
        }

        fn oct(self: NumFormatAdapter<T>) -> NumFormatAdapter<T> {
            NumFormatAdapter { radix: 8, _pad: self._pad, value: self.value }
        }

        fn bin(self: NumFormatAdapter<T>) -> NumFormatAdapter<T> {
            NumFormatAdapter { radix: 2, _pad: self._pad, value: self.value }
        }

        fn zero_pad(self: NumFormatAdapter<T>, pad: usize) -> NumFormatAdapter<T> {
            NumFormatAdapter { radix: self.radix, _pad: pad, value: self.value }
        }
    }

    struct FloatFormatAdapter<T: marker::FloatingPoint> {
        precision: u16,
        value: T
    }

    impl FloatFormatAdapter<T: marker::FloatingPoint> {
        fn fmt<F: Formatter<F>>(self: &FloatFormatAdapter<T>, fmt: &mut F) -> Result {
            format_float::<T, F>(self.value, fmt, self.precision)
        }
    }

    struct RepeatAdapter<T: Formattable<T>> {
        times: usize,
        inner: T
    }

    impl RepeatAdapter {
        fn fmt<T: Formattable<T, F>, F: Formatter<F>>(self: &RepeatAdapter<T>, fmt: &mut F) -> Result {
            for i in 0usize..self.times {
                self.inner.fmt(fmt)?;
            }
            Result::ok(())
        }
    }

    struct GenericPadAdapter<T: Formattable<T>> {
        len: usize,
        pad: u8,
        inner: T
    }

    impl GenericPadAdapter {
        fn fmt<T: Formattable<T, F>, F: Formatter<F>>(self: &GenericPadAdapter<T>, fmt: &mut F) -> Result {
            let buf: [u8; 32];
            let res = format_in!(&buf, "{}", self.inner);
            let s = if res.is_ok {
                res.inner.ok
            } else {
                // We fall back to the heap-allocating variant if the stack buffer was not large enough.
                let res = format!("{}", self.inner)?;
                defer res.free();
                res.as_slice()
            };

            if s.len < self.len {
                for _ in (0usize..self.len - s.len) {
                    fmt.write_char(self.pad)?;
                }
            }
            fmt.write_str(s)
        }
    }
}

fn hex<T: marker::Integer>(val: T) -> internal::NumFormatAdapter<T> {
    internal::NumFormatAdapter { radix: 16, _pad: 0, value: val }
}

fn bin<T: marker::Integer>(val: T) -> internal::NumFormatAdapter<T> {
    internal::NumFormatAdapter { radix: 2, _pad: 0, value: val }
}

fn oct<T: marker::Integer>(val: T) -> internal::NumFormatAdapter<T> {
    internal::NumFormatAdapter { radix: 8, _pad: 0, value: val }
}

fn zero_pad<T: marker::Integer>(val: T, pad: usize) -> internal::NumFormatAdapter<T> {
    internal::NumFormatAdapter { radix: 10, _pad: pad, value: val }
}

fn precision<T: marker::FloatingPoint>(val: T, prec: u16) -> internal::FloatFormatAdapter<T> {
    internal::FloatFormatAdapter { precision: prec, value: val }
}

fn repeat<T: Formattable<T>>(inner: T, times: usize) -> internal::RepeatAdapter<T> {
    internal::RepeatAdapter { times: times, inner: inner }
}

fn pad_with<T: Formattable<T>>(val: T, len: usize, pad: u8) -> internal::GenericPadAdapter<T> {
    internal::GenericPadAdapter { len: len, pad: pad, inner: val }
}


#[cfg(all(test, test_std))]
mod tests {
    static BUF: [u8; 1024];

    macro fmt($args...) {
        format_in!(&BUF, $args...).unwrap()
    }
    
    #[test]
    fn test_format_integer() {
        assert_eq!(fmt!("{}", u8::max_value()), "255");
        assert_eq!(fmt!("{}", -23847), "-23847");
        assert_eq!(fmt!("{}", i64::min_value()), "-9223372036854775808");
        assert_eq!(
            fmt!("{}", i128::min_value()), 
            "-170141183460469231731687303715884105728"
        );
    }

    #[test]
    fn test_format_radix() {
        assert_eq!(fmt!("{}", 255u32.hex()), "ff");
        assert_eq!(fmt!("{}", 255u32.bin()), "11111111");
        assert_eq!(fmt!("{}", 255u32.oct()), "377");
    }

    #[test]
    fn test_format_zero_pad() {
        assert_eq!(fmt!("{}", 255u32.zero_pad(4)), "0255");
        assert_eq!(fmt!("{}", 255u32.zero_pad(8)), "00000255");
    }

    #[test]
    fn test_format_radix_and_pad() {
        assert_eq!(fmt!("{}", 15u8.zero_pad(2).hex()), "0f");
        assert_eq!(fmt!("{}", 15u8.hex().zero_pad(2)), "0f");
    }

    #[test]
    fn test_format_repeat() {
        assert_eq!(fmt!("{}", "world".repeat(3)), "worldworldworld");
    }

    #[test]
    fn test_format_float() {
        // These tests do not assert that float formatting logic is correct. It is in fact
        // very incorrect.
        
        assert_eq!(fmt!("{}", f64::nan()), "NaN");
        assert_eq!(fmt!("{}", f64::infinity()), "Inf");
        assert_eq!(fmt!("{}", f64::neg_infinity()), "-Inf");

        assert_eq!(fmt!("{}", 0.0), "0.000000000000000");
        assert_eq!(fmt!("{}", -0.0), "-0.000000000000000");

        assert_eq!(fmt!("{}", 0.1.precision(5)), "0.10000");
        assert_eq!(fmt!("{}", 0.01.precision(5)), "0.01000");
        assert_eq!(fmt!("{}", 0.001.precision(5)), "0.00100");
        assert_eq!(fmt!("{}", 0.0001.precision(5)), "0.00010");
        assert_eq!(fmt!("{}", 0.00001.precision(5)), "0.00001");
        assert_eq!(fmt!("{}", 0.000001.precision(5)), "0.00000");
        
        assert_eq!(fmt!("{}", 1.0.precision(1)), "1.0");
        assert_eq!(fmt!("{}", 11.0.precision(1)), "11.0");
        assert_eq!(fmt!("{}", 111.0.precision(1)), "111.0");
        assert_eq!(fmt!("{}", 1111.0.precision(1)), "1111.0");
        assert_eq!(fmt!("{}", 11111.0.precision(1)), "11111.0");
        assert_eq!(fmt!("{}", 111111.0.precision(1)), "111111.0");
        assert_eq!(fmt!("{}", 1111111.0.precision(1)), "1111111.0");
        assert_eq!(fmt!("{}", 11111111.0.precision(1)), "11111111.0");
        assert_eq!(fmt!("{}", 111111111.0.precision(1)), "111111111.0");
        assert_eq!(fmt!("{}", 1111111111.0.precision(1)), "1111111111.0");
        assert_eq!(fmt!("{}", 11111111111.0.precision(1)), "11111111111.0");
        assert_eq!(fmt!("{}", 111111111111.0.precision(1)), "111111111111.0");
        assert_eq!(fmt!("{}", 1111111111111.0.precision(1)), "1111111111111.0");
        assert_eq!(fmt!("{}", 11111111111111.0.precision(1)), "11111111111111.0");
        assert_eq!(fmt!("{}", 111111111111111.0.precision(1)), "111111111111111.0");
        assert_eq!(fmt!("{}", 1111111111111111.0.precision(1)), "1111111111111111.0");
        
        assert_eq!(fmt!("{}", 10.0.precision(1)), "10.0");
        assert_eq!(fmt!("{}", 100.0.precision(1)), "100.0");
        assert_eq!(fmt!("{}", 1000.0.precision(1)), "1000.0");
        assert_eq!(fmt!("{}", 10000.0.precision(1)), "10000.0");
        assert_eq!(fmt!("{}", 100000.0.precision(1)), "100000.0");
        assert_eq!(fmt!("{}", 1000000.0.precision(1)), "1000000.0");
        assert_eq!(fmt!("{}", 10000000.0.precision(1)), "10000000.0");
        assert_eq!(fmt!("{}", 100000000.0.precision(1)), "100000000.0");
        assert_eq!(fmt!("{}", 1000000000.0.precision(1)), "1000000000.0");
        assert_eq!(fmt!("{}", 10000000000.0.precision(1)), "10000000000.0");
        assert_eq!(fmt!("{}", 100000000000.0.precision(1)), "100000000000.0");
        assert_eq!(fmt!("{}", 1000000000000.0.precision(1)), "1000000000000.0");
        assert_eq!(fmt!("{}", 10000000000000.0.precision(1)), "10000000000000.0");
        assert_eq!(fmt!("{}", 100000000000000.0.precision(1)), "100000000000000.0");
        assert_eq!(fmt!("{}", 1000000000000000.0.precision(1)), "1000000000000000.0");
        assert_eq!(fmt!("{}", 10000000000000000.0.precision(1)), "10000000000000000.0");
        assert_eq!(fmt!("{}", 100000000000000000.0.precision(1)), "100000000000000000.0");
        assert_eq!(fmt!("{}", 1000000000000000000.0.precision(1)), "1000000000000000000.0");
        assert_eq!(fmt!("{}", 10000000000000000000.0.precision(1)), "10000000000000000000.0");

        assert_eq!(fmt!("{}", 9.0.precision(1)), "9.0");
        assert_eq!(fmt!("{}", 99.0.precision(1)), "99.0");
        assert_eq!(fmt!("{}", 999.0.precision(1)), "999.0");
        assert_eq!(fmt!("{}", 9999.0.precision(1)), "9999.0");
        assert_eq!(fmt!("{}", 99999.0.precision(1)), "99999.0");
        assert_eq!(fmt!("{}", 999999.0.precision(1)), "999999.0");
        assert_eq!(fmt!("{}", 9999999.0.precision(1)), "9999999.0");
        assert_eq!(fmt!("{}", 99999999.0.precision(1)), "99999999.0");
        assert_eq!(fmt!("{}", 999999999.0.precision(1)), "999999999.0");
        assert_eq!(fmt!("{}", 9999999999.0.precision(1)), "9999999999.0");
        assert_eq!(fmt!("{}", 99999999999.0.precision(1)), "99999999999.0");
        assert_eq!(fmt!("{}", 999999999999.0.precision(1)), "999999999999.0");
        assert_eq!(fmt!("{}", 9999999999999.0.precision(1)), "9999999999999.0");
        assert_eq!(fmt!("{}", 99999999999999.0.precision(1)), "99999999999999.0");
        assert_eq!(fmt!("{}", 999999999999999.0.precision(1)), "999999999999999.0"); 

    }
}
