//! Regular expression matching with DFA-based engine
//!
//! This module provides a deterministic finite automaton (DFA) based regular expression
//! engine with support for Unicode, capture groups, and anchors. The implementation uses
//! Thompson's NFA construction followed by subset construction to build an efficient DFA.
//!
//! ## Supported Features
//!
//! - **Literals**: `abc`, Unicode characters
//! - **Character classes**: `[a-z]`, `[^0-9]`, `[Î±-Ï‰]`
//! - **Predefined classes**: `\d` (digits), `\w` (word), `\s` (whitespace), `.` (any except newline)
//! - **Quantifiers**: `*` (zero or more), `+` (one or more), `?` (zero or one)
//! - **Bounded repetition**: `{n}`, `{n,}`, `{n,m}`
//! - **Alternation**: `foo|bar`
//! - **Grouping**: `(foo)` capturing, `(?:foo)` non-capturing
//! - **Anchors**: `^` (start of string), `$` (end of string)
//! - **Escape sequences**: `\t`, `\n`, `\r`, `\xHH`, `\uHHHH`
//!
//! ## Limitations
//!
//! - No backreferences (this is a regular language engine)
//! - No lookahead/lookbehind assertions
//! - No word boundaries (`\b`, `\B`)
//! - No Unicode property classes
//!
//! ## Examples
//!
//! ### Basic matching
//!
//! ```
//! use std::regex::Regex;
//!
//! let re = Regex::compile("hello").unwrap();
//! defer re.free();
//!
//! assert!(re.is_match("hello world"));
//! assert!(!re.is_match("goodbye"));
//! ```
//!
//! ### Character classes and quantifiers
//!
//! ```
//! use std::regex::Regex;
//!
//! let re = Regex::compile("[0-9]+").unwrap();
//! defer re.free();
//!
//! assert!(re.is_match("123"));
//! assert!(!re.is_match("abc"));
//! ```
//!
//! ### Capture groups
//!
//! ```
//! use std::regex::Regex;
//!
//! let re = Regex::compile("(\\w+)@(\\w+\\.\\w+)").unwrap();
//! defer re.free();
//!
//! let caps = re.captures("user@example.com");
//! assert!(caps.is_some());
//! let caps = caps.unwrap();
//! defer caps.free();
//!
//! assert_eq!(caps.get(1).unwrap(), "user");
//! assert_eq!(caps.get(2).unwrap(), "example.com");
//! ```
//!
//! ### Anchors
//!
//! ```
//! use std::regex::Regex;
//!
//! let re = Regex::compile("^start").unwrap();
//! defer re.free();
//!
//! assert!(re.is_match("start of line"));
//! assert!(!re.is_match("not at start"));
//! ```

use internal::{
    RegexParser, thompson_construct, Nfa, Dfa
};
use collections::Vector;

struct Regex {
    dfa: Dfa,
    num_groups: usize,     // Number of capture groups (including group 0)
}

impl Regex {
    /// Compile a regex pattern
    fn compile(pattern: &[u8]) -> Result<Regex, ()> {
        // Parse the pattern
        let parser = RegexParser::new(pattern);
        let ast = parser.parse();
        if ast.is_err() {
            return Result::err(());
        }
        let ast = ast.unwrap();
        defer ast.free();

        // Capture the number of groups (next_group_id is one past the last group)
        let num_groups = parser.next_group_id;

        // Build NFA using Thompson construction
        let nfa = Nfa::new();
        let frag = thompson_construct(&ast, &nfa);

        // Set the NFA start state
        nfa.start = frag.start;

        // Convert NFA to DFA
        let dfa = Dfa::from_nfa(&nfa);
        nfa.free();

        Result::ok(Regex {
            dfa: dfa,
            num_groups: num_groups,
        })
    }

    /// Check if the entire text matches the pattern
    fn is_match(self: &Regex, text: &[u8]) -> bool {
        self.dfa.is_match(text)
    }

    /// Find the first match in the text
    /// Returns (start_pos, end_pos) if found
    fn find(self: &Regex, text: &[u8]) -> Option<(usize, usize)> {
        self.dfa.find(text)
    }

    /// Check if text matches from the beginning
    fn match_from_start(self: &Regex, text: &[u8]) -> bool {
        let result = self.dfa.match_from(text, 0);
        result.is_some() && result.unwrap() > 0
    }

    /// Find first match and return capture groups
    fn captures(self: &Regex, text: &[u8]) -> Option<Captures> {
        // Calculate number of tags needed (2 per group: start and end)
        let num_tags = self.num_groups * 2usize;

        // Try matching at each position
        for start_pos in 0usize..text.len() + 1 {
            let result = self.dfa.match_with_captures(text, start_pos, num_tags);
            if result.is_none() {
                continue;
            }

            let (end_pos, tag_positions) = result.unwrap();

            // Build Captures object
            let captures = Captures::new(text, self.num_groups);

            // Set group 0 (full match)
            captures.positions[0] = Option::some((start_pos, end_pos));

            // Set user groups from tag positions
            for group_id in 1usize..self.num_groups {
                let start_tag = 2usize * group_id;
                let end_tag = 2usize * group_id + 1usize;
                let group_start = tag_positions[start_tag];
                let group_end = tag_positions[end_tag];
                captures.positions[group_id] = Option::some((group_start, group_end));
            }

            tag_positions.free();
            return Option::some(captures);
        }

        Option::none()
    }

    fn move(self: &mut Regex) -> Regex {
        let ret = *self;
        self.dfa = Dfa::new();
        ret
    }

    fn free(self: &mut Regex) {
        self.dfa.free();
    }
}

/// Capture groups from a regex match
/// Contains the matched text and positions of capture groups
struct Captures {
    /// The matched text (borrowed)
    text: &[u8],
    /// Start and end positions for each capture group
    /// Group 0 is the full match, groups 1+ are user groups
    /// `positions[i] = (start, end)` for group `i`
    positions: Vector<Option<(usize, usize)>>,
}

impl Captures {
    /// Create a new Captures with the given number of groups
    fn new(text: &[u8], num_groups: usize) -> Captures {
        let positions: Vector<Option<(usize, usize)>> = Vector::new();
        // Initialize with None for all groups
        for _ in 0usize..num_groups {
            positions.push(Option::none());
        }
        Captures {
            text: text,
            positions: positions,
        }
    }

    /// Get the full matched text (capture group 0)
    fn get_match(self: &Captures) -> Option<&[u8]> {
        if self.positions.is_empty() {
            return Option::none();
        }
        let pos = &self.positions[0];
        if pos.is_none() {
            return Option::none();
        }
        let (start, end) = pos.unwrap();
        Option::some(self.text[start..end])
    }

    /// Get a capture group by index (0 = full match, 1+ = user groups)
    fn get(self: &Captures, group: usize) -> Option<&[u8]> {
        if group >= self.positions.len() {
            return Option::none();
        }
        let pos = &self.positions[group];
        if pos.is_none() {
            return Option::none();
        }
        let (start, end) = pos.unwrap();
        Option::some(self.text[start..end])
    }

    /// Get the start and end positions of a capture group
    fn get_pos(self: &Captures, group: usize) -> Option<(usize, usize)> {
        if group >= self.positions.len() {
            return Option::none();
        }
        self.positions[group]
    }

    /// Get the number of capture groups (including group 0 for full match)
    fn len(self: &Captures) -> usize {
        self.positions.len()
    }

    fn move(self: &mut Captures) -> Captures {
        let ret = *self;
        self.positions = Vector::new();
        ret
    }

    fn free(self: &mut Captures) {
        self.positions.free();
    }
}


#[cfg(all(test, test_std))]
#[docs(hide)]
mod tests {
    use internal::{IntervalSet, Nfa, Dfa, DfaState, DfaTransition};
    use string::unicode;
    use collections::Vector;

    #[test]
    fn test_interval_single() {
        let set = IntervalSet::single('a' as u32);
        defer set.free();
        assert!(set.contains('a' as u32));
        assert!(!set.contains('b' as u32));
    }

    #[test]
    fn test_interval_range() {
        let set = IntervalSet::range('a' as u32, 'z' as u32);
        defer set.free();
        assert!(set.contains('a' as u32));
        assert!(set.contains('m' as u32));
        assert!(set.contains('z' as u32));
        assert!(!set.contains('A' as u32));
        assert!(!set.contains('0' as u32));
    }

    #[test]
    fn test_interval_add_and_merge() {
        let set = IntervalSet::new();
        defer set.free();
        set.add_interval('a' as u32, 'c' as u32);
        set.add_interval('e' as u32, 'g' as u32);
        set.add_interval('b' as u32, 'f' as u32); // Overlaps both

        assert_eq!(set.intervals.len(), 1);
        assert_eq!(set.intervals[0].start, 'a' as u32);
        assert_eq!(set.intervals[0].end, 'g' as u32);
    }

    #[test]
    fn test_interval_negate() {
        let set = IntervalSet::range('a' as u32, 'z' as u32);
        defer set.free();
        let negated = set.negate();
        defer negated.free();

        assert!(!negated.contains('a' as u32));
        assert!(!negated.contains('m' as u32));
        assert!(!negated.contains('z' as u32));
        assert!(negated.contains('A' as u32));
        assert!(negated.contains('0' as u32));
        assert!(negated.contains(0));
        assert!(negated.contains(0x10FFFF));
    }

    #[test]
    fn test_interval_union() {
        let set1 = IntervalSet::range('a' as u32, 'z' as u32);
        defer set1.free();
        let set2 = IntervalSet::range('A' as u32, 'Z' as u32);
        defer set2.free();
        let union = set1.union(&set2);
        defer union.free();

        assert!(union.contains('a' as u32));
        assert!(union.contains('Z' as u32));
        assert!(!union.contains('0' as u32));
        assert_eq!(union.intervals.len(), 2);
    }

    #[test]
    fn test_nfa_basic() {
        // Build simple NFA: start --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let end_state = nfa.add_state(true);

        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(nfa.start, end_state, chars);

        assert_eq!(nfa.states.len(), 2);
        assert_eq!(nfa.states[0].transitions.len(), 1);
        assert!(nfa.states[1].is_final);
    }

    #[test]
    fn test_nfa_epsilon() {
        // Build NFA with epsilon transition
        let nfa = Nfa::new();
        defer nfa.free();
        let middle = nfa.add_state(false);
        let end_state = nfa.add_state(true);

        nfa.add_epsilon(nfa.start, middle);

        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(middle, end_state, chars);

        assert_eq!(nfa.states.len(), 3);
        assert!(nfa.states[0].transitions[0].on_chars.is_none());
    }

    #[test]
    fn test_nfa_to_dfa() {
        // Build simple NFA: start --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let end_state = nfa.add_state(true);
        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(nfa.start, end_state, chars);

        // Convert to DFA
        let dfa = Dfa::from_nfa(&nfa);
        defer dfa.free();

        // Test matching
        assert!(dfa.is_match("a"));
        assert!(dfa.is_match("xax"));
        assert!(!dfa.is_match("b"));
        assert!(!dfa.is_match(""));
    }

    #[test]
    fn test_nfa_to_dfa_with_epsilon() {
        // Build NFA with epsilon: start -Îµ-> middle --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let middle = nfa.add_state(false);
        let end_state = nfa.add_state(true);

        nfa.add_epsilon(nfa.start, middle);
        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(middle, end_state, chars);

        // Convert to DFA
        let dfa = Dfa::from_nfa(&nfa);
        defer dfa.free();

        // Test matching - epsilon should be transparent
        assert!(dfa.is_match("a"));
        assert!(dfa.is_match("ba"));
        assert!(!dfa.is_match("b"));
    }

    #[test]
    fn test_utf8_decode() {
        // Test ASCII
        let result = unicode::decode_utf8("a");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 'a' as u32);
        assert_eq!(result.unwrap().1, 1usize);

        // Test 2-byte (Ã± = U+00F1)
        let result = unicode::decode_utf8("Ã±");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0xF1u32);
        assert_eq!(result.unwrap().1, 2usize);

        // Test 3-byte (â‚¬ = U+20AC)
        let result = unicode::decode_utf8("â‚¬");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0x20ACu32);
        assert_eq!(result.unwrap().1, 3usize);

        // Test 4-byte (ğ”¸ = U+1D538)
        let result = unicode::decode_utf8("ğ”¸");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0x1D538u32);
        assert_eq!(result.unwrap().1, 4usize);
    }

    #[test]
    fn test_dfa_simple_match() {
        // Manually build a DFA that matches "ab"
        let dfa = Dfa::new();
        defer dfa.free();

        // State 0 (start) --'a'--> State 1
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: false,
            entry_tags: Vector::new(),
        });

        // State 1 --'b'--> State 2
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: false,
            entry_tags: Vector::new(),
        });

        // State 2 (final)
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: true,
            entry_tags: Vector::new(),
        });

        // Add transitions
        dfa.states[0].transitions.push(DfaTransition {
            chars: IntervalSet::single('a' as u32),
            to: 1,
            tags: Vector::new(),
        });

        dfa.states[1].transitions.push(DfaTransition {
            chars: IntervalSet::single('b' as u32),
            to: 2,
            tags: Vector::new(),
        });

        // Test matching
        assert!(dfa.is_match("ab"));
        assert!(dfa.is_match("xabx"));
        assert!(!dfa.is_match("ac"));
        assert!(!dfa.is_match("a"));
    }

    #[test]
    fn test_regex_literal() {
        let re = Regex::compile("abc");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("xabcy"));
        assert!(!re.is_match("ab"));
        assert!(!re.is_match("abx"));
    }

    #[test]
    fn test_regex_alternation() {
        let re = Regex::compile("cat|dog");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("cat"));
        assert!(re.is_match("dog"));
        assert!(re.is_match("the cat"));
        assert!(!re.is_match("bird"));
    }

    #[test]
    fn test_regex_star() {
        let re = Regex::compile("ab*c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ac"));       // zero b's
        assert!(re.is_match("abc"));      // one b
        assert!(re.is_match("abbc"));     // two b's
        assert!(re.is_match("abbbbbc"));  // many b's
        assert!(!re.is_match("ab"));      // no c
    }

    #[test]
    fn test_regex_plus() {
        let re = Regex::compile("ab+c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(!re.is_match("ac"));      // zero b's - should fail
        assert!(re.is_match("abc"));      // one b
        assert!(re.is_match("abbc"));     // two b's
        assert!(re.is_match("abbbbbc"));  // many b's
    }

    #[test]
    fn test_regex_question() {
        let re = Regex::compile("ab?c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ac"));       // zero b's
        assert!(re.is_match("abc"));      // one b
        assert!(!re.is_match("abbc"));    // two b's - should fail
    }

    #[test]
    fn test_regex_dot() {
        let re = Regex::compile("a.c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("a-c"));
        assert!(re.is_match("a c"));
        assert!(!re.is_match("ac"));      // needs something between
    }

    #[test]
    fn test_regex_char_class() {
        let re = Regex::compile("[abc]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("a"));
        assert!(re.is_match("b"));
        assert!(re.is_match("c"));
        assert!(!re.is_match("d"));
    }

    #[test]
    fn test_regex_char_range() {
        let re = Regex::compile("[a-z]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("world"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("test123"));  // contains lowercase
    }

    #[test]
    fn test_regex_negated_class() {
        let re = Regex::compile("[^0-9]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("abc123"));   // starts with non-digits
    }

    #[test]
    fn test_regex_groups() {
        let re = Regex::compile("(ab)+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ab"));
        assert!(re.is_match("abab"));
        assert!(re.is_match("ababab"));
        assert!(re.is_match("abc"));       // contains "ab"
        assert!(!re.is_match("a"));
        assert!(!re.is_match("ba"));       // doesn't contain "ab"
    }

    #[test]
    fn test_regex_complex() {
        let re = Regex::compile("(a|b)*c+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("c"));
        assert!(re.is_match("ac"));
        assert!(re.is_match("bc"));
        assert!(re.is_match("aaabbbccc"));
        assert!(!re.is_match("ab"));      // no c
    }

    #[test]
    fn test_regex_escape() {
        let re = Regex::compile("\\(test\\)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("(test)"));
        assert!(!re.is_match("test"));
    }

    #[test]
    fn test_regex_digit_class() {
        let re = Regex::compile("\\d+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("0"));
        assert!(re.is_match("abc123"));
        assert!(!re.is_match("abc"));
    }

    #[test]
    fn test_regex_non_digit_class() {
        let re = Regex::compile("\\D+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("hello"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("123abc"));  // contains non-digits
    }

    #[test]
    fn test_regex_word_class() {
        let re = Regex::compile("\\w+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("test_123"));
        assert!(re.is_match("ABC"));
        assert!(!re.is_match("!!!"));
        assert!(re.is_match("hello!!!"));  // contains word chars
    }

    #[test]
    fn test_regex_non_word_class() {
        let re = Regex::compile("\\W+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("!!!"));
        assert!(re.is_match("   "));
        assert!(!re.is_match("hello"));
        assert!(re.is_match("hello world"));  // contains space
    }

    #[test]
    fn test_regex_whitespace_class() {
        let re = Regex::compile("\\s+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match(" "));
        assert!(re.is_match("\t"));
        assert!(re.is_match("\n"));
        assert!(re.is_match("   "));
        assert!(!re.is_match("abc"));
        assert!(re.is_match("hello world"));  // contains space
    }

    #[test]
    fn test_regex_non_whitespace_class() {
        let re = Regex::compile("\\S+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("123"));
        assert!(!re.is_match("   "));
        assert!(re.is_match("   hello"));  // contains non-whitespace
    }

    #[test]
    fn test_regex_start_anchor() {
        let re = Regex::compile("^hello");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("hello world"));
        assert!(!re.is_match("say hello"));
        assert!(!re.is_match(" hello"));
    }

    #[test]
    fn test_regex_end_anchor() {
        let re = Regex::compile("world$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("world"));
        assert!(re.is_match("hello world"));
        assert!(!re.is_match("world!"));
        assert!(!re.is_match("world "));
    }

    #[test]
    fn test_regex_both_anchors() {
        let re = Regex::compile("^hello$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(!re.is_match("hello world"));
        assert!(!re.is_match("say hello"));
        assert!(!re.is_match(" hello "));
    }

    #[test]
    fn test_regex_anchor_with_pattern() {
        let re = Regex::compile("^\\d+$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("0"));
        assert!(!re.is_match("123abc"));
        assert!(!re.is_match("abc123"));
        assert!(!re.is_match(" 123 "));
    }

    #[test]
    fn test_regex_anchor_in_alternation() {
        // Anchor at start with grouped alternation
        let re = Regex::compile("^(foo|bar)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("foo"));
        assert!(re.is_match("foobar"));     // Matches ^foo
        assert!(re.is_match("bar"));         // Matches ^bar
        assert!(re.is_match("barfoo"));      // Matches ^bar
        assert!(!re.is_match("xfoo"));       // Requires start
        assert!(!re.is_match("xbar"));       // Requires start

        // Anchor at end with grouped alternation
        let re2 = Regex::compile("(foo|bar)$");
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();

        assert!(re2.is_match("foo"));
        assert!(re2.is_match("xfoo"));       // Matches foo$
        assert!(re2.is_match("bar"));        // Matches bar$
        assert!(re2.is_match("xbar"));       // Matches bar$
        assert!(!re2.is_match("foox"));      // Requires end
        assert!(!re2.is_match("barx"));      // Requires end
    }

    #[test]
    fn test_regex_anchor_in_group() {
        // Anchor inside parentheses
        let re = Regex::compile("^foo(bar|$)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("foo"));        // Matches ^foo followed by $
        assert!(re.is_match("foobar"));     // Matches ^foo followed by bar
        assert!(!re.is_match("foobaz"));    // Doesn't match bar or $
        assert!(!re.is_match("barfoo"));    // Doesn't start with foo
        assert!(!re.is_match("xfoo"));      // Doesn't start with ^
    }

    #[test]
    fn test_regex_anchor_multiple_in_pattern() {
        // Multiple anchors in complex patterns
        let re = Regex::compile("^(start|$)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match(""));           // Matches ^$
        assert!(re.is_match("start"));      // Matches ^start
        assert!(re.is_match("startx"));     // Matches ^start
        assert!(!re.is_match("xstart"));    // Doesn't start with start

        // Anchor at end inside group
        let re2 = Regex::compile("foo(bar$|baz)");
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();

        assert!(re2.is_match("foobar"));    // Matches foobar$
        assert!(re2.is_match("foobaz"));    // Matches foobaz
        assert!(re2.is_match("xfoobaz"));   // Matches foobaz anywhere
        assert!(re2.is_match("xfoobar"));   // Matches foobar$ at end
        assert!(!re2.is_match("foobarx"));  // bar$ requires end of string
        assert!(re2.is_match("foobazx"));   // Matches foobaz (baz alternative)
    }

    #[test]
    fn test_regex_escaped_anchor() {
        // Escaped anchors should match literal characters
        let re = Regex::compile("\\^foo");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("^foo"));
        assert!(!re.is_match("foo"));
        assert!(re.is_match("x^foo"));      // Can match anywhere

        let re2 = Regex::compile("foo\\$");
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();

        assert!(re2.is_match("foo$"));
        assert!(!re2.is_match("foo"));
        assert!(re2.is_match("foo$x"));     // Can match anywhere
    }

    #[test]
    fn test_regex_anchor_with_quantifiers() {
        // Anchors with quantifiers
        let re = Regex::compile("^a+$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("a"));
        assert!(re.is_match("aaa"));
        assert!(!re.is_match(""));
        assert!(!re.is_match("ab"));
        assert!(!re.is_match("ba"));

        // Anchor in repetition group
        let re2 = Regex::compile("(^foo)+");
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();

        // Note: (^foo)+ can only match once since ^ only matches at position 0
        assert!(re2.is_match("foo"));
        assert!(re2.is_match("foofoo"));    // First foo matches ^foo, but can't repeat ^
    }

    #[test]
    fn test_regex_anchor_edge_cases() {
        // Just anchor
        let re = Regex::compile("^");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match(""));
        assert!(re.is_match("anything"));

        let re2 = Regex::compile("$");
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();

        assert!(re2.is_match(""));
        assert!(re2.is_match("anything"));

        // Both anchors only
        let re3 = Regex::compile("^$");
        assert!(re3.is_ok());
        let re3 = re3.unwrap();
        defer re3.free();

        assert!(re3.is_match(""));
        assert!(!re3.is_match("x"));
    }

    #[test]
    fn test_regex_anchor_with_captures() {
        // Anchors with capture groups
        let re = Regex::compile("^(\\w+)@(\\w+)$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("user@domain");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "user@domain");
        assert_eq!(caps.get(1).unwrap(), "user");
        assert_eq!(caps.get(2).unwrap(), "domain");

        // Should not match if not anchored
        let caps2 = re.captures("prefix user@domain suffix");
        assert!(caps2.is_none());
    }

    #[test]
    fn test_regex_simple_capture() {
        let re = Regex::compile("(ab)c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Group 0 = full match
        assert_eq!(caps.get(0).unwrap(), "abc");
        // Group 1 = (ab)
        assert_eq!(caps.get(1).unwrap(), "ab");
    }

    #[test]
    fn test_regex_multiple_captures() {
        let re = Regex::compile("(\\d+)-(\\w+)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("hello 123-abc world");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Group 0 = full match
        assert_eq!(caps.get(0).unwrap(), "123-abc");
        // Group 1 = \d+
        assert_eq!(caps.get(1).unwrap(), "123");
        // Group 2 = \w+
        assert_eq!(caps.get(2).unwrap(), "abc");
    }

    #[test]
    fn test_regex_nested_captures() {
        let re = Regex::compile("(a(b)c)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Group 0 = full match
        assert_eq!(caps.get(0).unwrap(), "abc");
        // Group 1 = (a(b)c)
        assert_eq!(caps.get(1).unwrap(), "abc");
        // Group 2 = (b)
        assert_eq!(caps.get(2).unwrap(), "b");
    }

    #[test]
    fn test_regex_capture_positions() {
        let re = Regex::compile("(\\d+)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("abc123def");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Check positions
        let pos = caps.get_pos(0).unwrap();
        assert_eq!(pos.0, 3usize); // start at position 3
        assert_eq!(pos.1, 6usize); // end at position 6

        let pos1 = caps.get_pos(1).unwrap();
        assert_eq!(pos1.0, 3usize);
        assert_eq!(pos1.1, 6usize);
    }

    #[test]
    fn test_regex_capture_with_star() {
        let re = Regex::compile("(a*)b");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("aaab");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "aaab");
        assert_eq!(caps.get(1).unwrap(), "aaa");
    }

    #[test]
    fn test_regex_capture_num_groups() {
        let re = Regex::compile("(a)(b)(c)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Should have 4 groups: group 0 (full) + 3 capture groups
        assert_eq!(caps.len(), 4usize);
        assert_eq!(caps.get(0).unwrap(), "abc");
        assert_eq!(caps.get(1).unwrap(), "a");
        assert_eq!(caps.get(2).unwrap(), "b");
        assert_eq!(caps.get(3).unwrap(), "c");
    }

    #[test]
    fn test_regex_non_capturing_group() {
        let re = Regex::compile("(?:ab)c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        // Should only have group 0 (full match), no capture groups
        assert_eq!(re.num_groups, 1usize);

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.len(), 1usize);
        assert_eq!(caps.get(0).unwrap(), "abc");
    }

    #[test]
    fn test_regex_mixed_groups() {
        let re = Regex::compile("(\\d+)(?:-)?(\\w+)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        // Should have 3 groups: group 0 (full) + 2 capture groups
        // The (?:-)? is non-capturing
        assert_eq!(re.num_groups, 3usize);

        let caps = re.captures("123-abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "123-abc");
        assert_eq!(caps.get(1).unwrap(), "123");
        assert_eq!(caps.get(2).unwrap(), "abc");
    }

    #[test]
    fn test_regex_nested_non_capturing() {
        let re = Regex::compile("(a(?:b)c)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        // Should have 2 groups: group 0 (full) + 1 capture group
        assert_eq!(re.num_groups, 2usize);

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "abc");
        assert_eq!(caps.get(1).unwrap(), "abc");
    }

    #[test]
    fn test_regex_unicode_literal() {
        let re = Regex::compile("cafÃ©");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("cafÃ©"));
        assert!(!re.is_match("cafe"));
        assert!(re.is_match("I love cafÃ©!"));
    }

    #[test]
    fn test_regex_unicode_emoji() {
        let re = Regex::compile("hello ğŸŒ");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello ğŸŒ"));
        assert!(!re.is_match("hello world"));
        assert!(re.is_match("say hello ğŸŒ please"));
    }

    #[test]
    fn test_regex_unicode_char_class() {
        // Match any of: Î±, Î², Î³
        let re = Regex::compile("[Î±Î²Î³]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("Î±"));
        assert!(re.is_match("Î²"));
        assert!(re.is_match("Î³"));
        assert!(!re.is_match("a"));
        assert!(!re.is_match("Î´"));
        assert!(re.is_match("test Î± here"));
    }

    #[test]
    fn test_regex_unicode_char_range() {
        // Match Greek lowercase letters Î±-Ï‰ (U+03B1 to U+03C9)
        let re = Regex::compile("[Î±-Ï‰]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("Î±"));  // U+03B1 (start of range)
        assert!(re.is_match("Ï‰"));  // U+03C9 (end of range)
        assert!(re.is_match("Î¼"));  // U+03BC (middle of range)
        assert!(re.is_match("Ï€"));  // U+03C0 (pi)
        assert!(!re.is_match("a")); // Latin letter
        assert!(!re.is_match("Î‘")); // Greek uppercase Alpha (U+0391)
    }

    #[test]
    fn test_regex_unicode_mixed_class() {
        // Mix ASCII and Unicode in character class
        let re = Regex::compile("[a-zğŸŒğŸ˜€]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("a"));
        assert!(re.is_match("z"));
        assert!(re.is_match("m"));
        assert!(re.is_match("ğŸŒ"));
        assert!(re.is_match("ğŸ˜€"));
        assert!(!re.is_match("A"));
        assert!(!re.is_match("0"));
        assert!(!re.is_match("ğŸ˜"));
    }

    #[test]
    fn test_regex_unicode_capture() {
        let re = Regex::compile("(\\w+): (\\w+) ([ğŸŒğŸŒğŸŒ])");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("Hello: world ğŸŒ");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "Hello: world ğŸŒ");
        assert_eq!(caps.get(1).unwrap(), "Hello");
        assert_eq!(caps.get(2).unwrap(), "world");
        assert_eq!(caps.get(3).unwrap(), "ğŸŒ");
    }

    #[test]
    fn test_regex_unicode_alternation() {
        let re = Regex::compile("hello|ã“ã‚“ã«ã¡ã¯|Ù…Ø±Ø­Ø¨Ø§");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("ã“ã‚“ã«ã¡ã¯"));  // Japanese
        assert!(re.is_match("Ù…Ø±Ø­Ø¨Ø§"));      // Arabic
        assert!(!re.is_match("hola"));
    }

    #[test]
    fn test_regex_unicode_cyrillic_range() {
        // Match Cyrillic letters Ğ-Ğ¯ (U+0410 to U+042F)
        let re = Regex::compile("[Ğ-Ğ¯]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ĞŸĞ Ğ˜Ğ’Ğ•Ğ¢"));  // "HELLO" in Russian
        assert!(re.is_match("ĞœĞĞ¡ĞšĞ’Ğ"));  // "MOSCOW" in Russian
        assert!(!re.is_match("hello"));
        assert!(!re.is_match("Ğ¿Ñ€Ğ¸Ğ²ĞµÑ‚")); // lowercase Cyrillic
    }

    #[test]
    fn test_regex_unicode_cjk() {
        // Chinese characters
        let re = Regex::compile("ä½ å¥½.*ä¸–ç•Œ");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ä½ å¥½ä¸–ç•Œ"));        // Hello world (Chinese)
        assert!(re.is_match("ä½ å¥½ï¼Œä¸–ç•Œ"));      // Hello, world
        assert!(re.is_match("ä½ å¥½ç¾ä¸½çš„ä¸–ç•Œ"));  // Hello beautiful world
        assert!(!re.is_match("ä½ å¥½"));
        assert!(!re.is_match("ä¸–ç•Œ"));
    }

    #[test]
    fn test_regex_unicode_emoji_range() {
        // Emojis U+1F600 to U+1F64F (Emoticons)
        let re = Regex::compile("[ğŸ˜€-ğŸ™]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ğŸ˜€"));  // U+1F600 (grinning face)
        assert!(re.is_match("ğŸ˜Š"));  // U+1F60A (smiling face)
        assert!(re.is_match("ğŸ™"));  // U+1F64F (folded hands)
        assert!(re.is_match("ğŸ˜€ğŸ˜ŠğŸ™"));  // Multiple emojis
        assert!(!re.is_match("ğŸŒ")); // U+1F30D (outside range)
    }

    #[test]
    fn test_regex_unicode_negated_class() {
        // Match anything except Latin letters
        let re = Regex::compile("[^a-zA-Z]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("ä½ å¥½"));
        assert!(re.is_match("ğŸŒ"));
        assert!(re.is_match("!@#"));
        assert!(!re.is_match("hello"));
        assert!(!re.is_match("ABC"));
    }

    #[test]
    fn test_regex_unicode_dot_matches_multibyte() {
        // Dot should match any single character including multibyte Unicode
        let re = Regex::compile("a.c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));     // ASCII
        assert!(re.is_match("aÃ©c"));     // 2-byte UTF-8
        assert!(re.is_match("aä½ c"));    // 3-byte UTF-8
        assert!(re.is_match("ağŸŒc"));    // 4-byte UTF-8
        assert!(!re.is_match("ac"));     // No character in middle
        assert!(!re.is_match("abbc"));   // Two characters in middle
    }

    #[test]
    fn test_regex_repeat_exact() {
        // {n} - exactly n times
        let re = Regex::compile("a{3}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("aaa"));
        assert!(re.is_match("xaaax"));
        assert!(!re.is_match("aa"));
        assert!(re.is_match("aaaa"));  // Matches first 3 a's
        assert!(!re.is_match("a"));
    }

    #[test]
    fn test_regex_repeat_at_least() {
        // {n,} - at least n times
        let re = Regex::compile("a{2,}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(!re.is_match("a"));
        assert!(re.is_match("aa"));
        assert!(re.is_match("aaa"));
        assert!(re.is_match("aaaa"));
        assert!(re.is_match("xaaaax"));
    }

    #[test]
    fn test_regex_repeat_range() {
        // {n,m} - between n and m times
        let re = Regex::compile("a{2,4}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(!re.is_match("a"));
        assert!(re.is_match("aa"));
        assert!(re.is_match("aaa"));
        assert!(re.is_match("aaaa"));
        assert!(re.is_match("aaaaa"));  // Matches first 4
        assert!(re.is_match("xaaax"));
    }

    #[test]
    fn test_regex_repeat_zero() {
        // {0} - matches empty (degenerate case)
        let re = Regex::compile("a{0}b");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("b"));
        assert!(re.is_match("ab"));  // "ab" contains "b"
        assert!(!re.is_match("a"));
    }

    #[test]
    fn test_regex_repeat_complex() {
        // Repetition on groups
        let re = Regex::compile("(ab){2}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abab"));
        assert!(re.is_match("xababx"));
        assert!(!re.is_match("ab"));
        assert!(re.is_match("ababab"));  // Matches first 2 occurrences
    }

    #[test]
    fn test_regex_repeat_with_char_class() {
        // Repetition on character classes
        let re = Regex::compile("[0-9]{3}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("999"));
        assert!(re.is_match("x456x"));
        assert!(!re.is_match("12"));
        assert!(re.is_match("1234"));  // Matches first 3 digits
    }

    #[test]
    fn test_regex_repeat_captures() {
        // Test repetition with captures
        let re = Regex::compile("(\\d{2,3})-([a-z]{2})");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("12-ab");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "12-ab");
        assert_eq!(caps.get(1).unwrap(), "12");
        assert_eq!(caps.get(2).unwrap(), "ab");

        let caps2 = re.captures("123-xy");
        assert!(caps2.is_some());
        let caps2 = caps2.unwrap();
        defer caps2.free();

        assert_eq!(caps2.get(0).unwrap(), "123-xy");
        assert_eq!(caps2.get(1).unwrap(), "123");
        assert_eq!(caps2.get(2).unwrap(), "xy");
    }

    #[test]
    fn test_escape_basic() {
        // Test \t, \n, \r
        let re = Regex::compile("a\\tb");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("a\tb"));
        assert!(!re.is_match("ab"));

        let re2 = Regex::compile("line1\\nline2");
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();
        assert!(re2.is_match("line1\nline2"));
        assert!(!re2.is_match("line1line2"));

        let re3 = Regex::compile("car\\rreturn");
        assert!(re3.is_ok());
        let re3 = re3.unwrap();
        defer re3.free();
        assert!(re3.is_match("car\rreturn"));
        assert!(!re3.is_match("carreturn"));
    }

    #[test]
    fn test_escape_backslash() {
        // Test escaping backslash itself
        let re = Regex::compile("a\\\\b");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("a\\b"));
        assert!(!re.is_match("ab"));
    }

    #[test]
    fn test_escape_metacharacters() {
        // Test escaping regex metacharacters
        let re = Regex::compile("\\(\\)\\[\\]\\{\\}\\*\\+\\?\\.\\|\\^\\$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("()[]{}*+?.|^$"));
        assert!(!re.is_match("abc"));
    }

    #[test]
    fn test_escape_hex() {
        // Test \xHH escape sequences
        let re = Regex::compile("\\x41\\x42\\x43");  // ABC
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("ABC"));
        assert!(!re.is_match("abc"));

        // Test lowercase hex digits
        let re2 = Regex::compile("\\x61\\x62\\x63");  // abc
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();
        assert!(re2.is_match("abc"));
        assert!(!re2.is_match("ABC"));

        // Test mixed case hex
        let re3 = Regex::compile("\\x4a\\x4B");  // JK
        assert!(re3.is_ok());
        let re3 = re3.unwrap();
        defer re3.free();
        assert!(re3.is_match("JK"));
    }

    #[test]
    fn test_escape_unicode() {
        // Test \uHHHH escape sequences
        let re = Regex::compile("\\u0041\\u0042\\u0043");  // ABC
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("ABC"));

        // Test Unicode characters beyond ASCII
        let re2 = Regex::compile("\\u00E9\\u00E0");  // Ã©Ã 
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();
        assert!(re2.is_match("Ã©Ã "));

        // Test emoji with Unicode escape (U+1F44D = ğŸ‘)
        // Note: \u only supports 4 hex digits, for higher codepoints use literal or \x sequences
        let re3 = Regex::compile("\\u03B1\\u03B2");  // Î±Î² (Greek)
        assert!(re3.is_ok());
        let re3 = re3.unwrap();
        defer re3.free();
        assert!(re3.is_match("Î±Î²"));
    }

    #[test]
    fn test_escape_in_char_class() {
        // Test escape sequences inside character classes
        let re = Regex::compile("[\\t\\n\\r]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("\t"));
        assert!(re.is_match("\n"));
        assert!(re.is_match("\r"));
        assert!(!re.is_match("a"));

        // Test hex escapes in character class
        let re2 = Regex::compile("[\\x41-\\x43]");  // [A-C]
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();
        assert!(re2.is_match("A"));
        assert!(re2.is_match("B"));
        assert!(re2.is_match("C"));
        assert!(!re2.is_match("D"));
    }

    #[test]
    fn test_escape_mixed() {
        // Test mixing different escape types
        let re = Regex::compile("\\x48\\u0065llo\\t\\d+");  // Hello\t followed by digits
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("Hello\t123"));
        assert!(!re.is_match("Hello 123"));
    }
}

