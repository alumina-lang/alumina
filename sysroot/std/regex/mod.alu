//! Regular expression matching with Unicode support
//!
//! This module provides DFA-based regular expression matching.
//! Only regular languages are supported (no backreferences).

// Start with just the interval set - test early, test often

use collections::{Vector, HashSet};
use string::{StringBuf, unicode};
use cmp::{sort_by_key, sort};

/// An interval representing a range of Unicode codepoints [start, end] inclusive
struct Interval {
    start: u32,
    end: u32
}

/// A set of Unicode codepoint intervals (sorted, non-overlapping)
/// This efficiently represents character classes like [a-zA-Z0-9]
struct IntervalSet {
    intervals: Vector<Interval>
}

impl IntervalSet {
    /// Create an empty interval set
    fn new() -> IntervalSet {
        IntervalSet {
            intervals: Vector::new()
        }
    }

    /// Create a set containing a single codepoint
    fn single(ch: u32) -> IntervalSet {
        let set = IntervalSet::new();
        set.intervals.push(Interval { start: ch, end: ch });
        set
    }

    /// Create a set from a range [start, end] inclusive
    fn range(start: u32, end: u32) -> IntervalSet {
        let set = IntervalSet::new();
        set.intervals.push(Interval { start: start, end: end });
        set
    }

    /// Check if a codepoint is in the set (binary search)
    fn contains(self: &IntervalSet, ch: u32) -> bool {
        let left = 0usize;
        let right = self.intervals.len();

        while left < right {
            let mid = left + (right - left) / 2;
            let interval = &self.intervals[mid];

            if ch < interval.start {
                right = mid;
            } else if ch > interval.end {
                left = mid + 1;
            } else {
                return true;
            }
        }

        false
    }

    /// Add an interval to the set (maintains sorted, non-overlapping invariant)
    fn add_interval(self: &mut IntervalSet, start: u32, end: u32) {
        if start > end {
            return; // Invalid interval
        }

        // Simple implementation: add and normalize
        // A more efficient implementation would merge during insertion
        self.intervals.push(Interval { start: start, end: end });
        self.normalize();
    }

    /// Add a single codepoint
    fn add(self: &mut IntervalSet, ch: u32) {
        self.add_interval(ch, ch);
    }

    /// Normalize: sort and merge overlapping/adjacent intervals
    fn normalize(self: &mut IntervalSet) {
        if self.intervals.len() <= 1 {
            return;
        }

        // Sort by start position
        self.intervals.as_slice_mut().sort_by_key(|interval: &Interval| -> u32 { interval.start });

        // Merge overlapping and adjacent intervals
        let merged: Vector<Interval> = Vector::new();
        let current = self.intervals[0];

        for i in 1usize..self.intervals.len() {
            let next = self.intervals[i];

            // Check if overlapping or adjacent (end + 1 == start means adjacent)
            if next.start <= current.end + 1 {
                // Merge: extend current to cover both
                current.end = if next.end > current.end { next.end } else { current.end };
            } else {
                // No overlap: save current and start new
                merged.push(current);
                current = next;
            }
        }
        merged.push(current);

        self.intervals = merged;
    }

    /// Negate the interval set (complement within valid Unicode range)
    fn negate(self: &IntervalSet) -> IntervalSet {
        let result = IntervalSet::new();

        if self.intervals.is_empty() {
            // Empty set negated = all Unicode
            result.intervals.push(Interval { start: 0, end: 0x10FFFF });
            return result;
        }

        let prev_end = 0u32;

        for interval in self.intervals.iter() {
            if prev_end < interval.start {
                // Add gap before this interval
                if interval.start > 0 {
                    result.intervals.push(Interval {
                        start: if prev_end == 0 { 0 } else { prev_end + 1 },
                        end: interval.start - 1
                    });
                }
            }
            prev_end = interval.end;
        }

        // Add gap after last interval
        if prev_end < 0x10FFFF {
            result.intervals.push(Interval {
                start: prev_end + 1,
                end: 0x10FFFF
            });
        }

        result
    }

    /// Union of two interval sets
    fn union(self: &IntervalSet, other: &IntervalSet) -> IntervalSet {
        let result = IntervalSet::new();

        // Copy all intervals from both sets
        for interval in self.intervals.iter() {
            result.intervals.push(interval);
        }
        for interval in other.intervals.iter() {
            result.intervals.push(interval);
        }

        result.normalize();
        result
    }

    /// Move semantics - transfer ownership leaving empty set behind
    fn move(self: &mut IntervalSet) -> IntervalSet {
        let ret = *self;
        self.intervals = Vector::new();
        ret
    }

    /// Free allocated memory
    fn free(self: &mut IntervalSet) {
        self.intervals.free();
    }

    /// Create character class for \d (digits 0-9)
    fn digit_class() -> IntervalSet {
        IntervalSet::range('0' as u32, '9' as u32)
    }

    /// Create character class for \D (non-digits)
    fn non_digit_class() -> IntervalSet {
        let digits = IntervalSet::digit_class();
        defer digits.free();
        digits.negate()
    }

    /// Create character class for \w (word characters: a-z, A-Z, 0-9, _)
    fn word_class() -> IntervalSet {
        let result = IntervalSet::new();
        result.add_interval('a' as u32, 'z' as u32);
        result.add_interval('A' as u32, 'Z' as u32);
        result.add_interval('0' as u32, '9' as u32);
        result.add('_' as u32);
        result
    }

    /// Create character class for \W (non-word characters)
    fn non_word_class() -> IntervalSet {
        let word = IntervalSet::word_class();
        defer word.free();
        word.negate()
    }

    /// Create character class for \s (whitespace: space, tab, newline, carriage return, form feed)
    fn whitespace_class() -> IntervalSet {
        let result = IntervalSet::new();
        result.add(' ' as u32);   // space
        result.add('\t' as u32);  // tab
        result.add('\n' as u32);  // newline
        result.add('\r' as u32);  // carriage return
        result.add(0x0C);         // form feed
        result
    }

    /// Create character class for \S (non-whitespace)
    fn non_whitespace_class() -> IntervalSet {
        let ws = IntervalSet::whitespace_class();
        defer ws.free();
        ws.negate()
    }
}

/// NFA (Nondeterministic Finite Automaton) for regex matching
/// Uses Thompson construction algorithm

/// Transition type for NFA
struct NfaTransition {
    /// Target state
    to: usize,
    /// Character class for this transition (None = epsilon transition)
    on_chars: Option<IntervalSet>,
}

impl NfaTransition {
    fn move(self: &mut NfaTransition) -> NfaTransition {
        let ret = *self;
        self.on_chars = Option::none();
        ret
    }

    fn free(self: &mut NfaTransition) {
        if self.on_chars.is_some() {
            self.on_chars.unwrap().free();
        }
    }
}

/// NFA state
struct NfaState {
    transitions: Vector<NfaTransition>,
    /// Is this an accepting/final state?
    is_final: bool,
}

impl NfaState {
    fn move(self: &mut NfaState) -> NfaState {
        let ret = *self;
        self.transitions = Vector::new();
        ret
    }

    fn free(self: &mut NfaState) {
        self.transitions.free_all();
    }
}

/// Complete NFA
struct Nfa {
    states: Vector<NfaState>,
    start: usize,
}

impl Nfa {
    /// Create a new NFA with a start state
    fn new() -> Nfa {
        let states: Vector<NfaState> = Vector::new();
        states.push(NfaState {
            transitions: Vector::new(),
            is_final: false,
        });

        Nfa {
            states: states,
            start: 0,
        }
    }

    /// Add a new state and return its index
    fn add_state(self: &mut Nfa, is_final: bool) -> usize {
        let idx = self.states.len();
        self.states.push(NfaState {
            transitions: Vector::new(),
            is_final: is_final,
        });
        idx
    }

    /// Add an epsilon transition from state `from` to state `to`
    fn add_epsilon(self: &mut Nfa, from: usize, to: usize) {
        self.states[from].transitions.push(NfaTransition {
            to: to,
            on_chars: Option::none(),
        });
    }

    /// Add a character transition from state `from` to state `to`
    fn add_transition(self: &mut Nfa, from: usize, to: usize, chars: IntervalSet) {
        self.states[from].transitions.push(NfaTransition {
            to: to,
            on_chars: Option::some(chars),
        });
    }

    fn move(self: &mut Nfa) -> Nfa {
        let ret = *self;
        self.states = Vector::new();
        ret
    }

    fn free(self: &mut Nfa) {
        self.states.free_all();
    }
}

/// NFA fragment used during Thompson construction
/// Represents a partial NFA with designated start and end states
struct NfaFragment {
    start: usize,
    end: usize,
}

/// Regex AST node types
/// Using discriminant + union pattern since Alumina doesn't have enums
struct RegexNode {
    kind: u8,  // 0=Literal, 1=Concat, 2=Alt, 3=Star, 4=Plus, 5=Question, 6=CharClass, 7=StartAnchor, 8=EndAnchor
    // Union of possible data
    literal_char: u32,
    char_class: IntervalSet,
    children: Vector<RegexNode>,
}

// Kind constants
const REGEX_LITERAL: u8 = 0;
const REGEX_CONCAT: u8 = 1;
const REGEX_ALT: u8 = 2;
const REGEX_STAR: u8 = 3;
const REGEX_PLUS: u8 = 4;
const REGEX_QUESTION: u8 = 5;
const REGEX_CHAR_CLASS: u8 = 6;
const REGEX_START_ANCHOR: u8 = 7;
const REGEX_END_ANCHOR: u8 = 8;

impl RegexNode {
    fn literal(ch: u32) -> RegexNode {
        RegexNode {
            kind: REGEX_LITERAL,
            literal_char: ch,
            char_class: IntervalSet::new(),
            children: Vector::new(),
        }
    }

    fn char_class(class: IntervalSet) -> RegexNode {
        RegexNode {
            kind: REGEX_CHAR_CLASS,
            literal_char: 0,
            char_class: class,
            children: Vector::new(),
        }
    }

    fn concat(nodes: Vector<RegexNode>) -> RegexNode {
        RegexNode {
            kind: REGEX_CONCAT,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: nodes,
        }
    }

    fn alt(left: RegexNode, right: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(left);
        children.push(right);
        RegexNode {
            kind: REGEX_ALT,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
        }
    }

    fn star(node: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(node);
        RegexNode {
            kind: REGEX_STAR,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
        }
    }

    fn plus(node: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(node);
        RegexNode {
            kind: REGEX_PLUS,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
        }
    }

    fn question(node: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(node);
        RegexNode {
            kind: REGEX_QUESTION,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
        }
    }

    fn start_anchor() -> RegexNode {
        RegexNode {
            kind: REGEX_START_ANCHOR,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: Vector::new(),
        }
    }

    fn end_anchor() -> RegexNode {
        RegexNode {
            kind: REGEX_END_ANCHOR,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: Vector::new(),
        }
    }

    fn move(self: &mut RegexNode) -> RegexNode {
        let ret = *self;
        self.children = Vector::new();
        self.char_class = IntervalSet::new();
        ret
    }

    fn free(self: &mut RegexNode) {
        self.children.free_all();
        self.char_class.free();
    }
}

/// Thompson construction: Convert regex AST to NFA
fn thompson_construct(node: &RegexNode, nfa: &mut Nfa) -> NfaFragment {
    if node.kind == REGEX_LITERAL {
        // Create: start --ch--> end
        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        let chars = IntervalSet::single(node.literal_char);
        nfa.add_transition(start, end, chars);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_CHAR_CLASS {
        // Create: start --[class]--> end
        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Clone the character class
        let chars = IntervalSet::new();
        for interval in node.char_class.intervals.iter() {
            chars.intervals.push(interval);
        }
        nfa.add_transition(start, end, chars);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_CONCAT {
        // Concatenation: connect fragments in sequence
        if node.children.is_empty() {
            // Empty concatenation - epsilon transition
            let start = nfa.states.len();
            nfa.add_state(false);
            let end = nfa.add_state(true);
            nfa.add_epsilon(start, end);
            return NfaFragment { start: start, end: end };
        }

        let first_frag = thompson_construct(&node.children[0], nfa);
        let overall_start = first_frag.start;
        let prev_end = first_frag.end;

        for i in 1usize..node.children.len() {
            let frag = thompson_construct(&node.children[i], nfa);
            // Connect previous end to this start
            nfa.states[prev_end].is_final = false;
            nfa.add_epsilon(prev_end, frag.start);
            prev_end = frag.end;
        }

        NfaFragment { start: overall_start, end: prev_end }
    } else if node.kind == REGEX_ALT {
        // Alternation: start -ε-> (left | right) -ε-> end
        let left_frag = thompson_construct(&node.children[0], nfa);
        let right_frag = thompson_construct(&node.children[1], nfa);

        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Connect start to both alternatives
        nfa.add_epsilon(start, left_frag.start);
        nfa.add_epsilon(start, right_frag.start);

        // Connect both alternatives to end
        nfa.states[left_frag.end].is_final = false;
        nfa.states[right_frag.end].is_final = false;
        nfa.add_epsilon(left_frag.end, end);
        nfa.add_epsilon(right_frag.end, end);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_STAR {
        // Star: start -ε-> (inner -ε-> start) and start -ε-> end
        let inner_frag = thompson_construct(&node.children[0], nfa);

        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Connect start to inner and to end (zero occurrences)
        nfa.add_epsilon(start, inner_frag.start);
        nfa.add_epsilon(start, end);

        // Connect inner end back to inner start (repeat)
        nfa.states[inner_frag.end].is_final = false;
        nfa.add_epsilon(inner_frag.end, inner_frag.start);
        nfa.add_epsilon(inner_frag.end, end);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_PLUS {
        // Plus: same as star but no epsilon from start to end
        let inner_frag = thompson_construct(&node.children[0], nfa);

        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Connect start to inner (at least one occurrence)
        nfa.add_epsilon(start, inner_frag.start);

        // Connect inner end back to inner start (repeat) and to end
        nfa.states[inner_frag.end].is_final = false;
        nfa.add_epsilon(inner_frag.end, inner_frag.start);
        nfa.add_epsilon(inner_frag.end, end);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_QUESTION {
        // Question: start -ε-> inner -ε-> end, and start -ε-> end
        let inner_frag = thompson_construct(&node.children[0], nfa);

        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Connect start to inner and to end (optional)
        nfa.add_epsilon(start, inner_frag.start);
        nfa.add_epsilon(start, end);

        // Connect inner end to end
        nfa.states[inner_frag.end].is_final = false;
        nfa.add_epsilon(inner_frag.end, end);

        NfaFragment { start: start, end: end }
    } else {
        // Unknown node type - create empty epsilon transition
        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);
        nfa.add_epsilon(start, end);
        NfaFragment { start: start, end: end }
    }
}

/// Simple regex parser
/// Parses a subset of regex syntax: literals, ., *, +, ?, |, (), []
struct RegexParser {
    input: &[u8],
    pos: usize,
}

impl RegexParser {
    fn new(pattern: &[u8]) -> RegexParser {
        RegexParser {
            input: pattern,
            pos: 0,
        }
    }

    fn peek(self: &RegexParser) -> Option<u8> {
        if self.pos < self.input.len() {
            Option::some(self.input[self.pos])
        } else {
            Option::none()
        }
    }

    fn advance(self: &mut RegexParser) {
        if self.pos < self.input.len() {
            self.pos += 1;
        }
    }

    fn peek_char(self: &RegexParser) -> Option<u32> {
        if self.pos >= self.input.len() {
            return Option::none();
        }
        let decoded = unicode::decode_utf8(self.input[self.pos..]);
        if decoded.is_ok() {
            Option::some(decoded.unwrap().0)
        } else {
            Option::none()
        }
    }

    fn consume_char(self: &mut RegexParser) -> Option<u32> {
        if self.pos >= self.input.len() {
            return Option::none();
        }
        let decoded = unicode::decode_utf8(self.input[self.pos..]);
        if decoded.is_ok() {
            let ch = decoded.unwrap().0;
            let len = decoded.unwrap().1;
            self.pos += len;
            Option::some(ch)
        } else {
            Option::none()
        }
    }

    /// Parse full regex
    fn parse(self: &mut RegexParser) -> Result<RegexNode, ()> {
        self.parse_alternation()
    }

    /// Parse alternation (lowest precedence): a|b|c
    fn parse_alternation(self: &mut RegexParser) -> Result<RegexNode, ()> {
        let left = self.parse_concatenation();
        if left.is_err() {
            return left;
        }
        let left = left.unwrap();

        let ch = self.peek();
        if ch.is_some() && ch.unwrap() == '|' {
            self.advance();
            let right = self.parse_alternation();
            if right.is_err() {
                left.free();
                return right;
            }
            Result::ok(RegexNode::alt(left, right.unwrap()))
        } else {
            Result::ok(left)
        }
    }

    /// Parse concatenation: abc
    fn parse_concatenation(self: &mut RegexParser) -> Result<RegexNode, ()> {
        let nodes: Vector<RegexNode> = Vector::new();

        loop {
            let ch = self.peek();
            if ch.is_none() || ch.unwrap() == '|' || ch.unwrap() == ')' {
                break;
            }

            let node = self.parse_postfix();
            if node.is_err() {
                nodes.free_all();
                return node;
            }
            nodes.push(node.unwrap());
        }

        if nodes.is_empty() {
            // Empty concatenation - matches empty string
            Result::ok(RegexNode::concat(nodes))
        } else if nodes.len() == 1 {
            // Single node - no need for concat wrapper
            let result = nodes[0].move();
            nodes.free();
            Result::ok(result)
        } else {
            Result::ok(RegexNode::concat(nodes))
        }
    }

    /// Parse postfix operators: *, +, ?
    fn parse_postfix(self: &mut RegexParser) -> Result<RegexNode, ()> {
        let base = self.parse_atom();
        if base.is_err() {
            return base;
        }
        let base = base.unwrap();

        let ch = self.peek();
        if ch.is_none() {
            return Result::ok(base);
        }

        if ch.unwrap() == '*' {
            self.advance();
            Result::ok(RegexNode::star(base))
        } else if ch.unwrap() == '+' {
            self.advance();
            Result::ok(RegexNode::plus(base))
        } else if ch.unwrap() == '?' {
            self.advance();
            Result::ok(RegexNode::question(base))
        } else {
            Result::ok(base)
        }
    }

    /// Parse atomic expression: literal, ., [], ()
    fn parse_atom(self: &mut RegexParser) -> Result<RegexNode, ()> {
        let ch = self.peek();
        if ch.is_none() {
            return Result::err(());
        }

        if ch.unwrap() == '(' {
            // Group
            self.advance();
            let inner = self.parse_alternation();
            if inner.is_err() {
                return inner;
            }
            let closing = self.peek();
            if closing.is_none() || closing.unwrap() != ')' {
                inner.unwrap().free();
                return Result::err(());
            }
            self.advance();
            inner
        } else if ch.unwrap() == '.' {
            // Any character (except newline)
            self.advance();
            let any_char = IntervalSet::new();
            any_char.add_interval(0, 0x10FFFF);
            // Remove newline
            let newline = IntervalSet::single('\n' as u32);
            defer newline.free();
            let without_newline = any_char.union(&newline.negate());
            any_char.free();
            Result::ok(RegexNode::char_class(without_newline))
        } else if ch.unwrap() == '[' {
            // Character class
            self.parse_char_class()
        } else if ch.unwrap() == '\\' {
            // Escape sequence
            self.advance();
            let escaped = self.consume_char();
            if escaped.is_none() {
                return Result::err(());
            }
            let esc = escaped.unwrap();

            // Check for character class escapes
            if esc == 'd' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::digit_class()))
            } else if esc == 'D' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::non_digit_class()))
            } else if esc == 'w' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::word_class()))
            } else if esc == 'W' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::non_word_class()))
            } else if esc == 's' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::whitespace_class()))
            } else if esc == 'S' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::non_whitespace_class()))
            } else {
                // Regular escaped character (e.g., \(, \), \*, etc.)
                Result::ok(RegexNode::literal(esc))
            }
        } else {
            // Literal character
            let literal = self.consume_char();
            if literal.is_none() {
                return Result::err(());
            }
            Result::ok(RegexNode::literal(literal.unwrap()))
        }
    }

    /// Parse character class: [abc], [a-z], [^abc]
    fn parse_char_class(self: &mut RegexParser) -> Result<RegexNode, ()> {
        if self.peek().is_none() || self.peek().unwrap() != '[' {
            return Result::err(());
        }
        self.advance();

        let negated = false;
        if self.peek().is_some() && self.peek().unwrap() == '^' {
            negated = true;
            self.advance();
        }

        let class = IntervalSet::new();

        loop {
            let ch = self.peek();
            if ch.is_none() {
                class.free();
                return Result::err(());
            }
            if ch.unwrap() == ']' {
                self.advance();
                break;
            }

            let start_ch = self.consume_char();
            if start_ch.is_none() {
                class.free();
                return Result::err(());
            }
            let start = start_ch.unwrap();

            // Check for range
            if self.peek().is_some() && self.peek().unwrap() == '-' {
                self.advance();
                // Check if this is the end of the class
                if self.peek().is_some() && self.peek().unwrap() == ']' {
                    // Literal '-'
                    class.add(start);
                    class.add('-' as u32);
                } else {
                    let end_ch = self.consume_char();
                    if end_ch.is_none() {
                        class.free();
                        return Result::err(());
                    }
                    class.add_interval(start, end_ch.unwrap());
                }
            } else {
                class.add(start);
            }
        }

        if negated {
            let negated_class = class.negate();
            class.free();
            Result::ok(RegexNode::char_class(negated_class))
        } else {
            Result::ok(RegexNode::char_class(class))
        }
    }
}

/// Compute epsilon closure of a set of NFA states
/// Returns all states reachable via epsilon transitions
fn epsilon_closure(nfa: &Nfa, states: &HashSet<usize>) -> HashSet<usize> {
    let result: HashSet<usize> = HashSet::new();
    let stack: Vector<usize> = Vector::new();
    defer stack.free();

    // Start with the input states
    for state in states.iter() {
        result.insert(state);
        stack.push(state);
    }

    // Process stack: follow epsilon transitions
    while !stack.is_empty() {
        let current = stack.pop().unwrap();

        for trans in nfa.states[current].transitions.iter() {
            if trans.on_chars.is_none() {
                // Epsilon transition
                if !result.contains(&trans.to) {
                    result.insert(trans.to);
                    stack.push(trans.to);
                }
            }
        }
    }

    result
}

/// Compute the set of NFA states reachable from a set of states on a character
fn move_on_char(nfa: &Nfa, states: &HashSet<usize>, ch: u32) -> HashSet<usize> {
    let result: HashSet<usize> = HashSet::new();

    for state in states.iter() {
        for trans in nfa.states[state].transitions.iter() {
            if trans.on_chars.is_some() {
                let chars = trans.on_chars.unwrap();
                if chars.contains(ch) {
                    result.insert(trans.to);
                }
            }
        }
    }

    result
}

/// Hash a set of NFA states to use as a key in the state map
fn hash_state_set(states: &HashSet<usize>) -> u64 {
    use hash::DefaultHash;

    // Convert to sorted vector for consistent hashing
    let sorted: Vector<usize> = Vector::new();
    defer sorted.free();

    for state in states.iter() {
        sorted.push(state);
    }
    sort(sorted.as_slice_mut());

    // Hash the sorted states
    let hasher = DefaultHash::new();
    for state in sorted.iter() {
        state.hash(&hasher);
    }
    hasher.finish()
}

/// Collect all distinct character classes from transitions in a state set
/// This splits overlapping intervals into non-overlapping character classes
fn collect_character_classes(nfa: &Nfa, states: &HashSet<usize>) -> Vector<IntervalSet> {
    // Collect all intervals from all transitions
    let all_intervals: Vector<Interval> = Vector::new();
    defer all_intervals.free();

    for state in states.iter() {
        for trans in nfa.states[state].transitions.iter() {
            if trans.on_chars.is_some() {
                let chars = trans.on_chars.unwrap();
                for interval in chars.intervals.iter() {
                    all_intervals.push(interval);
                }
            }
        }
    }

    if all_intervals.is_empty() {
        return Vector::new();
    }

    // Collect all boundary points
    let boundaries: Vector<u32> = Vector::new();
    defer boundaries.free();

    for interval in all_intervals.iter() {
        boundaries.push(interval.start);
        if interval.end < 0x10FFFF {
            boundaries.push(interval.end + 1);
        }
    }

    // Sort and deduplicate boundaries
    sort(boundaries.as_slice_mut());
    let unique_boundaries: Vector<u32> = Vector::new();
    defer unique_boundaries.free();

    if !boundaries.is_empty() {
        unique_boundaries.push(boundaries[0]);
        for i in 1usize..boundaries.len() {
            if boundaries[i] != boundaries[i - 1] {
                unique_boundaries.push(boundaries[i]);
            }
        }
    }

    // Create character classes from boundaries
    let char_classes: Vector<IntervalSet> = Vector::new();

    for i in 0usize..unique_boundaries.len() {
        let start = unique_boundaries[i];
        let end = if i + 1 < unique_boundaries.len() {
            unique_boundaries[i + 1] - 1
        } else {
            0x10FFFF
        };

        // Check if this range is covered by any original interval
        let mid = start;
        let covered = false;
        for interval in all_intervals.iter() {
            if mid >= interval.start && mid <= interval.end {
                covered = true;
                break;
            }
        }

        if covered {
            let class = IntervalSet::range(start, end);
            char_classes.push(class);
        }
    }

    char_classes
}

/// DFA (Deterministic Finite Automaton) compiled from NFA
/// Each state has exactly one transition per character class

/// DFA transition - maps a character class to a destination state
struct DfaTransition {
    chars: IntervalSet,
    to: usize,
}

impl DfaTransition {
    fn move(self: &mut DfaTransition) -> DfaTransition {
        let ret = *self;
        self.chars = IntervalSet::new();
        ret
    }

    fn free(self: &mut DfaTransition) {
        self.chars.free();
    }
}

/// DFA state
struct DfaState {
    transitions: Vector<DfaTransition>,
    is_final: bool,
}

impl DfaState {
    fn move(self: &mut DfaState) -> DfaState {
        let ret = *self;
        self.transitions = Vector::new();
        ret
    }

    fn free(self: &mut DfaState) {
        self.transitions.free_all();
    }
}

/// Complete DFA
struct Dfa {
    states: Vector<DfaState>,
    start: usize,
}

impl Dfa {
    /// Create empty DFA
    fn new() -> Dfa {
        Dfa {
            states: Vector::new(),
            start: 0,
        }
    }

    /// Convert an NFA to a DFA using subset construction
    fn from_nfa(nfa: &Nfa) -> Dfa {
        use collections::HashMap;

        let dfa = Dfa::new();

        // Map from NFA state set to DFA state index
        let state_map: HashMap<u64, usize> = HashMap::new();
        defer state_map.free();

        let work_list: Vector<HashSet<usize>> = Vector::new();
        defer work_list.free_all();

        // Compute initial state (epsilon closure of NFA start state)
        let start_set: HashSet<usize> = HashSet::new();
        defer start_set.free();

        start_set.insert(nfa.start);
        let start_closure = epsilon_closure(nfa, &start_set);

        // Check if start state is final
        let is_start_final = false;
        for s in start_closure.iter() {
            if nfa.states[s].is_final {
                is_start_final = true;
                break;
            }
        }

        // Add start state to DFA
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: is_start_final,
        });

        let start_hash = hash_state_set(&start_closure);
        state_map.insert(start_hash, 0);
        work_list.push(start_closure);

        // Process work list
        while !work_list.is_empty() {
            let current_set = work_list.pop().unwrap();

            let current_hash = hash_state_set(&current_set);
            let current_idx = state_map.get(&current_hash).unwrap();

            // Collect all possible character classes from this state set
            let char_classes = collect_character_classes(nfa, &current_set);

            // For each character class, compute the next state
            for char_class in char_classes.iter() {
                // Find a representative character in this class
                if char_class.intervals.is_empty() {
                    continue;
                }
                let rep_char = char_class.intervals[0].start;

                // Compute next state set
                let next_set = move_on_char(nfa, &current_set, rep_char);
                let next_closure = epsilon_closure(nfa, &next_set);
                next_set.free();

                if next_closure.is_empty() {
                    next_closure.free();
                    continue;
                }

                // Check if this state set already exists
                let next_hash = hash_state_set(&next_closure);
                let existing = state_map.get(&next_hash);
                let next_idx = if existing.is_some() {
                    // State already exists, free the closure
                    next_closure.free();
                    existing.unwrap()
                } else {
                    // Create new DFA state
                    let new_idx = dfa.states.len();
                    let is_final = false;
                    for s in next_closure.iter() {
                        if nfa.states[s].is_final {
                            is_final = true;
                            break;
                        }
                    }

                    dfa.states.push(DfaState {
                        transitions: Vector::new(),
                        is_final: is_final,
                    });

                    state_map.insert(next_hash, new_idx);
                    work_list.push(next_closure);  // Transfer ownership to work_list
                    new_idx
                };

                // Add transition to current DFA state
                // Note: char_class is being moved here, so we need to avoid reusing it
                dfa.states[current_idx].transitions.push(DfaTransition {
                    chars: char_class,
                    to: next_idx,
                });
            }

            // char_classes elements were moved, just free the vector itself
            char_classes.free();
            current_set.free();
        }

        dfa
    }

    /// Check if text matches (simple boolean match)
    fn is_match(self: &Dfa, text: &[u8]) -> bool {
        self.find(text).is_some()
    }

    /// Find first match position
    fn find(self: &Dfa, text: &[u8]) -> Option<(usize, usize)> {
        // Try starting the match at each position
        for start_pos in 0usize..text.len() + 1 {
            let result = self.match_from(text, start_pos);
            if result.is_some() {
                return Option::some((start_pos, result.unwrap()));
            }
        }
        Option::none()
    }

    /// Try to match starting from a specific position
    fn match_from(self: &Dfa, text: &[u8], start_pos: usize) -> Option<usize> {
        let state = self.start;
        let pos = start_pos;
        let last_accept: Option<usize> = Option::none();

        // Check if start state is final
        if self.states[state].is_final {
            last_accept = Option::some(pos);
        }

        while pos < text.len() {
            // Decode UTF-8 codepoint
            let decoded = unicode::decode_utf8(text[pos..]);
            if decoded.is_err() {
                return last_accept; // Invalid UTF-8
            }

            let ch = decoded.unwrap().0;
            let bytes = decoded.unwrap().1;

            // Find transition for this character
            let next_state: Option<usize> = Option::none();
            for trans in self.states[state].transitions.iter() {
                if trans.chars.contains(ch) {
                    next_state = Option::some(trans.to);
                    break;
                }
            }

            if next_state.is_none() {
                return last_accept; // No transition found
            }

            state = next_state.unwrap();
            pos += bytes;

            // Update last accepting position
            if self.states[state].is_final {
                last_accept = Option::some(pos);
            }
        }

        // End of input - return last accept or current if accepting
        if self.states[state].is_final {
            Option::some(pos)
        } else {
            last_accept
        }
    }

    fn move(self: &mut Dfa) -> Dfa {
        let ret = *self;
        self.states = Vector::new();
        ret
    }

    fn free(self: &mut Dfa) {
        self.states.free_all();
    }
}

/// Public Regex API
/// Compiled regular expression that can be used for matching
struct Regex {
    dfa: Dfa,
    anchored_start: bool,  // Pattern starts with ^
    anchored_end: bool,    // Pattern ends with $
}

impl Regex {
    /// Compile a regex pattern
    fn compile(pattern: &[u8]) -> Result<Regex, ()> {
        // Check for anchors and strip them
        let anchored_start = pattern.len() > 0 && pattern[0] == '^';
        let anchored_end = pattern.len() > 0 && pattern[pattern.len() - 1] == '$';

        let start_offset = if anchored_start { 1usize } else { 0usize };
        let end_offset = if anchored_end { pattern.len() - 1 } else { pattern.len() };

        // Get the actual pattern without anchors
        let actual_pattern = if start_offset < end_offset {
            pattern[start_offset..end_offset]
        } else {
            pattern[0usize..0usize]  // Empty pattern
        };

        // Parse the pattern
        let parser = RegexParser::new(actual_pattern);
        let ast = parser.parse();
        if ast.is_err() {
            return Result::err(());
        }
        let ast = ast.unwrap();
        defer ast.free();

        // Build NFA using Thompson construction
        let nfa = Nfa::new();
        let frag = thompson_construct(&ast, &nfa);

        // Set the NFA start state
        nfa.start = frag.start;

        // Convert NFA to DFA
        let dfa = Dfa::from_nfa(&nfa);
        nfa.free();

        Result::ok(Regex {
            dfa: dfa,
            anchored_start: anchored_start,
            anchored_end: anchored_end,
        })
    }

    /// Check if the entire text matches the pattern
    fn is_match(self: &Regex, text: &[u8]) -> bool {
        if self.anchored_start && self.anchored_end {
            // Must match entire string exactly
            let result = self.dfa.match_from(text, 0);
            result.is_some() && result.unwrap() == text.len()
        } else if self.anchored_start {
            // Must match from start
            let result = self.dfa.match_from(text, 0);
            result.is_some()
        } else if self.anchored_end {
            // Must match at end - try all positions
            for start_pos in 0usize..text.len() + 1 {
                let result = self.dfa.match_from(text, start_pos);
                if result.is_some() && result.unwrap() == text.len() {
                    return true;
                }
            }
            false
        } else {
            // No anchors - match anywhere
            self.dfa.is_match(text)
        }
    }

    /// Find the first match in the text
    /// Returns (start_pos, end_pos) if found
    fn find(self: &Regex, text: &[u8]) -> Option<(usize, usize)> {
        if self.anchored_start {
            // Must start at beginning
            let result = self.dfa.match_from(text, 0);
            if result.is_some() {
                let end = result.unwrap();
                if !self.anchored_end || end == text.len() {
                    return Option::some((0, end));
                }
            }
            Option::none()
        } else if self.anchored_end {
            // Must end at end
            for start_pos in 0usize..text.len() + 1 {
                let result = self.dfa.match_from(text, start_pos);
                if result.is_some() && result.unwrap() == text.len() {
                    return Option::some((start_pos, text.len()));
                }
            }
            Option::none()
        } else {
            self.dfa.find(text)
        }
    }

    /// Check if text matches from the beginning
    fn match_from_start(self: &Regex, text: &[u8]) -> bool {
        let result = self.dfa.match_from(text, 0);
        if result.is_none() {
            return false;
        }
        let end = result.unwrap();
        if self.anchored_end {
            end == text.len()
        } else {
            end > 0
        }
    }

    fn move(self: &mut Regex) -> Regex {
        let ret = *self;
        self.dfa = Dfa::new();
        ret
    }

    fn free(self: &mut Regex) {
        self.dfa.free();
    }
}


#[cfg(all(test, test_std))]
#[docs(hide)]
mod tests {
    #[test]
    fn test_interval_single() {
        let set = IntervalSet::single('a' as u32);
        defer set.free();
        assert!(set.contains('a' as u32));
        assert!(!set.contains('b' as u32));
    }

    #[test]
    fn test_interval_range() {
        let set = IntervalSet::range('a' as u32, 'z' as u32);
        defer set.free();
        assert!(set.contains('a' as u32));
        assert!(set.contains('m' as u32));
        assert!(set.contains('z' as u32));
        assert!(!set.contains('A' as u32));
        assert!(!set.contains('0' as u32));
    }

    #[test]
    fn test_interval_add_and_merge() {
        let set = IntervalSet::new();
        defer set.free();
        set.add_interval('a' as u32, 'c' as u32);
        set.add_interval('e' as u32, 'g' as u32);
        set.add_interval('b' as u32, 'f' as u32); // Overlaps both

        assert_eq!(set.intervals.len(), 1);
        assert_eq!(set.intervals[0].start, 'a' as u32);
        assert_eq!(set.intervals[0].end, 'g' as u32);
    }

    #[test]
    fn test_interval_negate() {
        let set = IntervalSet::range('a' as u32, 'z' as u32);
        defer set.free();
        let negated = set.negate();
        defer negated.free();

        assert!(!negated.contains('a' as u32));
        assert!(!negated.contains('m' as u32));
        assert!(!negated.contains('z' as u32));
        assert!(negated.contains('A' as u32));
        assert!(negated.contains('0' as u32));
        assert!(negated.contains(0));
        assert!(negated.contains(0x10FFFF));
    }

    #[test]
    fn test_interval_union() {
        let set1 = IntervalSet::range('a' as u32, 'z' as u32);
        defer set1.free();
        let set2 = IntervalSet::range('A' as u32, 'Z' as u32);
        defer set2.free();
        let union = set1.union(&set2);
        defer union.free();

        assert!(union.contains('a' as u32));
        assert!(union.contains('Z' as u32));
        assert!(!union.contains('0' as u32));
        assert_eq!(union.intervals.len(), 2);
    }

    #[test]
    fn test_nfa_basic() {
        // Build simple NFA: start --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let end_state = nfa.add_state(true);

        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(nfa.start, end_state, chars);

        assert_eq!(nfa.states.len(), 2);
        assert_eq!(nfa.states[0].transitions.len(), 1);
        assert!(nfa.states[1].is_final);
    }

    #[test]
    fn test_nfa_epsilon() {
        // Build NFA with epsilon transition
        let nfa = Nfa::new();
        defer nfa.free();
        let middle = nfa.add_state(false);
        let end_state = nfa.add_state(true);

        nfa.add_epsilon(nfa.start, middle);

        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(middle, end_state, chars);

        assert_eq!(nfa.states.len(), 3);
        assert!(nfa.states[0].transitions[0].on_chars.is_none());
    }

    #[test]
    fn test_nfa_to_dfa() {
        // Build simple NFA: start --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let end_state = nfa.add_state(true);
        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(nfa.start, end_state, chars);

        // Convert to DFA
        let dfa = Dfa::from_nfa(&nfa);
        defer dfa.free();

        // Test matching
        assert!(dfa.is_match("a"));
        assert!(dfa.is_match("xax"));
        assert!(!dfa.is_match("b"));
        assert!(!dfa.is_match(""));
    }

    #[test]
    fn test_nfa_to_dfa_with_epsilon() {
        // Build NFA with epsilon: start -ε-> middle --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let middle = nfa.add_state(false);
        let end_state = nfa.add_state(true);

        nfa.add_epsilon(nfa.start, middle);
        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(middle, end_state, chars);

        // Convert to DFA
        let dfa = Dfa::from_nfa(&nfa);
        defer dfa.free();

        // Test matching - epsilon should be transparent
        assert!(dfa.is_match("a"));
        assert!(dfa.is_match("ba"));
        assert!(!dfa.is_match("b"));
    }

    #[test]
    fn test_utf8_decode() {
        // Test ASCII
        let result = unicode::decode_utf8("a");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 'a' as u32);
        assert_eq!(result.unwrap().1, 1usize);

        // Test 2-byte (ñ = U+00F1)
        let result = unicode::decode_utf8("ñ");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0xF1u32);
        assert_eq!(result.unwrap().1, 2usize);

        // Test 3-byte (€ = U+20AC)
        let result = unicode::decode_utf8("€");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0x20ACu32);
        assert_eq!(result.unwrap().1, 3usize);

        // Test 4-byte (𝔸 = U+1D538)
        let result = unicode::decode_utf8("𝔸");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0x1D538u32);
        assert_eq!(result.unwrap().1, 4usize);
    }

    #[test]
    fn test_dfa_simple_match() {
        // Manually build a DFA that matches "ab"
        let dfa = Dfa::new();
        defer dfa.free();

        // State 0 (start) --'a'--> State 1
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: false,
        });

        // State 1 --'b'--> State 2
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: false,
        });

        // State 2 (final)
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: true,
        });

        // Add transitions
        dfa.states[0].transitions.push(DfaTransition {
            chars: IntervalSet::single('a' as u32),
            to: 1,
        });

        dfa.states[1].transitions.push(DfaTransition {
            chars: IntervalSet::single('b' as u32),
            to: 2,
        });

        // Test matching
        assert!(dfa.is_match("ab"));
        assert!(dfa.is_match("xabx"));
        assert!(!dfa.is_match("ac"));
        assert!(!dfa.is_match("a"));
    }

    #[test]
    fn test_regex_literal() {
        let re = Regex::compile("abc");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("xabcy"));
        assert!(!re.is_match("ab"));
        assert!(!re.is_match("abx"));
    }

    #[test]
    fn test_regex_alternation() {
        let re = Regex::compile("cat|dog");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("cat"));
        assert!(re.is_match("dog"));
        assert!(re.is_match("the cat"));
        assert!(!re.is_match("bird"));
    }

    #[test]
    fn test_regex_star() {
        let re = Regex::compile("ab*c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ac"));       // zero b's
        assert!(re.is_match("abc"));      // one b
        assert!(re.is_match("abbc"));     // two b's
        assert!(re.is_match("abbbbbc"));  // many b's
        assert!(!re.is_match("ab"));      // no c
    }

    #[test]
    fn test_regex_plus() {
        let re = Regex::compile("ab+c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(!re.is_match("ac"));      // zero b's - should fail
        assert!(re.is_match("abc"));      // one b
        assert!(re.is_match("abbc"));     // two b's
        assert!(re.is_match("abbbbbc"));  // many b's
    }

    #[test]
    fn test_regex_question() {
        let re = Regex::compile("ab?c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ac"));       // zero b's
        assert!(re.is_match("abc"));      // one b
        assert!(!re.is_match("abbc"));    // two b's - should fail
    }

    #[test]
    fn test_regex_dot() {
        let re = Regex::compile("a.c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("a-c"));
        assert!(re.is_match("a c"));
        assert!(!re.is_match("ac"));      // needs something between
    }

    #[test]
    fn test_regex_char_class() {
        let re = Regex::compile("[abc]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("a"));
        assert!(re.is_match("b"));
        assert!(re.is_match("c"));
        assert!(!re.is_match("d"));
    }

    #[test]
    fn test_regex_char_range() {
        let re = Regex::compile("[a-z]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("world"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("test123"));  // contains lowercase
    }

    #[test]
    fn test_regex_negated_class() {
        let re = Regex::compile("[^0-9]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("abc123"));   // starts with non-digits
    }

    #[test]
    fn test_regex_groups() {
        let re = Regex::compile("(ab)+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ab"));
        assert!(re.is_match("abab"));
        assert!(re.is_match("ababab"));
        assert!(re.is_match("abc"));       // contains "ab"
        assert!(!re.is_match("a"));
        assert!(!re.is_match("ba"));       // doesn't contain "ab"
    }

    #[test]
    fn test_regex_complex() {
        let re = Regex::compile("(a|b)*c+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("c"));
        assert!(re.is_match("ac"));
        assert!(re.is_match("bc"));
        assert!(re.is_match("aaabbbccc"));
        assert!(!re.is_match("ab"));      // no c
    }

    #[test]
    fn test_regex_escape() {
        let re = Regex::compile("\\(test\\)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("(test)"));
        assert!(!re.is_match("test"));
    }

    #[test]
    fn test_regex_digit_class() {
        let re = Regex::compile("\\d+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("0"));
        assert!(re.is_match("abc123"));
        assert!(!re.is_match("abc"));
    }

    #[test]
    fn test_regex_non_digit_class() {
        let re = Regex::compile("\\D+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("hello"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("123abc"));  // contains non-digits
    }

    #[test]
    fn test_regex_word_class() {
        let re = Regex::compile("\\w+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("test_123"));
        assert!(re.is_match("ABC"));
        assert!(!re.is_match("!!!"));
        assert!(re.is_match("hello!!!"));  // contains word chars
    }

    #[test]
    fn test_regex_non_word_class() {
        let re = Regex::compile("\\W+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("!!!"));
        assert!(re.is_match("   "));
        assert!(!re.is_match("hello"));
        assert!(re.is_match("hello world"));  // contains space
    }

    #[test]
    fn test_regex_whitespace_class() {
        let re = Regex::compile("\\s+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match(" "));
        assert!(re.is_match("\t"));
        assert!(re.is_match("\n"));
        assert!(re.is_match("   "));
        assert!(!re.is_match("abc"));
        assert!(re.is_match("hello world"));  // contains space
    }

    #[test]
    fn test_regex_non_whitespace_class() {
        let re = Regex::compile("\\S+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("123"));
        assert!(!re.is_match("   "));
        assert!(re.is_match("   hello"));  // contains non-whitespace
    }

    #[test]
    fn test_regex_start_anchor() {
        let re = Regex::compile("^hello");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("hello world"));
        assert!(!re.is_match("say hello"));
        assert!(!re.is_match(" hello"));
    }

    #[test]
    fn test_regex_end_anchor() {
        let re = Regex::compile("world$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("world"));
        assert!(re.is_match("hello world"));
        assert!(!re.is_match("world!"));
        assert!(!re.is_match("world "));
    }

    #[test]
    fn test_regex_both_anchors() {
        let re = Regex::compile("^hello$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(!re.is_match("hello world"));
        assert!(!re.is_match("say hello"));
        assert!(!re.is_match(" hello "));
    }

    #[test]
    fn test_regex_anchor_with_pattern() {
        let re = Regex::compile("^\\d+$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("0"));
        assert!(!re.is_match("123abc"));
        assert!(!re.is_match("abc123"));
        assert!(!re.is_match(" 123 "));
    }
}

