//! Regular expression matching with Unicode support
//!
//! This module provides DFA-based regular expression matching.
//! Only regular languages are supported (no backreferences).

// Start with just the interval set - test early, test often

use collections::{Vector, HashSet};
use string::{StringBuf, unicode};
use cmp::{sort_by_key, sort, max};

/// An interval representing a range of Unicode codepoints [start, end] inclusive
struct Interval {
    start: u32,
    end: u32
}

/// A set of Unicode codepoint intervals (sorted, non-overlapping)
/// This efficiently represents character classes like [a-zA-Z0-9]
struct IntervalSet {
    intervals: Vector<Interval>
}

impl IntervalSet {
    /// Create an empty interval set
    fn new() -> IntervalSet {
        IntervalSet {
            intervals: Vector::new()
        }
    }

    /// Create a set containing a single codepoint
    fn single(ch: u32) -> IntervalSet {
        let set = IntervalSet::new();
        set.intervals.push(Interval { start: ch, end: ch });
        set
    }

    /// Create a set from a range [start, end] inclusive
    fn range(start: u32, end: u32) -> IntervalSet {
        let set = IntervalSet::new();
        set.intervals.push(Interval { start: start, end: end });
        set
    }

    /// Check if a codepoint is in the set (binary search)
    fn contains(self: &IntervalSet, ch: u32) -> bool {
        let left = 0usize;
        let right = self.intervals.len();

        while left < right {
            let mid = left + (right - left) / 2;
            let interval = &self.intervals[mid];

            if ch < interval.start {
                right = mid;
            } else if ch > interval.end {
                left = mid + 1;
            } else {
                return true;
            }
        }

        false
    }

    /// Add an interval to the set (maintains sorted, non-overlapping invariant)
    fn add_interval(self: &mut IntervalSet, start: u32, end: u32) {
        if start > end {
            return; // Invalid interval
        }

        // Simple implementation: add and normalize
        // A more efficient implementation would merge during insertion
        self.intervals.push(Interval { start: start, end: end });
        self.normalize();
    }

    /// Add a single codepoint
    fn add(self: &mut IntervalSet, ch: u32) {
        self.add_interval(ch, ch);
    }

    /// Normalize: sort and merge overlapping/adjacent intervals
    fn normalize(self: &mut IntervalSet) {
        if self.intervals.len() <= 1 {
            return;
        }

        // Sort by start position
        self.intervals.as_slice_mut().sort_by_key(|interval: &Interval| -> u32 { interval.start });

        // Merge overlapping and adjacent intervals
        let merged: Vector<Interval> = Vector::new();
        let current = self.intervals[0];

        for i in 1usize..self.intervals.len() {
            let next = self.intervals[i];

            // Check if overlapping or adjacent (end + 1 == start means adjacent)
            if next.start <= current.end + 1 {
                // Merge: extend current to cover both
                current.end = max(next.end, current.end);
            } else {
                // No overlap: save current and start new
                merged.push(current);
                current = next;
            }
        }
        merged.push(current);

        self.intervals = merged;
    }

    /// Negate the interval set (complement within valid Unicode range)
    fn negate(self: &IntervalSet) -> IntervalSet {
        let result = IntervalSet::new();

        if self.intervals.is_empty() {
            // Empty set negated = all Unicode
            result.intervals.push(Interval { start: 0, end: 0x10FFFF });
            return result;
        }

        let prev_end = 0u32;

        for interval in self.intervals.iter() {
            if prev_end < interval.start {
                // Add gap before this interval
                if interval.start > 0 {
                    result.intervals.push(Interval {
                        start: if prev_end == 0 { 0 } else { prev_end + 1 },
                        end: interval.start - 1
                    });
                }
            }
            prev_end = interval.end;
        }

        // Add gap after last interval
        if prev_end < 0x10FFFF {
            result.intervals.push(Interval {
                start: prev_end + 1,
                end: 0x10FFFF
            });
        }

        result
    }

    /// Union of two interval sets
    fn union(self: &IntervalSet, other: &IntervalSet) -> IntervalSet {
        let result = IntervalSet::new();

        // Copy all intervals from both sets
        for interval in self.intervals.iter() {
            result.intervals.push(interval);
        }
        for interval in other.intervals.iter() {
            result.intervals.push(interval);
        }

        result.normalize();
        result
    }

    /// Move semantics - transfer ownership leaving empty set behind
    fn move(self: &mut IntervalSet) -> IntervalSet {
        let ret = *self;
        self.intervals = Vector::new();
        ret
    }

    /// Free allocated memory
    fn free(self: &mut IntervalSet) {
        self.intervals.free();
    }

    /// Create character class for \d (digits 0-9)
    fn digit_class() -> IntervalSet {
        IntervalSet::range('0' as u32, '9' as u32)
    }

    /// Create character class for \D (non-digits)
    fn non_digit_class() -> IntervalSet {
        let digits = IntervalSet::digit_class();
        defer digits.free();
        digits.negate()
    }

    /// Create character class for \w (word characters: a-z, A-Z, 0-9, _)
    fn word_class() -> IntervalSet {
        let result = IntervalSet::new();
        result.add_interval('a' as u32, 'z' as u32);
        result.add_interval('A' as u32, 'Z' as u32);
        result.add_interval('0' as u32, '9' as u32);
        result.add('_' as u32);
        result
    }

    /// Create character class for \W (non-word characters)
    fn non_word_class() -> IntervalSet {
        let word = IntervalSet::word_class();
        defer word.free();
        word.negate()
    }

    /// Create character class for \s (whitespace: space, tab, newline, carriage return, form feed)
    fn whitespace_class() -> IntervalSet {
        let result = IntervalSet::new();
        result.add(' ' as u32);   // space
        result.add('\t' as u32);  // tab
        result.add('\n' as u32);  // newline
        result.add('\r' as u32);  // carriage return
        result.add(0x0C);         // form feed
        result
    }

    /// Create character class for \S (non-whitespace)
    fn non_whitespace_class() -> IntervalSet {
        let ws = IntervalSet::whitespace_class();
        defer ws.free();
        ws.negate()
    }
}

/// NFA (Nondeterministic Finite Automaton) for regex matching
/// Uses Thompson construction algorithm

/// Transition type for NFA
struct NfaTransition {
    /// Target state
    to: usize,
    /// Character class for this transition (None = epsilon transition)
    on_chars: Option<IntervalSet>,
    /// Tags to record when crossing this transition (for captures)
    /// Tags are indices: even = group start, odd = group end
    /// Tag 0 = start of capture 0 (full match), tag 1 = end of capture 0, etc.
    tags: Vector<usize>,
}

impl NfaTransition {
    fn move(self: &mut NfaTransition) -> NfaTransition {
        let ret = *self;
        self.on_chars = Option::none();
        self.tags = Vector::new();
        ret
    }

    fn free(self: &mut NfaTransition) {
        if self.on_chars.is_some() {
            self.on_chars.unwrap().free();
        }
        self.tags.free();
    }
}

/// NFA state
struct NfaState {
    transitions: Vector<NfaTransition>,
    /// Is this an accepting/final state?
    is_final: bool,
}

impl NfaState {
    fn move(self: &mut NfaState) -> NfaState {
        let ret = *self;
        self.transitions = Vector::new();
        ret
    }

    fn free(self: &mut NfaState) {
        self.transitions.free_all();
    }
}

/// Complete NFA
struct Nfa {
    states: Vector<NfaState>,
    start: usize,
}

impl Nfa {
    /// Create a new NFA with a start state
    fn new() -> Nfa {
        let states: Vector<NfaState> = Vector::new();
        states.push(NfaState {
            transitions: Vector::new(),
            is_final: false,
        });

        Nfa {
            states: states,
            start: 0,
        }
    }

    /// Add a new state and return its index
    fn add_state(self: &mut Nfa, is_final: bool) -> usize {
        let idx = self.states.len();
        self.states.push(NfaState {
            transitions: Vector::new(),
            is_final: is_final,
        });
        idx
    }

    /// Add an epsilon transition from state `from` to state `to`
    fn add_epsilon(self: &mut Nfa, from: usize, to: usize) {
        self.states[from].transitions.push(NfaTransition {
            to: to,
            on_chars: Option::none(),
            tags: Vector::new(),
        });
    }

    /// Add an epsilon transition with tags
    fn add_epsilon_tagged(self: &mut Nfa, from: usize, to: usize, tags: Vector<usize>) {
        self.states[from].transitions.push(NfaTransition {
            to: to,
            on_chars: Option::none(),
            tags: tags,
        });
    }

    /// Add a character transition from state `from` to state `to`
    fn add_transition(self: &mut Nfa, from: usize, to: usize, chars: IntervalSet) {
        self.states[from].transitions.push(NfaTransition {
            to: to,
            on_chars: Option::some(chars),
            tags: Vector::new(),
        });
    }

    /// Add a character transition with tags
    fn add_transition_tagged(self: &mut Nfa, from: usize, to: usize, chars: IntervalSet, tags: Vector<usize>) {
        self.states[from].transitions.push(NfaTransition {
            to: to,
            on_chars: Option::some(chars),
            tags: tags,
        });
    }

    fn move(self: &mut Nfa) -> Nfa {
        let ret = *self;
        self.states = Vector::new();
        ret
    }

    fn free(self: &mut Nfa) {
        self.states.free_all();
    }
}

/// NFA fragment used during Thompson construction
/// Represents a partial NFA with designated start and end states
struct NfaFragment {
    start: usize,
    end: usize,
}

/// Regex AST node types
/// Using discriminant + union pattern since Alumina doesn't have enums
struct RegexNode {
    kind: u8,  // 0=Literal, 1=Concat, 2=Alt, 3=Star, 4=Plus, 5=Question, 6=CharClass, 7=StartAnchor, 8=EndAnchor, 9=Capture, 10=Repeat
    // Union of possible data
    literal_char: u32,
    char_class: IntervalSet,
    children: Vector<RegexNode>,
    group_id: usize,  // For capture groups
    repeat_min: usize,  // For bounded repetition
    repeat_max: Option<usize>,  // None = unbounded
}

// Kind constants
const REGEX_LITERAL: u8 = 0;
const REGEX_CONCAT: u8 = 1;
const REGEX_ALT: u8 = 2;
const REGEX_STAR: u8 = 3;
const REGEX_PLUS: u8 = 4;
const REGEX_QUESTION: u8 = 5;
const REGEX_CHAR_CLASS: u8 = 6;
const REGEX_START_ANCHOR: u8 = 7;
const REGEX_END_ANCHOR: u8 = 8;
const REGEX_CAPTURE: u8 = 9;
const REGEX_REPEAT: u8 = 10;

impl RegexNode {
    fn literal(ch: u32) -> RegexNode {
        RegexNode {
            kind: REGEX_LITERAL,
            literal_char: ch,
            char_class: IntervalSet::new(),
            children: Vector::new(),
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn char_class(class: IntervalSet) -> RegexNode {
        RegexNode {
            kind: REGEX_CHAR_CLASS,
            literal_char: 0,
            char_class: class,
            children: Vector::new(),
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn concat(nodes: Vector<RegexNode>) -> RegexNode {
        RegexNode {
            kind: REGEX_CONCAT,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: nodes,
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn alt(left: RegexNode, right: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(left);
        children.push(right);
        RegexNode {
            kind: REGEX_ALT,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn star(node: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(node);
        RegexNode {
            kind: REGEX_STAR,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn plus(node: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(node);
        RegexNode {
            kind: REGEX_PLUS,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn question(node: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(node);
        RegexNode {
            kind: REGEX_QUESTION,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn start_anchor() -> RegexNode {
        RegexNode {
            kind: REGEX_START_ANCHOR,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: Vector::new(),
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn end_anchor() -> RegexNode {
        RegexNode {
            kind: REGEX_END_ANCHOR,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: Vector::new(),
            group_id: 0,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn capture(group_id: usize, inner: RegexNode) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(inner);
        RegexNode {
            kind: REGEX_CAPTURE,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
            group_id: group_id,
            repeat_min: 0,
            repeat_max: Option::none(),
        }
    }

    fn repeat(node: RegexNode, min: usize, max: Option<usize>) -> RegexNode {
        let children: Vector<RegexNode> = Vector::new();
        children.push(node);
        RegexNode {
            kind: REGEX_REPEAT,
            literal_char: 0,
            char_class: IntervalSet::new(),
            children: children,
            group_id: 0,
            repeat_min: min,
            repeat_max: max,
        }
    }

    fn move(self: &mut RegexNode) -> RegexNode {
        let ret = *self;
        self.children = Vector::new();
        self.char_class = IntervalSet::new();
        ret
    }

    fn free(self: &mut RegexNode) {
        self.children.free_all();
        self.char_class.free();
    }
}

/// Thompson construction: Convert regex AST to NFA
fn thompson_construct(node: &RegexNode, nfa: &mut Nfa) -> NfaFragment {
    if node.kind == REGEX_LITERAL {
        // Create: start --ch--> end
        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        let chars = IntervalSet::single(node.literal_char);
        nfa.add_transition(start, end, chars);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_CHAR_CLASS {
        // Create: start --[class]--> end
        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Clone the character class
        let chars = IntervalSet::new();
        for interval in node.char_class.intervals.iter() {
            chars.intervals.push(interval);
        }
        nfa.add_transition(start, end, chars);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_CONCAT {
        // Concatenation: connect fragments in sequence
        if node.children.is_empty() {
            // Empty concatenation - epsilon transition
            let start = nfa.states.len();
            nfa.add_state(false);
            let end = nfa.add_state(true);
            nfa.add_epsilon(start, end);
            return NfaFragment { start: start, end: end };
        }

        let first_frag = thompson_construct(&node.children[0], nfa);
        let overall_start = first_frag.start;
        let prev_end = first_frag.end;

        for i in 1usize..node.children.len() {
            let frag = thompson_construct(&node.children[i], nfa);
            // Connect previous end to this start
            nfa.states[prev_end].is_final = false;
            nfa.add_epsilon(prev_end, frag.start);
            prev_end = frag.end;
        }

        NfaFragment { start: overall_start, end: prev_end }
    } else if node.kind == REGEX_ALT {
        // Alternation: start -ε-> (left | right) -ε-> end
        let left_frag = thompson_construct(&node.children[0], nfa);
        let right_frag = thompson_construct(&node.children[1], nfa);

        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Connect start to both alternatives
        nfa.add_epsilon(start, left_frag.start);
        nfa.add_epsilon(start, right_frag.start);

        // Connect both alternatives to end
        nfa.states[left_frag.end].is_final = false;
        nfa.states[right_frag.end].is_final = false;
        nfa.add_epsilon(left_frag.end, end);
        nfa.add_epsilon(right_frag.end, end);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_STAR {
        // Star: start -ε-> (inner -ε-> start) and start -ε-> end
        let inner_frag = thompson_construct(&node.children[0], nfa);

        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Connect start to inner and to end (zero occurrences)
        nfa.add_epsilon(start, inner_frag.start);
        nfa.add_epsilon(start, end);

        // Connect inner end back to inner start (repeat)
        nfa.states[inner_frag.end].is_final = false;
        nfa.add_epsilon(inner_frag.end, inner_frag.start);
        nfa.add_epsilon(inner_frag.end, end);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_PLUS {
        // Plus: same as star but no epsilon from start to end
        let inner_frag = thompson_construct(&node.children[0], nfa);

        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Connect start to inner (at least one occurrence)
        nfa.add_epsilon(start, inner_frag.start);

        // Connect inner end back to inner start (repeat) and to end
        nfa.states[inner_frag.end].is_final = false;
        nfa.add_epsilon(inner_frag.end, inner_frag.start);
        nfa.add_epsilon(inner_frag.end, end);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_QUESTION {
        // Question: start -ε-> inner -ε-> end, and start -ε-> end
        let inner_frag = thompson_construct(&node.children[0], nfa);

        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Connect start to inner and to end (optional)
        nfa.add_epsilon(start, inner_frag.start);
        nfa.add_epsilon(start, end);

        // Connect inner end to end
        nfa.states[inner_frag.end].is_final = false;
        nfa.add_epsilon(inner_frag.end, end);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_CAPTURE {
        // Capture group: add tags for start/end boundaries
        // Tag numbering: group N has start_tag = 2*N, end_tag = 2*N + 1
        let group_id = node.group_id;
        let start_tag = 2usize * group_id;
        let end_tag = 2usize * group_id + 1usize;

        // Build inner fragment
        let inner_frag = thompson_construct(&node.children[0], nfa);

        // Create wrapper with tagged epsilon transitions
        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);

        // Add epsilon with start tag: start -[tag:start]-> inner_start
        let start_tags: Vector<usize> = Vector::new();
        start_tags.push(start_tag);
        nfa.add_epsilon_tagged(start, inner_frag.start, start_tags);

        // Add epsilon with end tag: inner_end -[tag:end]-> end
        nfa.states[inner_frag.end].is_final = false;
        let end_tags: Vector<usize> = Vector::new();
        end_tags.push(end_tag);
        nfa.add_epsilon_tagged(inner_frag.end, end, end_tags);

        NfaFragment { start: start, end: end }
    } else if node.kind == REGEX_REPEAT {
        // Bounded repetition: {n,m}
        // Construct as: inner{n} inner?{m-n} (when m is Some)
        // Or: inner{n} inner* (when m is None, meaning unbounded)
        let min = node.repeat_min;
        let max = node.repeat_max;

        let fragments: Vector<NfaFragment> = Vector::new();
        defer fragments.free();

        // Create min required copies
        for _ in 0usize..min {
            let frag = thompson_construct(&node.children[0], nfa);
            fragments.push(frag);
        }

        // If there's a max, create (max - min) optional copies
        if max.is_some() {
            let max_val = max.unwrap();
            if max_val > min {
                for _ in 0usize..(max_val - min) {
                    let frag = thompson_construct(&node.children[0], nfa);
                    fragments.push(frag);
                }
            }
        }
        // Note: for unbounded (max is None), we don't add extra fragments here
        // Instead, we'll make the last fragment loop back to itself

        if fragments.is_empty() {
            // {0} or {0,0} - matches empty string
            let start = nfa.states.len();
            nfa.add_state(false);
            let end = nfa.add_state(true);
            nfa.add_epsilon(start, end);
            return NfaFragment { start: start, end: end };
        }

        // Chain all fragments together
        let start = fragments[0].start;

        // First, connect all required fragments in sequence
        let num_required = if min < fragments.len() { min } else { fragments.len() };
        for i in 0usize..(num_required - 1) {
            nfa.states[fragments[i].end].is_final = false;
            nfa.add_epsilon(fragments[i].end, fragments[i + 1].start);
        }

        // If we have optional fragments (when max > min)
        if fragments.len() > min {
            // Create a shared end state
            let final_end = nfa.add_state(true);

            // The last required fragment can either stop here OR continue to optional
            nfa.states[fragments[min - 1].end].is_final = false;
            nfa.add_epsilon(fragments[min - 1].end, final_end);  // Can stop after required
            if min < fragments.len() {
                nfa.add_epsilon(fragments[min - 1].end, fragments[min].start);  // Or continue to optional
            }

            // Connect optional fragments, each can skip to the end
            for i in min..(fragments.len() - 1) {
                nfa.states[fragments[i].end].is_final = false;
                nfa.add_epsilon(fragments[i].end, fragments[i + 1].start);  // Continue to next
                nfa.add_epsilon(fragments[i].end, final_end);  // Or stop here
            }

            // Last fragment (optional) also points to end
            nfa.states[fragments[fragments.len() - 1].end].is_final = false;
            nfa.add_epsilon(fragments[fragments.len() - 1].end, final_end);

            NfaFragment { start: start, end: final_end }
        } else {
            // No optional fragments - just return the last required fragment
            // Handle unbounded case
            if max.is_none() && !fragments.is_empty() {
                // Unbounded - make the last required fragment loop back (like star)
                let last_frag = &fragments[fragments.len() - 1];
                nfa.add_epsilon(last_frag.end, last_frag.start);
            }

            NfaFragment { start: start, end: fragments[fragments.len() - 1].end }
        }
    } else {
        // Unknown node type - create empty epsilon transition
        let start = nfa.states.len();
        nfa.add_state(false);
        let end = nfa.add_state(true);
        nfa.add_epsilon(start, end);
        NfaFragment { start: start, end: end }
    }
}

/// Simple regex parser
/// Parses a subset of regex syntax: literals, ., *, +, ?, |, (), []
struct RegexParser {
    input: &[u8],
    pos: usize,
    next_group_id: usize,  // Track next capture group number (0 = full match, 1+ = user groups)
}

impl RegexParser {
    fn new(pattern: &[u8]) -> RegexParser {
        RegexParser {
            input: pattern,
            pos: 0,
            next_group_id: 1,  // Start at 1 (0 is reserved for full match)
        }
    }

    fn peek(self: &RegexParser) -> Option<u8> {
        if self.pos < self.input.len() {
            Option::some(self.input[self.pos])
        } else {
            Option::none()
        }
    }

    fn advance(self: &mut RegexParser) {
        if self.pos < self.input.len() {
            self.pos += 1;
        }
    }

    fn peek_char(self: &RegexParser) -> Option<u32> {
        if self.pos >= self.input.len() {
            return Option::none();
        }
        let decoded = unicode::decode_utf8(self.input[self.pos..]);
        if decoded.is_ok() {
            let (ch, _) = decoded.unwrap();
            Option::some(ch)
        } else {
            Option::none()
        }
    }

    fn consume_char(self: &mut RegexParser) -> Option<u32> {
        if self.pos >= self.input.len() {
            return Option::none();
        }
        let decoded = unicode::decode_utf8(self.input[self.pos..]);
        if decoded.is_ok() {
            let (ch, len) = decoded.unwrap();
            self.pos += len;
            Option::some(ch)
        } else {
            Option::none()
        }
    }

    /// Parse full regex
    fn parse(self: &mut RegexParser) -> Result<RegexNode, ()> {
        self.parse_alternation()
    }

    /// Parse alternation (lowest precedence): a|b|c
    fn parse_alternation(self: &mut RegexParser) -> Result<RegexNode, ()> {
        let left = self.parse_concatenation();
        if left.is_err() {
            return left;
        }
        let left = left.unwrap();

        let ch = self.peek();
        if ch.is_some() && ch.unwrap() == '|' {
            self.advance();
            let right = self.parse_alternation();
            if right.is_err() {
                left.free();
                return right;
            }
            Result::ok(RegexNode::alt(left, right.unwrap()))
        } else {
            Result::ok(left)
        }
    }

    /// Parse concatenation: abc
    fn parse_concatenation(self: &mut RegexParser) -> Result<RegexNode, ()> {
        let nodes: Vector<RegexNode> = Vector::new();

        loop {
            let ch = self.peek();
            if ch.is_none() || ch.unwrap() == '|' || ch.unwrap() == ')' {
                break;
            }

            let node = self.parse_postfix();
            if node.is_err() {
                nodes.free_all();
                return node;
            }
            nodes.push(node.unwrap());
        }

        if nodes.is_empty() {
            // Empty concatenation - matches empty string
            Result::ok(RegexNode::concat(nodes))
        } else if nodes.len() == 1 {
            // Single node - no need for concat wrapper
            let result = nodes[0].move();
            nodes.free();
            Result::ok(result)
        } else {
            Result::ok(RegexNode::concat(nodes))
        }
    }

    /// Parse postfix operators: *, +, ?
    fn parse_postfix(self: &mut RegexParser) -> Result<RegexNode, ()> {
        let base = self.parse_atom();
        if base.is_err() {
            return base;
        }
        let base = base.unwrap();

        let ch = self.peek();
        if ch.is_none() {
            return Result::ok(base);
        }

        if ch.unwrap() == '*' {
            self.advance();
            Result::ok(RegexNode::star(base))
        } else if ch.unwrap() == '+' {
            self.advance();
            Result::ok(RegexNode::plus(base))
        } else if ch.unwrap() == '?' {
            self.advance();
            Result::ok(RegexNode::question(base))
        } else if ch.unwrap() == '{' {
            // Bounded repetition: {n}, {n,}, {n,m}
            self.advance();

            // Parse min count
            let min_result = self.parse_number();
            if min_result.is_err() {
                base.free();
                return Result::err(());
            }
            let min = min_result.unwrap();

            let ch2 = self.peek();
            if ch2.is_none() {
                base.free();
                return Result::err(());
            }

            if ch2.unwrap() == '}' {
                // {n} - exact count
                self.advance();
                Result::ok(RegexNode::repeat(base, min, Option::some(min)))
            } else if ch2.unwrap() == ',' {
                self.advance();
                let ch3 = self.peek();
                if ch3.is_none() {
                    base.free();
                    return Result::err(());
                }

                if ch3.unwrap() == '}' {
                    // {n,} - at least n
                    self.advance();
                    Result::ok(RegexNode::repeat(base, min, Option::none()))
                } else {
                    // {n,m} - between n and m
                    let max_result = self.parse_number();
                    if max_result.is_err() {
                        base.free();
                        return Result::err(());
                    }
                    let max = max_result.unwrap();

                    if self.peek().is_none() || self.peek().unwrap() != '}' {
                        base.free();
                        return Result::err(());
                    }
                    self.advance();

                    Result::ok(RegexNode::repeat(base, min, Option::some(max)))
                }
            } else {
                base.free();
                Result::err(())
            }
        } else {
            Result::ok(base)
        }
    }

    /// Parse a decimal number from the input
    fn parse_number(self: &mut RegexParser) -> Result<usize, ()> {
        let start_pos = self.pos;

        while self.pos < self.input.len() {
            let ch = self.input[self.pos];
            if ch >= '0' && ch <= '9' {
                self.pos += 1;
            } else {
                break;
            }
        }

        if self.pos == start_pos {
            return Result::err(());  // No digits found
        }

        // Convert to number
        let result = 0usize;
        for i in start_pos..self.pos {
            let digit = (self.input[i] - '0') as usize;
            result = result * 10usize + digit;
        }

        Result::ok(result)
    }

    /// Parse hex escape sequence: \xHH or \uHHHH
    fn parse_hex_escape(self: &mut RegexParser, num_digits: usize) -> Result<RegexNode, ()> {
        let value_result = self.parse_hex_value(num_digits);
        if value_result.is_err() {
            return Result::err(());
        }
        Result::ok(RegexNode::literal(value_result.unwrap()))
    }

    /// Parse atomic expression: literal, ., [], ()
    fn parse_atom(self: &mut RegexParser) -> Result<RegexNode, ()> {
        let ch = self.peek();
        if ch.is_none() {
            return Result::err(());
        }

        if ch.unwrap() == '(' {
            // Group (capturing or non-capturing)
            self.advance();

            // Check for non-capturing group (?:...)
            let is_non_capturing = false;
            if self.peek().is_some() && self.peek().unwrap() == '?' {
                self.advance();
                if self.peek().is_some() && self.peek().unwrap() == ':' {
                    self.advance();
                    is_non_capturing = true;
                } else {
                    // Invalid syntax after (?
                    return Result::err(());
                }
            }

            // Assign group ID BEFORE parsing inner content (for correct nesting order)
            let group_id = if !is_non_capturing {
                let id = self.next_group_id;
                self.next_group_id += 1;
                id
            } else {
                0  // Placeholder, won't be used
            };

            let inner = self.parse_alternation();
            if inner.is_err() {
                return inner;
            }
            let closing = self.peek();
            if closing.is_none() || closing.unwrap() != ')' {
                inner.unwrap().free();
                return Result::err(());
            }
            self.advance();

            if is_non_capturing {
                // Non-capturing group - just return the inner node
                inner
            } else {
                // Capturing group - wrap in capture node with pre-assigned group ID
                Result::ok(RegexNode::capture(group_id, inner.unwrap()))
            }
        } else if ch.unwrap() == '.' {
            // Any character (except newline)
            self.advance();
            let any_char = IntervalSet::new();
            any_char.add_interval(0, 0x10FFFF);
            // Remove newline
            let newline = IntervalSet::single('\n' as u32);
            defer newline.free();
            let without_newline = any_char.union(&newline.negate());
            any_char.free();
            Result::ok(RegexNode::char_class(without_newline))
        } else if ch.unwrap() == '[' {
            // Character class
            self.parse_char_class()
        } else if ch.unwrap() == '\\' {
            // Escape sequence
            self.advance();
            let escaped = self.consume_char();
            if escaped.is_none() {
                return Result::err(());
            }
            let esc = escaped.unwrap();

            // Check for character class escapes
            if esc == 'd' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::digit_class()))
            } else if esc == 'D' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::non_digit_class()))
            } else if esc == 'w' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::word_class()))
            } else if esc == 'W' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::non_word_class()))
            } else if esc == 's' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::whitespace_class()))
            } else if esc == 'S' as u32 {
                Result::ok(RegexNode::char_class(IntervalSet::non_whitespace_class()))
            } else if esc == 't' as u32 {
                Result::ok(RegexNode::literal('\t' as u32))
            } else if esc == 'n' as u32 {
                Result::ok(RegexNode::literal('\n' as u32))
            } else if esc == 'r' as u32 {
                Result::ok(RegexNode::literal('\r' as u32))
            } else if esc == 'x' as u32 {
                // Hex escape: \xHH
                self.parse_hex_escape(2)
            } else if esc == 'u' as u32 {
                // Unicode escape: \uHHHH
                self.parse_hex_escape(4)
            } else {
                // Regular escaped character (e.g., \(, \), \*, \., \\, etc.)
                Result::ok(RegexNode::literal(esc))
            }
        } else {
            // Literal character
            let literal = self.consume_char();
            if literal.is_none() {
                return Result::err(());
            }
            Result::ok(RegexNode::literal(literal.unwrap()))
        }
    }

    /// Parse a single character in a character class (handles escapes)
    fn parse_class_char(self: &mut RegexParser) -> Result<u32, ()> {
        if self.peek().is_none() {
            return Result::err(());
        }

        if self.peek().unwrap() == '\\' {
            self.advance();
            let esc = self.consume_char();
            if esc.is_none() {
                return Result::err(());
            }
            let esc_ch = esc.unwrap();

            // Handle escape sequences
            if esc_ch == 't' as u32 {
                Result::ok('\t' as u32)
            } else if esc_ch == 'n' as u32 {
                Result::ok('\n' as u32)
            } else if esc_ch == 'r' as u32 {
                Result::ok('\r' as u32)
            } else if esc_ch == 'x' as u32 {
                // Hex escape
                let value_result = self.parse_hex_value(2);
                if value_result.is_err() {
                    return Result::err(());
                }
                Result::ok(value_result.unwrap())
            } else if esc_ch == 'u' as u32 {
                // Unicode escape
                let value_result = self.parse_hex_value(4);
                if value_result.is_err() {
                    return Result::err(());
                }
                Result::ok(value_result.unwrap())
            } else {
                // Literal escaped character (e.g., \], \-, \\)
                Result::ok(esc_ch)
            }
        } else {
            let ch = self.consume_char();
            if ch.is_some() {
                Result::ok(ch.unwrap())
            } else {
                Result::err(())
            }
        }
    }

    /// Parse hex value (helper for parse_hex_escape and parse_class_char)
    fn parse_hex_value(self: &mut RegexParser, num_digits: usize) -> Result<u32, ()> {
        let value = 0u32;

        for _ in 0usize..num_digits {
            if self.pos >= self.input.len() {
                return Result::err(());
            }

            let ch = self.input[self.pos];
            let digit: u32;

            if ch >= '0' && ch <= '9' {
                digit = (ch - '0') as u32;
            } else if ch >= 'a' && ch <= 'f' {
                digit = (ch - 'a') as u32 + 10u32;
            } else if ch >= 'A' && ch <= 'F' {
                digit = (ch - 'A') as u32 + 10u32;
            } else {
                return Result::err(());
            }

            value = value * 16u32 + digit;
            self.pos += 1;
        }

        // Validate Unicode codepoint range
        if value > 0x10FFFF {
            return Result::err(());
        }

        Result::ok(value)
    }

    /// Parse character class: [abc], [a-z], [^abc]
    fn parse_char_class(self: &mut RegexParser) -> Result<RegexNode, ()> {
        if self.peek().is_none() || self.peek().unwrap() != '[' {
            return Result::err(());
        }
        self.advance();

        let negated = false;
        if self.peek().is_some() && self.peek().unwrap() == '^' {
            negated = true;
            self.advance();
        }

        let class = IntervalSet::new();

        loop {
            let ch = self.peek();
            if ch.is_none() {
                class.free();
                return Result::err(());
            }
            if ch.unwrap() == ']' {
                self.advance();
                break;
            }

            let start_result = self.parse_class_char();
            if start_result.is_err() {
                class.free();
                return Result::err(());
            }
            let start = start_result.unwrap();

            // Check for range
            if self.peek().is_some() && self.peek().unwrap() == '-' {
                self.advance();
                // Check if this is the end of the class
                if self.peek().is_some() && self.peek().unwrap() == ']' {
                    // Literal '-'
                    class.add(start);
                    class.add('-' as u32);
                } else {
                    let end_result = self.parse_class_char();
                    if end_result.is_err() {
                        class.free();
                        return Result::err(());
                    }
                    class.add_interval(start, end_result.unwrap());
                }
            } else {
                class.add(start);
            }
        }

        if negated {
            let negated_class = class.negate();
            class.free();
            Result::ok(RegexNode::char_class(negated_class))
        } else {
            Result::ok(RegexNode::char_class(class))
        }
    }
}

/// Result of epsilon closure computation - states and accumulated tags
struct EpsilonClosureResult {
    states: HashSet<usize>,
    tags: Vector<usize>,
}

impl EpsilonClosureResult {
    fn free(self: &mut EpsilonClosureResult) {
        self.states.free();
        self.tags.free();
    }
}

/// Compute epsilon closure of a set of NFA states
/// Returns all states reachable via epsilon transitions, plus tags encountered
fn epsilon_closure(nfa: &Nfa, states: &HashSet<usize>) -> EpsilonClosureResult {
    let result: HashSet<usize> = HashSet::new();
    let tags: Vector<usize> = Vector::new();
    let stack: Vector<usize> = Vector::new();
    defer stack.free();

    // Start with the input states
    for state in states.iter() {
        result.insert(state);
        stack.push(state);
    }

    // Process stack: follow epsilon transitions and collect tags
    while !stack.is_empty() {
        let current = stack.pop().unwrap();

        for trans in nfa.states[current].transitions.iter() {
            if trans.on_chars.is_none() {
                // Epsilon transition - collect its tags
                for tag in trans.tags.iter() {
                    tags.push(tag);
                }

                if !result.contains(&trans.to) {
                    result.insert(trans.to);
                    stack.push(trans.to);
                }
            }
        }
    }

    EpsilonClosureResult {
        states: result,
        tags: tags,
    }
}

/// Result of move operation - states and accumulated tags
struct MoveResult {
    states: HashSet<usize>,
    tags: Vector<usize>,
}

impl MoveResult {
    fn free(self: &mut MoveResult) {
        self.states.free();
        self.tags.free();
    }
}

/// Compute the set of NFA states reachable from a set of states on a character
/// Also collects tags from the transitions taken
fn move_on_char(nfa: &Nfa, states: &HashSet<usize>, ch: u32) -> MoveResult {
    let result: HashSet<usize> = HashSet::new();
    let tags: Vector<usize> = Vector::new();

    for state in states.iter() {
        for trans in nfa.states[state].transitions.iter() {
            if trans.on_chars.is_some() {
                let chars = trans.on_chars.unwrap();
                if chars.contains(ch) {
                    result.insert(trans.to);
                    // Collect tags from this transition
                    for tag in trans.tags.iter() {
                        tags.push(tag);
                    }
                }
            }
        }
    }

    MoveResult {
        states: result,
        tags: tags,
    }
}

/// Hash a set of NFA states to use as a key in the state map
fn hash_state_set(states: &HashSet<usize>) -> u64 {
    use hash::DefaultHash;

    // Convert to sorted vector for consistent hashing
    let sorted: Vector<usize> = Vector::new();
    defer sorted.free();

    for state in states.iter() {
        sorted.push(state);
    }
    sort(sorted.as_slice_mut());

    // Hash the sorted states
    let hasher = DefaultHash::new();
    for state in sorted.iter() {
        state.hash(&hasher);
    }
    hasher.finish()
}

/// Collect all distinct character classes from transitions in a state set
/// This splits overlapping intervals into non-overlapping character classes
fn collect_character_classes(nfa: &Nfa, states: &HashSet<usize>) -> Vector<IntervalSet> {
    // Collect all intervals from all transitions
    let all_intervals: Vector<Interval> = Vector::new();
    defer all_intervals.free();

    for state in states.iter() {
        for trans in nfa.states[state].transitions.iter() {
            if trans.on_chars.is_some() {
                let chars = trans.on_chars.unwrap();
                for interval in chars.intervals.iter() {
                    all_intervals.push(interval);
                }
            }
        }
    }

    if all_intervals.is_empty() {
        return Vector::new();
    }

    // Collect all boundary points
    let boundaries: Vector<u32> = Vector::new();
    defer boundaries.free();

    for interval in all_intervals.iter() {
        boundaries.push(interval.start);
        if interval.end < 0x10FFFF {
            boundaries.push(interval.end + 1);
        }
    }

    // Sort and deduplicate boundaries
    sort(boundaries.as_slice_mut());
    let unique_boundaries: Vector<u32> = Vector::new();
    defer unique_boundaries.free();

    if !boundaries.is_empty() {
        unique_boundaries.push(boundaries[0]);
        for i in 1usize..boundaries.len() {
            if boundaries[i] != boundaries[i - 1] {
                unique_boundaries.push(boundaries[i]);
            }
        }
    }

    // Create character classes from boundaries
    let char_classes: Vector<IntervalSet> = Vector::new();

    for i in 0usize..unique_boundaries.len() {
        let start = unique_boundaries[i];
        let end = if i + 1 < unique_boundaries.len() {
            unique_boundaries[i + 1] - 1
        } else {
            0x10FFFF
        };

        // Check if this range is covered by any original interval
        let mid = start;
        let covered = false;
        for interval in all_intervals.iter() {
            if mid >= interval.start && mid <= interval.end {
                covered = true;
                break;
            }
        }

        if covered {
            let class = IntervalSet::range(start, end);
            char_classes.push(class);
        }
    }

    char_classes
}

/// DFA (Deterministic Finite Automaton) compiled from NFA
/// Each state has exactly one transition per character class

/// DFA transition - maps a character class to a destination state
struct DfaTransition {
    chars: IntervalSet,
    to: usize,
    /// Tags to record when crossing this transition (for captures)
    tags: Vector<usize>,
}

impl DfaTransition {
    fn move(self: &mut DfaTransition) -> DfaTransition {
        let ret = *self;
        self.chars = IntervalSet::new();
        self.tags = Vector::new();
        ret
    }

    fn free(self: &mut DfaTransition) {
        self.chars.free();
        self.tags.free();
    }
}

/// DFA state
struct DfaState {
    transitions: Vector<DfaTransition>,
    is_final: bool,
    /// Tags to record when entering this state (from epsilon closures)
    entry_tags: Vector<usize>,
}

impl DfaState {
    fn move(self: &mut DfaState) -> DfaState {
        let ret = *self;
        self.transitions = Vector::new();
        self.entry_tags = Vector::new();
        ret
    }

    fn free(self: &mut DfaState) {
        self.transitions.free_all();
        self.entry_tags.free();
    }
}

/// Complete DFA
struct Dfa {
    states: Vector<DfaState>,
    start: usize,
}

impl Dfa {
    /// Create empty DFA
    fn new() -> Dfa {
        Dfa {
            states: Vector::new(),
            start: 0,
        }
    }

    /// Convert an NFA to a DFA using subset construction
    fn from_nfa(nfa: &Nfa) -> Dfa {
        use collections::HashMap;

        let dfa = Dfa::new();

        // Map from NFA state set to DFA state index
        let state_map: HashMap<u64, usize> = HashMap::new();
        defer state_map.free();

        let work_list: Vector<HashSet<usize>> = Vector::new();
        defer work_list.free_all();

        // Compute initial state (epsilon closure of NFA start state)
        let start_set: HashSet<usize> = HashSet::new();
        defer start_set.free();

        start_set.insert(nfa.start);
        let start_closure_result = epsilon_closure(nfa, &start_set);

        // Check if start state is final
        let is_start_final = false;
        for s in start_closure_result.states.iter() {
            if nfa.states[s].is_final {
                is_start_final = true;
                break;
            }
        }

        // Add start state to DFA (with entry tags from initial epsilon closure)
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: is_start_final,
            entry_tags: start_closure_result.tags.move(),
        });

        let start_hash = hash_state_set(&start_closure_result.states);
        state_map.insert(start_hash, 0);
        work_list.push(start_closure_result.states.move());

        // Process work list
        while !work_list.is_empty() {
            let current_set = work_list.pop().unwrap();

            let current_hash = hash_state_set(&current_set);
            let current_idx = state_map.get(&current_hash).unwrap();

            // Collect all possible character classes from this state set
            let char_classes = collect_character_classes(nfa, &current_set);

            // For each character class, compute the next state
            for char_class in char_classes.iter() {
                // Find a representative character in this class
                if char_class.intervals.is_empty() {
                    continue;
                }
                let rep_char = char_class.intervals[0].start;

                // Compute next state set and collect tags
                let move_result = move_on_char(nfa, &current_set, rep_char);
                let closure_result = epsilon_closure(nfa, &move_result.states);

                // Tags from move go on the transition
                // Tags from epsilon closure become entry tags for the destination state
                let trans_tags = move_result.tags.move();
                let entry_tags_for_dest = closure_result.tags.move();
                move_result.free();

                if closure_result.states.is_empty() {
                    closure_result.states.free();
                    trans_tags.free();
                    entry_tags_for_dest.free();
                    continue;
                }

                // Check if this state set already exists
                let next_hash = hash_state_set(&closure_result.states);
                let existing = state_map.get(&next_hash);
                let next_idx = if existing.is_some() {
                    // State already exists, free the closure and entry tags
                    closure_result.states.free();
                    entry_tags_for_dest.free();
                    existing.unwrap()
                } else {
                    // Create new DFA state with entry tags
                    let new_idx = dfa.states.len();
                    let is_final = false;
                    for s in closure_result.states.iter() {
                        if nfa.states[s].is_final {
                            is_final = true;
                            break;
                        }
                    }

                    dfa.states.push(DfaState {
                        transitions: Vector::new(),
                        is_final: is_final,
                        entry_tags: entry_tags_for_dest,
                    });

                    state_map.insert(next_hash, new_idx);
                    work_list.push(closure_result.states.move());  // Transfer ownership to work_list
                    new_idx
                };

                // Add transition to current DFA state with tags
                // Note: char_class is being moved here, so we need to avoid reusing it
                dfa.states[current_idx].transitions.push(DfaTransition {
                    chars: char_class,
                    to: next_idx,
                    tags: trans_tags,
                });
            }

            // char_classes elements were moved, just free the vector itself
            char_classes.free();
            current_set.free();
        }

        dfa
    }

    /// Check if text matches (simple boolean match)
    fn is_match(self: &Dfa, text: &[u8]) -> bool {
        self.find(text).is_some()
    }

    /// Find first match position
    fn find(self: &Dfa, text: &[u8]) -> Option<(usize, usize)> {
        // Try starting the match at each position
        for start_pos in 0usize..text.len() + 1 {
            let result = self.match_from(text, start_pos);
            if result.is_some() {
                return Option::some((start_pos, result.unwrap()));
            }
        }
        Option::none()
    }

    /// Try to match starting from a specific position
    fn match_from(self: &Dfa, text: &[u8], start_pos: usize) -> Option<usize> {
        let state = self.start;
        let pos = start_pos;
        let last_accept: Option<usize> = Option::none();

        // Check if start state is final
        if self.states[state].is_final {
            last_accept = Option::some(pos);
        }

        while pos < text.len() {
            // Decode UTF-8 codepoint
            let decoded = unicode::decode_utf8(text[pos..]);
            if decoded.is_err() {
                return last_accept; // Invalid UTF-8
            }

            let (ch, bytes) = decoded.unwrap();

            // Find transition for this character
            let next_state: Option<usize> = Option::none();
            for trans in self.states[state].transitions.iter() {
                if trans.chars.contains(ch) {
                    next_state = Option::some(trans.to);
                    break;
                }
            }

            if next_state.is_none() {
                return last_accept; // No transition found
            }

            state = next_state.unwrap();
            pos += bytes;

            // Update last accepting position
            if self.states[state].is_final {
                last_accept = Option::some(pos);
            }
        }

        // End of input - return last accept or current if accepting
        if self.states[state].is_final {
            Option::some(pos)
        } else {
            last_accept
        }
    }

    /// Match from a position and track capture groups
    /// Returns (end_pos, tag_positions) where tag_positions[i] is the byte position when tag i was recorded
    fn match_with_captures(self: &Dfa, text: &[u8], start_pos: usize, num_tags: usize) -> Option<(usize, Vector<usize>)> {
        let state = self.start;
        let pos = start_pos;
        let last_accept: Option<(usize, Vector<usize>)> = Option::none();

        // Track positions for each tag
        let tag_positions: Vector<usize> = Vector::new();
        for _ in 0usize..num_tags {
            tag_positions.push(0);
        }

        // Record entry tags for the start state
        for tag in self.states[state].entry_tags.iter() {
            tag_positions[tag] = pos;
        }

        // Check if start state is final
        if self.states[state].is_final {
            // Clone tag positions for last_accept
            last_accept = Option::some((pos, tag_positions.clone()));
        }

        while pos < text.len() {
            // Decode UTF-8 codepoint
            let decoded = unicode::decode_utf8(text[pos..]);
            if decoded.is_err() {
                tag_positions.free();
                return last_accept; // Invalid UTF-8
            }

            let (ch, bytes) = decoded.unwrap();

            // Find transition for this character
            let next_trans_idx: Option<usize> = Option::none();
            for i in 0usize..self.states[state].transitions.len() {
                let trans = &self.states[state].transitions[i];
                if trans.chars.contains(ch) {
                    next_trans_idx = Option::some(i);
                    break;
                }
            }

            if next_trans_idx.is_none() {
                tag_positions.free();
                return last_accept; // No transition found
            }

            let trans = &self.states[state].transitions[next_trans_idx.unwrap()];

            state = trans.to;
            pos += bytes;

            // Record tags from this transition (after advancing position)
            for tag in trans.tags.iter() {
                tag_positions[tag] = pos;
            }

            // Record entry tags for the destination state
            for tag in self.states[state].entry_tags.iter() {
                tag_positions[tag] = pos;
            }

            // Update last accepting position
            if self.states[state].is_final {
                // Free old last_accept if it exists
                if last_accept.is_some() {
                    last_accept.unwrap().1.free();
                }
                // Clone tag positions for last_accept
                last_accept = Option::some((pos, tag_positions.clone()));
            }
        }

        // End of input - return last accept or current if accepting
        if self.states[state].is_final {
            // Free old last_accept if it exists
            if last_accept.is_some() {
                last_accept.unwrap().1.free();
            }
            Option::some((pos, tag_positions))
        } else {
            tag_positions.free();
            last_accept
        }
    }

    fn move(self: &mut Dfa) -> Dfa {
        let ret = *self;
        self.states = Vector::new();
        ret
    }

    fn free(self: &mut Dfa) {
        self.states.free_all();
    }
}

/// Public Regex API
/// Compiled regular expression that can be used for matching
struct Regex {
    dfa: Dfa,
    anchored_start: bool,  // Pattern starts with ^
    anchored_end: bool,    // Pattern ends with $
    num_groups: usize,     // Number of capture groups (including group 0)
}

impl Regex {
    /// Compile a regex pattern
    fn compile(pattern: &[u8]) -> Result<Regex, ()> {
        // Check for anchors and strip them (but not if they're escaped)
        let anchored_start = pattern.len() > 0 && pattern[0] == '^';

        // Check if end anchor is present and not escaped
        let anchored_end = if pattern.len() > 0 && pattern[pattern.len() - 1] == '$' {
            // Count preceding backslashes
            let num_backslashes = 0usize;
            let i = pattern.len() - 1;
            while i > num_backslashes && pattern[i - num_backslashes - 1] == '\\' {
                num_backslashes += 1;
            }
            // If even number of backslashes (including 0), $ is not escaped
            num_backslashes % 2 == 0
        } else {
            false
        };

        let start_offset = if anchored_start { 1usize } else { 0usize };
        let end_offset = if anchored_end { pattern.len() - 1 } else { pattern.len() };

        // Get the actual pattern without anchors
        let actual_pattern = if start_offset < end_offset {
            pattern[start_offset..end_offset]
        } else {
            pattern[0usize..0usize]  // Empty pattern
        };

        // Parse the pattern
        let parser = RegexParser::new(actual_pattern);
        let ast = parser.parse();
        if ast.is_err() {
            return Result::err(());
        }
        let ast = ast.unwrap();
        defer ast.free();

        // Capture the number of groups (next_group_id is one past the last group)
        let num_groups = parser.next_group_id;

        // Build NFA using Thompson construction
        let nfa = Nfa::new();
        let frag = thompson_construct(&ast, &nfa);

        // Set the NFA start state
        nfa.start = frag.start;

        // Convert NFA to DFA
        let dfa = Dfa::from_nfa(&nfa);
        nfa.free();

        Result::ok(Regex {
            dfa: dfa,
            anchored_start: anchored_start,
            anchored_end: anchored_end,
            num_groups: num_groups,
        })
    }

    /// Check if the entire text matches the pattern
    fn is_match(self: &Regex, text: &[u8]) -> bool {
        if self.anchored_start && self.anchored_end {
            // Must match entire string exactly
            let result = self.dfa.match_from(text, 0);
            result.is_some() && result.unwrap() == text.len()
        } else if self.anchored_start {
            // Must match from start
            let result = self.dfa.match_from(text, 0);
            result.is_some()
        } else if self.anchored_end {
            // Must match at end - try all positions
            for start_pos in 0usize..text.len() + 1 {
                let result = self.dfa.match_from(text, start_pos);
                if result.is_some() && result.unwrap() == text.len() {
                    return true;
                }
            }
            false
        } else {
            // No anchors - match anywhere
            self.dfa.is_match(text)
        }
    }

    /// Find the first match in the text
    /// Returns (start_pos, end_pos) if found
    fn find(self: &Regex, text: &[u8]) -> Option<(usize, usize)> {
        if self.anchored_start {
            // Must start at beginning
            let result = self.dfa.match_from(text, 0);
            if result.is_some() {
                let end = result.unwrap();
                if !self.anchored_end || end == text.len() {
                    return Option::some((0, end));
                }
            }
            Option::none()
        } else if self.anchored_end {
            // Must end at end
            for start_pos in 0usize..text.len() + 1 {
                let result = self.dfa.match_from(text, start_pos);
                if result.is_some() && result.unwrap() == text.len() {
                    return Option::some((start_pos, text.len()));
                }
            }
            Option::none()
        } else {
            self.dfa.find(text)
        }
    }

    /// Check if text matches from the beginning
    fn match_from_start(self: &Regex, text: &[u8]) -> bool {
        let result = self.dfa.match_from(text, 0);
        if result.is_none() {
            return false;
        }
        let end = result.unwrap();
        if self.anchored_end {
            end == text.len()
        } else {
            end > 0
        }
    }

    /// Find first match and return capture groups
    fn captures(self: &Regex, text: &[u8]) -> Option<Captures> {
        // Calculate number of tags needed (2 per group: start and end)
        let num_tags = self.num_groups * 2usize;

        // Try matching at each position (respecting anchors)
        let start_positions: Vector<usize> = Vector::new();
        defer start_positions.free();

        if self.anchored_start {
            start_positions.push(0);
        } else {
            for i in 0usize..text.len() + 1 {
                start_positions.push(i);
            }
        }

        for start_pos in start_positions.iter() {
            let result = self.dfa.match_with_captures(text, start_pos, num_tags);
            if result.is_none() {
                continue;
            }

            let (end_pos, tag_positions) = result.unwrap();

            // Check end anchor constraint
            if self.anchored_end && end_pos != text.len() {
                tag_positions.free();
                continue;
            }

            // Build Captures object
            let captures = Captures::new(text, self.num_groups);

            // Set group 0 (full match)
            captures.positions[0] = Option::some((start_pos, end_pos));

            // Set user groups from tag positions
            for group_id in 1usize..self.num_groups {
                let start_tag = 2usize * group_id;
                let end_tag = 2usize * group_id + 1usize;
                let group_start = tag_positions[start_tag];
                let group_end = tag_positions[end_tag];
                captures.positions[group_id] = Option::some((group_start, group_end));
            }

            tag_positions.free();
            return Option::some(captures);
        }

        Option::none()
    }

    fn move(self: &mut Regex) -> Regex {
        let ret = *self;
        self.dfa = Dfa::new();
        ret
    }

    fn free(self: &mut Regex) {
        self.dfa.free();
    }
}

/// Capture groups from a regex match
/// Contains the matched text and positions of capture groups
struct Captures {
    /// The matched text (borrowed)
    text: &[u8],
    /// Start and end positions for each capture group
    /// Group 0 is the full match, groups 1+ are user groups
    /// positions[i] = (start, end) for group i
    positions: Vector<Option<(usize, usize)>>,
}

impl Captures {
    /// Create a new Captures with the given number of groups
    fn new(text: &[u8], num_groups: usize) -> Captures {
        let positions: Vector<Option<(usize, usize)>> = Vector::new();
        // Initialize with None for all groups
        for _ in 0usize..num_groups {
            positions.push(Option::none());
        }
        Captures {
            text: text,
            positions: positions,
        }
    }

    /// Get the full matched text (capture group 0)
    fn get_match(self: &Captures) -> Option<&[u8]> {
        if self.positions.is_empty() {
            return Option::none();
        }
        let pos = &self.positions[0];
        if pos.is_none() {
            return Option::none();
        }
        let (start, end) = pos.unwrap();
        Option::some(self.text[start..end])
    }

    /// Get a capture group by index (0 = full match, 1+ = user groups)
    fn get(self: &Captures, group: usize) -> Option<&[u8]> {
        if group >= self.positions.len() {
            return Option::none();
        }
        let pos = &self.positions[group];
        if pos.is_none() {
            return Option::none();
        }
        let (start, end) = pos.unwrap();
        Option::some(self.text[start..end])
    }

    /// Get the start and end positions of a capture group
    fn get_pos(self: &Captures, group: usize) -> Option<(usize, usize)> {
        if group >= self.positions.len() {
            return Option::none();
        }
        self.positions[group]
    }

    /// Get the number of capture groups (including group 0 for full match)
    fn len(self: &Captures) -> usize {
        self.positions.len()
    }

    fn move(self: &mut Captures) -> Captures {
        let ret = *self;
        self.positions = Vector::new();
        ret
    }

    fn free(self: &mut Captures) {
        self.positions.free();
    }
}


#[cfg(all(test, test_std))]
#[docs(hide)]
mod tests {
    #[test]
    fn test_interval_single() {
        let set = IntervalSet::single('a' as u32);
        defer set.free();
        assert!(set.contains('a' as u32));
        assert!(!set.contains('b' as u32));
    }

    #[test]
    fn test_interval_range() {
        let set = IntervalSet::range('a' as u32, 'z' as u32);
        defer set.free();
        assert!(set.contains('a' as u32));
        assert!(set.contains('m' as u32));
        assert!(set.contains('z' as u32));
        assert!(!set.contains('A' as u32));
        assert!(!set.contains('0' as u32));
    }

    #[test]
    fn test_interval_add_and_merge() {
        let set = IntervalSet::new();
        defer set.free();
        set.add_interval('a' as u32, 'c' as u32);
        set.add_interval('e' as u32, 'g' as u32);
        set.add_interval('b' as u32, 'f' as u32); // Overlaps both

        assert_eq!(set.intervals.len(), 1);
        assert_eq!(set.intervals[0].start, 'a' as u32);
        assert_eq!(set.intervals[0].end, 'g' as u32);
    }

    #[test]
    fn test_interval_negate() {
        let set = IntervalSet::range('a' as u32, 'z' as u32);
        defer set.free();
        let negated = set.negate();
        defer negated.free();

        assert!(!negated.contains('a' as u32));
        assert!(!negated.contains('m' as u32));
        assert!(!negated.contains('z' as u32));
        assert!(negated.contains('A' as u32));
        assert!(negated.contains('0' as u32));
        assert!(negated.contains(0));
        assert!(negated.contains(0x10FFFF));
    }

    #[test]
    fn test_interval_union() {
        let set1 = IntervalSet::range('a' as u32, 'z' as u32);
        defer set1.free();
        let set2 = IntervalSet::range('A' as u32, 'Z' as u32);
        defer set2.free();
        let union = set1.union(&set2);
        defer union.free();

        assert!(union.contains('a' as u32));
        assert!(union.contains('Z' as u32));
        assert!(!union.contains('0' as u32));
        assert_eq!(union.intervals.len(), 2);
    }

    #[test]
    fn test_nfa_basic() {
        // Build simple NFA: start --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let end_state = nfa.add_state(true);

        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(nfa.start, end_state, chars);

        assert_eq!(nfa.states.len(), 2);
        assert_eq!(nfa.states[0].transitions.len(), 1);
        assert!(nfa.states[1].is_final);
    }

    #[test]
    fn test_nfa_epsilon() {
        // Build NFA with epsilon transition
        let nfa = Nfa::new();
        defer nfa.free();
        let middle = nfa.add_state(false);
        let end_state = nfa.add_state(true);

        nfa.add_epsilon(nfa.start, middle);

        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(middle, end_state, chars);

        assert_eq!(nfa.states.len(), 3);
        assert!(nfa.states[0].transitions[0].on_chars.is_none());
    }

    #[test]
    fn test_nfa_to_dfa() {
        // Build simple NFA: start --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let end_state = nfa.add_state(true);
        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(nfa.start, end_state, chars);

        // Convert to DFA
        let dfa = Dfa::from_nfa(&nfa);
        defer dfa.free();

        // Test matching
        assert!(dfa.is_match("a"));
        assert!(dfa.is_match("xax"));
        assert!(!dfa.is_match("b"));
        assert!(!dfa.is_match(""));
    }

    #[test]
    fn test_nfa_to_dfa_with_epsilon() {
        // Build NFA with epsilon: start -ε-> middle --'a'--> end
        let nfa = Nfa::new();
        defer nfa.free();
        let middle = nfa.add_state(false);
        let end_state = nfa.add_state(true);

        nfa.add_epsilon(nfa.start, middle);
        let chars = IntervalSet::single('a' as u32);
        nfa.add_transition(middle, end_state, chars);

        // Convert to DFA
        let dfa = Dfa::from_nfa(&nfa);
        defer dfa.free();

        // Test matching - epsilon should be transparent
        assert!(dfa.is_match("a"));
        assert!(dfa.is_match("ba"));
        assert!(!dfa.is_match("b"));
    }

    #[test]
    fn test_utf8_decode() {
        // Test ASCII
        let result = unicode::decode_utf8("a");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 'a' as u32);
        assert_eq!(result.unwrap().1, 1usize);

        // Test 2-byte (ñ = U+00F1)
        let result = unicode::decode_utf8("ñ");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0xF1u32);
        assert_eq!(result.unwrap().1, 2usize);

        // Test 3-byte (€ = U+20AC)
        let result = unicode::decode_utf8("€");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0x20ACu32);
        assert_eq!(result.unwrap().1, 3usize);

        // Test 4-byte (𝔸 = U+1D538)
        let result = unicode::decode_utf8("𝔸");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().0, 0x1D538u32);
        assert_eq!(result.unwrap().1, 4usize);
    }

    #[test]
    fn test_dfa_simple_match() {
        // Manually build a DFA that matches "ab"
        let dfa = Dfa::new();
        defer dfa.free();

        // State 0 (start) --'a'--> State 1
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: false,
            entry_tags: Vector::new(),
        });

        // State 1 --'b'--> State 2
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: false,
            entry_tags: Vector::new(),
        });

        // State 2 (final)
        dfa.states.push(DfaState {
            transitions: Vector::new(),
            is_final: true,
            entry_tags: Vector::new(),
        });

        // Add transitions
        dfa.states[0].transitions.push(DfaTransition {
            chars: IntervalSet::single('a' as u32),
            to: 1,
            tags: Vector::new(),
        });

        dfa.states[1].transitions.push(DfaTransition {
            chars: IntervalSet::single('b' as u32),
            to: 2,
            tags: Vector::new(),
        });

        // Test matching
        assert!(dfa.is_match("ab"));
        assert!(dfa.is_match("xabx"));
        assert!(!dfa.is_match("ac"));
        assert!(!dfa.is_match("a"));
    }

    #[test]
    fn test_regex_literal() {
        let re = Regex::compile("abc");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("xabcy"));
        assert!(!re.is_match("ab"));
        assert!(!re.is_match("abx"));
    }

    #[test]
    fn test_regex_alternation() {
        let re = Regex::compile("cat|dog");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("cat"));
        assert!(re.is_match("dog"));
        assert!(re.is_match("the cat"));
        assert!(!re.is_match("bird"));
    }

    #[test]
    fn test_regex_star() {
        let re = Regex::compile("ab*c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ac"));       // zero b's
        assert!(re.is_match("abc"));      // one b
        assert!(re.is_match("abbc"));     // two b's
        assert!(re.is_match("abbbbbc"));  // many b's
        assert!(!re.is_match("ab"));      // no c
    }

    #[test]
    fn test_regex_plus() {
        let re = Regex::compile("ab+c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(!re.is_match("ac"));      // zero b's - should fail
        assert!(re.is_match("abc"));      // one b
        assert!(re.is_match("abbc"));     // two b's
        assert!(re.is_match("abbbbbc"));  // many b's
    }

    #[test]
    fn test_regex_question() {
        let re = Regex::compile("ab?c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ac"));       // zero b's
        assert!(re.is_match("abc"));      // one b
        assert!(!re.is_match("abbc"));    // two b's - should fail
    }

    #[test]
    fn test_regex_dot() {
        let re = Regex::compile("a.c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("a-c"));
        assert!(re.is_match("a c"));
        assert!(!re.is_match("ac"));      // needs something between
    }

    #[test]
    fn test_regex_char_class() {
        let re = Regex::compile("[abc]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("a"));
        assert!(re.is_match("b"));
        assert!(re.is_match("c"));
        assert!(!re.is_match("d"));
    }

    #[test]
    fn test_regex_char_range() {
        let re = Regex::compile("[a-z]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("world"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("test123"));  // contains lowercase
    }

    #[test]
    fn test_regex_negated_class() {
        let re = Regex::compile("[^0-9]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("abc123"));   // starts with non-digits
    }

    #[test]
    fn test_regex_groups() {
        let re = Regex::compile("(ab)+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ab"));
        assert!(re.is_match("abab"));
        assert!(re.is_match("ababab"));
        assert!(re.is_match("abc"));       // contains "ab"
        assert!(!re.is_match("a"));
        assert!(!re.is_match("ba"));       // doesn't contain "ab"
    }

    #[test]
    fn test_regex_complex() {
        let re = Regex::compile("(a|b)*c+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("c"));
        assert!(re.is_match("ac"));
        assert!(re.is_match("bc"));
        assert!(re.is_match("aaabbbccc"));
        assert!(!re.is_match("ab"));      // no c
    }

    #[test]
    fn test_regex_escape() {
        let re = Regex::compile("\\(test\\)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("(test)"));
        assert!(!re.is_match("test"));
    }

    #[test]
    fn test_regex_digit_class() {
        let re = Regex::compile("\\d+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("0"));
        assert!(re.is_match("abc123"));
        assert!(!re.is_match("abc"));
    }

    #[test]
    fn test_regex_non_digit_class() {
        let re = Regex::compile("\\D+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));
        assert!(re.is_match("hello"));
        assert!(!re.is_match("123"));
        assert!(re.is_match("123abc"));  // contains non-digits
    }

    #[test]
    fn test_regex_word_class() {
        let re = Regex::compile("\\w+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("test_123"));
        assert!(re.is_match("ABC"));
        assert!(!re.is_match("!!!"));
        assert!(re.is_match("hello!!!"));  // contains word chars
    }

    #[test]
    fn test_regex_non_word_class() {
        let re = Regex::compile("\\W+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("!!!"));
        assert!(re.is_match("   "));
        assert!(!re.is_match("hello"));
        assert!(re.is_match("hello world"));  // contains space
    }

    #[test]
    fn test_regex_whitespace_class() {
        let re = Regex::compile("\\s+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match(" "));
        assert!(re.is_match("\t"));
        assert!(re.is_match("\n"));
        assert!(re.is_match("   "));
        assert!(!re.is_match("abc"));
        assert!(re.is_match("hello world"));  // contains space
    }

    #[test]
    fn test_regex_non_whitespace_class() {
        let re = Regex::compile("\\S+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("123"));
        assert!(!re.is_match("   "));
        assert!(re.is_match("   hello"));  // contains non-whitespace
    }

    #[test]
    fn test_regex_start_anchor() {
        let re = Regex::compile("^hello");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("hello world"));
        assert!(!re.is_match("say hello"));
        assert!(!re.is_match(" hello"));
    }

    #[test]
    fn test_regex_end_anchor() {
        let re = Regex::compile("world$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("world"));
        assert!(re.is_match("hello world"));
        assert!(!re.is_match("world!"));
        assert!(!re.is_match("world "));
    }

    #[test]
    fn test_regex_both_anchors() {
        let re = Regex::compile("^hello$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(!re.is_match("hello world"));
        assert!(!re.is_match("say hello"));
        assert!(!re.is_match(" hello "));
    }

    #[test]
    fn test_regex_anchor_with_pattern() {
        let re = Regex::compile("^\\d+$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("0"));
        assert!(!re.is_match("123abc"));
        assert!(!re.is_match("abc123"));
        assert!(!re.is_match(" 123 "));
    }

    #[test]
    fn test_regex_simple_capture() {
        let re = Regex::compile("(ab)c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Group 0 = full match
        assert_eq!(caps.get(0).unwrap(), "abc");
        // Group 1 = (ab)
        assert_eq!(caps.get(1).unwrap(), "ab");
    }

    #[test]
    fn test_regex_multiple_captures() {
        let re = Regex::compile("(\\d+)-(\\w+)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("hello 123-abc world");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Group 0 = full match
        assert_eq!(caps.get(0).unwrap(), "123-abc");
        // Group 1 = \d+
        assert_eq!(caps.get(1).unwrap(), "123");
        // Group 2 = \w+
        assert_eq!(caps.get(2).unwrap(), "abc");
    }

    #[test]
    fn test_regex_nested_captures() {
        let re = Regex::compile("(a(b)c)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Group 0 = full match
        assert_eq!(caps.get(0).unwrap(), "abc");
        // Group 1 = (a(b)c)
        assert_eq!(caps.get(1).unwrap(), "abc");
        // Group 2 = (b)
        assert_eq!(caps.get(2).unwrap(), "b");
    }

    #[test]
    fn test_regex_capture_positions() {
        let re = Regex::compile("(\\d+)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("abc123def");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Check positions
        let pos = caps.get_pos(0).unwrap();
        assert_eq!(pos.0, 3usize); // start at position 3
        assert_eq!(pos.1, 6usize); // end at position 6

        let pos1 = caps.get_pos(1).unwrap();
        assert_eq!(pos1.0, 3usize);
        assert_eq!(pos1.1, 6usize);
    }

    #[test]
    fn test_regex_capture_with_star() {
        let re = Regex::compile("(a*)b");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("aaab");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "aaab");
        assert_eq!(caps.get(1).unwrap(), "aaa");
    }

    #[test]
    fn test_regex_capture_num_groups() {
        let re = Regex::compile("(a)(b)(c)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        // Should have 4 groups: group 0 (full) + 3 capture groups
        assert_eq!(caps.len(), 4usize);
        assert_eq!(caps.get(0).unwrap(), "abc");
        assert_eq!(caps.get(1).unwrap(), "a");
        assert_eq!(caps.get(2).unwrap(), "b");
        assert_eq!(caps.get(3).unwrap(), "c");
    }

    #[test]
    fn test_regex_non_capturing_group() {
        let re = Regex::compile("(?:ab)c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        // Should only have group 0 (full match), no capture groups
        assert_eq!(re.num_groups, 1usize);

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.len(), 1usize);
        assert_eq!(caps.get(0).unwrap(), "abc");
    }

    #[test]
    fn test_regex_mixed_groups() {
        let re = Regex::compile("(\\d+)(?:-)?(\\w+)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        // Should have 3 groups: group 0 (full) + 2 capture groups
        // The (?:-)? is non-capturing
        assert_eq!(re.num_groups, 3usize);

        let caps = re.captures("123-abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "123-abc");
        assert_eq!(caps.get(1).unwrap(), "123");
        assert_eq!(caps.get(2).unwrap(), "abc");
    }

    #[test]
    fn test_regex_nested_non_capturing() {
        let re = Regex::compile("(a(?:b)c)");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        // Should have 2 groups: group 0 (full) + 1 capture group
        assert_eq!(re.num_groups, 2usize);

        let caps = re.captures("abc");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "abc");
        assert_eq!(caps.get(1).unwrap(), "abc");
    }

    #[test]
    fn test_regex_unicode_literal() {
        let re = Regex::compile("café");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("café"));
        assert!(!re.is_match("cafe"));
        assert!(re.is_match("I love café!"));
    }

    #[test]
    fn test_regex_unicode_emoji() {
        let re = Regex::compile("hello 🌍");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello 🌍"));
        assert!(!re.is_match("hello world"));
        assert!(re.is_match("say hello 🌍 please"));
    }

    #[test]
    fn test_regex_unicode_char_class() {
        // Match any of: α, β, γ
        let re = Regex::compile("[αβγ]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("α"));
        assert!(re.is_match("β"));
        assert!(re.is_match("γ"));
        assert!(!re.is_match("a"));
        assert!(!re.is_match("δ"));
        assert!(re.is_match("test α here"));
    }

    #[test]
    fn test_regex_unicode_char_range() {
        // Match Greek lowercase letters α-ω (U+03B1 to U+03C9)
        let re = Regex::compile("[α-ω]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("α"));  // U+03B1 (start of range)
        assert!(re.is_match("ω"));  // U+03C9 (end of range)
        assert!(re.is_match("μ"));  // U+03BC (middle of range)
        assert!(re.is_match("π"));  // U+03C0 (pi)
        assert!(!re.is_match("a")); // Latin letter
        assert!(!re.is_match("Α")); // Greek uppercase Alpha (U+0391)
    }

    #[test]
    fn test_regex_unicode_mixed_class() {
        // Mix ASCII and Unicode in character class
        let re = Regex::compile("[a-z🌍😀]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("a"));
        assert!(re.is_match("z"));
        assert!(re.is_match("m"));
        assert!(re.is_match("🌍"));
        assert!(re.is_match("😀"));
        assert!(!re.is_match("A"));
        assert!(!re.is_match("0"));
        assert!(!re.is_match("😎"));
    }

    #[test]
    fn test_regex_unicode_capture() {
        let re = Regex::compile("(\\w+): (\\w+) ([🌍🌎🌏])");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("Hello: world 🌍");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "Hello: world 🌍");
        assert_eq!(caps.get(1).unwrap(), "Hello");
        assert_eq!(caps.get(2).unwrap(), "world");
        assert_eq!(caps.get(3).unwrap(), "🌍");
    }

    #[test]
    fn test_regex_unicode_alternation() {
        let re = Regex::compile("hello|こんにちは|مرحبا");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("hello"));
        assert!(re.is_match("こんにちは"));  // Japanese
        assert!(re.is_match("مرحبا"));      // Arabic
        assert!(!re.is_match("hola"));
    }

    #[test]
    fn test_regex_unicode_cyrillic_range() {
        // Match Cyrillic letters А-Я (U+0410 to U+042F)
        let re = Regex::compile("[А-Я]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("ПРИВЕТ"));  // "HELLO" in Russian
        assert!(re.is_match("МОСКВА"));  // "MOSCOW" in Russian
        assert!(!re.is_match("hello"));
        assert!(!re.is_match("привет")); // lowercase Cyrillic
    }

    #[test]
    fn test_regex_unicode_cjk() {
        // Chinese characters
        let re = Regex::compile("你好.*世界");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("你好世界"));        // Hello world (Chinese)
        assert!(re.is_match("你好，世界"));      // Hello, world
        assert!(re.is_match("你好美丽的世界"));  // Hello beautiful world
        assert!(!re.is_match("你好"));
        assert!(!re.is_match("世界"));
    }

    #[test]
    fn test_regex_unicode_emoji_range() {
        // Emojis U+1F600 to U+1F64F (Emoticons)
        let re = Regex::compile("[😀-🙏]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("😀"));  // U+1F600 (grinning face)
        assert!(re.is_match("😊"));  // U+1F60A (smiling face)
        assert!(re.is_match("🙏"));  // U+1F64F (folded hands)
        assert!(re.is_match("😀😊🙏"));  // Multiple emojis
        assert!(!re.is_match("🌍")); // U+1F30D (outside range)
    }

    #[test]
    fn test_regex_unicode_negated_class() {
        // Match anything except Latin letters
        let re = Regex::compile("[^a-zA-Z]+");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("你好"));
        assert!(re.is_match("🌍"));
        assert!(re.is_match("!@#"));
        assert!(!re.is_match("hello"));
        assert!(!re.is_match("ABC"));
    }

    #[test]
    fn test_regex_unicode_dot_matches_multibyte() {
        // Dot should match any single character including multibyte Unicode
        let re = Regex::compile("a.c");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abc"));     // ASCII
        assert!(re.is_match("aéc"));     // 2-byte UTF-8
        assert!(re.is_match("a你c"));    // 3-byte UTF-8
        assert!(re.is_match("a🌍c"));    // 4-byte UTF-8
        assert!(!re.is_match("ac"));     // No character in middle
        assert!(!re.is_match("abbc"));   // Two characters in middle
    }

    #[test]
    fn test_regex_repeat_exact() {
        // {n} - exactly n times
        let re = Regex::compile("a{3}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("aaa"));
        assert!(re.is_match("xaaax"));
        assert!(!re.is_match("aa"));
        assert!(re.is_match("aaaa"));  // Matches first 3 a's
        assert!(!re.is_match("a"));
    }

    #[test]
    fn test_regex_repeat_at_least() {
        // {n,} - at least n times
        let re = Regex::compile("a{2,}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(!re.is_match("a"));
        assert!(re.is_match("aa"));
        assert!(re.is_match("aaa"));
        assert!(re.is_match("aaaa"));
        assert!(re.is_match("xaaaax"));
    }

    #[test]
    fn test_regex_repeat_range() {
        // {n,m} - between n and m times
        let re = Regex::compile("a{2,4}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(!re.is_match("a"));
        assert!(re.is_match("aa"));
        assert!(re.is_match("aaa"));
        assert!(re.is_match("aaaa"));
        assert!(re.is_match("aaaaa"));  // Matches first 4
        assert!(re.is_match("xaaax"));
    }

    #[test]
    fn test_regex_repeat_zero() {
        // {0} - matches empty (degenerate case)
        let re = Regex::compile("a{0}b");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("b"));
        assert!(re.is_match("ab"));  // "ab" contains "b"
        assert!(!re.is_match("a"));
    }

    #[test]
    fn test_regex_repeat_complex() {
        // Repetition on groups
        let re = Regex::compile("(ab){2}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("abab"));
        assert!(re.is_match("xababx"));
        assert!(!re.is_match("ab"));
        assert!(re.is_match("ababab"));  // Matches first 2 occurrences
    }

    #[test]
    fn test_regex_repeat_with_char_class() {
        // Repetition on character classes
        let re = Regex::compile("[0-9]{3}");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        assert!(re.is_match("123"));
        assert!(re.is_match("999"));
        assert!(re.is_match("x456x"));
        assert!(!re.is_match("12"));
        assert!(re.is_match("1234"));  // Matches first 3 digits
    }

    #[test]
    fn test_regex_repeat_captures() {
        // Test repetition with captures
        let re = Regex::compile("(\\d{2,3})-([a-z]{2})");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();

        let caps = re.captures("12-ab");
        assert!(caps.is_some());
        let caps = caps.unwrap();
        defer caps.free();

        assert_eq!(caps.get(0).unwrap(), "12-ab");
        assert_eq!(caps.get(1).unwrap(), "12");
        assert_eq!(caps.get(2).unwrap(), "ab");

        let caps2 = re.captures("123-xy");
        assert!(caps2.is_some());
        let caps2 = caps2.unwrap();
        defer caps2.free();

        assert_eq!(caps2.get(0).unwrap(), "123-xy");
        assert_eq!(caps2.get(1).unwrap(), "123");
        assert_eq!(caps2.get(2).unwrap(), "xy");
    }

    #[test]
    fn test_escape_basic() {
        // Test \t, \n, \r
        let re = Regex::compile("a\\tb");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("a\tb"));
        assert!(!re.is_match("ab"));

        let re2 = Regex::compile("line1\\nline2");
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();
        assert!(re2.is_match("line1\nline2"));
        assert!(!re2.is_match("line1line2"));

        let re3 = Regex::compile("car\\rreturn");
        assert!(re3.is_ok());
        let re3 = re3.unwrap();
        defer re3.free();
        assert!(re3.is_match("car\rreturn"));
        assert!(!re3.is_match("carreturn"));
    }

    #[test]
    fn test_escape_backslash() {
        // Test escaping backslash itself
        let re = Regex::compile("a\\\\b");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("a\\b"));
        assert!(!re.is_match("ab"));
    }

    #[test]
    fn test_escape_metacharacters() {
        // Test escaping regex metacharacters
        let re = Regex::compile("\\(\\)\\[\\]\\{\\}\\*\\+\\?\\.\\|\\^\\$");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("()[]{}*+?.|^$"));
        assert!(!re.is_match("abc"));
    }

    #[test]
    fn test_escape_hex() {
        // Test \xHH escape sequences
        let re = Regex::compile("\\x41\\x42\\x43");  // ABC
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("ABC"));
        assert!(!re.is_match("abc"));

        // Test lowercase hex digits
        let re2 = Regex::compile("\\x61\\x62\\x63");  // abc
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();
        assert!(re2.is_match("abc"));
        assert!(!re2.is_match("ABC"));

        // Test mixed case hex
        let re3 = Regex::compile("\\x4a\\x4B");  // JK
        assert!(re3.is_ok());
        let re3 = re3.unwrap();
        defer re3.free();
        assert!(re3.is_match("JK"));
    }

    #[test]
    fn test_escape_unicode() {
        // Test \uHHHH escape sequences
        let re = Regex::compile("\\u0041\\u0042\\u0043");  // ABC
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("ABC"));

        // Test Unicode characters beyond ASCII
        let re2 = Regex::compile("\\u00E9\\u00E0");  // éà
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();
        assert!(re2.is_match("éà"));

        // Test emoji with Unicode escape (U+1F44D = 👍)
        // Note: \u only supports 4 hex digits, for higher codepoints use literal or \x sequences
        let re3 = Regex::compile("\\u03B1\\u03B2");  // αβ (Greek)
        assert!(re3.is_ok());
        let re3 = re3.unwrap();
        defer re3.free();
        assert!(re3.is_match("αβ"));
    }

    #[test]
    fn test_escape_in_char_class() {
        // Test escape sequences inside character classes
        let re = Regex::compile("[\\t\\n\\r]");
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("\t"));
        assert!(re.is_match("\n"));
        assert!(re.is_match("\r"));
        assert!(!re.is_match("a"));

        // Test hex escapes in character class
        let re2 = Regex::compile("[\\x41-\\x43]");  // [A-C]
        assert!(re2.is_ok());
        let re2 = re2.unwrap();
        defer re2.free();
        assert!(re2.is_match("A"));
        assert!(re2.is_match("B"));
        assert!(re2.is_match("C"));
        assert!(!re2.is_match("D"));
    }

    #[test]
    fn test_escape_mixed() {
        // Test mixing different escape types
        let re = Regex::compile("\\x48\\u0065llo\\t\\d+");  // Hello\t followed by digits
        assert!(re.is_ok());
        let re = re.unwrap();
        defer re.free();
        assert!(re.is_match("Hello\t123"));
        assert!(!re.is_match("Hello 123"));
    }
}

