//! Heap-allocating collections.

use std::cmp::Comparable;
use std::marker::Callable;
use std::mem::Freeable;

use vector::Vector;
use hashmap::HashMap;
use hashset::HashSet;

/// Helper for collections that own heap-allocated objects. This is used to
/// be able to do `defer col.free_all()` without much boilerplate.
fn free_all<T: Freeable<T>(col: &mut T) {
    for i in col {
        i.free();
    }
    col.free();
}

/// Sorts a slice using a key extraction function.
fn sort_by<T, F: Callable<(&T), K>, K: Comparable<K>>(arr: &mut [T], key: F) {
    if arr.len <= 1 {
        return;
    }
    
    let p = partition_by(arr, key);
    sort_by(arr[..p], key);
    sort_by(arr[p+1..], key);
}

/// Sorts the slice.
fn sort<T: Comparable<T>>(arr: &mut [T]) {
    sort_by(arr, |k: &T| -> T { *k });
}

fn partition_by<T, F: Callable<(&T), K>, K: Comparable<K>>(arr: &mut [T], key: F) -> usize {
    use std::mem::swap;

    let pivot = arr[arr.len - 1];
    let i = 0usize;
    let j = 0usize;
    while j < arr.len - 1 {
        if key(&arr[j]) <= key(&pivot) {
            swap(&arr[i], &arr[j]);
            i += 1;
        }
        j += 1;
    }
    swap(&arr[i], &arr[arr.len - 1]);
    i
}


#[cfg(all(test, test_std))]
mod tests {
    #[test]
    fn test_sort() {
        let slice = [4, 8, 2, 9, 7, 10, 3, 1, 6, 5].as_slice_mut();
        sort(slice);

        assert_eq!(slice, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }

    #[test]
    fn test_sort_by() {
        let slice = [4, 8, 2, 9, 7, 10, 3, 1, 6, 5].as_slice_mut();
        sort_by(slice, |x: &i32| -> i32 { -*x });

        assert_eq!(slice, &[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
    }
}


