//! Builtin types and their method implementations.
//!
//! This module holds impl blocks for builtin types all items with `#[lang(builtin_X)]` are
//! treated as X when lowering into IR, so they cannot actually exist as proper structs.
//!
//! Builtin protocols also cannot be directly implemented by user code, even though
//! they contain no associated functions. They are handled specially
//! by the compiler.

use cmp::{Equatable, Comparable, Ordering, lex_compare};
use hash::{Hashable, Hasher};
use fmt::{Formatter};

/// Unit type (`()`)
///
/// Unit type (also called void type) is the return type of expressions that do not return
/// a value. It is equivalent to a [tuple] with zero elements.
#[docs(builtin)]
type void = ();

/// Boolean type
#[lang(builtin_bool)]
#[docs(builtin)]
struct bool {}
impl bool {
    /// Returns `true`.
    #[inline(ir)]
    fn max_value() -> bool {
        true
    }

    /// Returns `false`.
    #[inline(ir)]
    fn min_value() -> bool {
        false
    }

    /// Convert boolean into an [Option] with a given value.
    ///
    /// Returns `Option::some(value)` if the boolean is `true`, `Option::none()` otherwise.
    ///
    /// ## Example
    /// ```
    /// let o1 = true.then_some("hello");
    /// let o2 = false.then_some("world");
    ///
    /// assert_eq!(o1, Option::some("hello"));
    /// assert_eq!(o2, Option::none());
    /// ```
    fn then_some<T>(self: bool, value: T) -> Option<T> {
        if self {
            Option::some(value)
        } else {
            Option::none()
        }
    }

    /// Convert boolean into an [Option] with a value provided by a closure.
    ///
    /// Returns `Option::some(func())` if the boolean is `true`, `Option::none()` otherwise.
    ///
    /// ## Example
    /// ```
    /// let o1 = true.then(|| -> &[u8] { "hello" });
    /// let o2 = false.then(|| -> &[u8] { "hello" });
    ///
    /// assert_eq!(o1, Option::some("hello"));
    /// assert_eq!(o2, Option::none());
    /// ```
    fn then<T, F: Fn() -> T>(self: bool, func: F) -> Option<T> {
        if self {
            Option::some(func())
        } else {
            Option::none()
        }
    }

    /// @ cmp::Equatable::equals
    #[inline(always)]
    fn equals(lhs: &bool, rhs: &bool) -> bool {
        *lhs == *rhs
    }

    /// @ cmp::Comparable::compare
    #[inline(always)]
    fn compare(lhs: &bool, rhs: &bool) -> Ordering {
        if *lhs == *rhs {
            Ordering::Equal
        } else if *rhs {
            Ordering::Less
        } else {
            Ordering::Greater
        }
    }

    /// @ hash::Hashable::hash
    fn hash<H: Hasher<H>>(self: &bool, hasher: &mut H) {
        hasher.write(mem::slice::from_raw(self as &u8, 1));
    }

    /// @ fmt::Formattable::fmt
    fn fmt<F: Formatter<F>>(self: &bool, formatter: &mut F) -> Result<(), fmt::Error> {
        formatter.write_str(if *self { "true" } else { "false" })
    }

    mixin Equatable<bool>;
    mixin Comparable<u8>;
}

/// Never type (`!`)
///
/// Never type is the type of expressions that never return. For example,
/// ```no_run
/// let _a = loop {};  // `_a` is of type `!`
/// ```
///
/// It has a couple of interesting properties, notably it is a bottom type,
/// which means that values of never type can be coerced into any other type.
#[lang(builtin_never)]
#[docs(builtin)]
struct never {}

/// 8-bit unsigned integer (byte)
///
/// This is also the "character" type, e.g. expression `"hello"[0]` has type `u8`.
#[lang(builtin_u8)]
#[docs(builtin)]
struct u8 {}
impl u8 {
    mixin internal::BitOps<u8>;
    mixin internal::WithOverflow<u8>;
    mixin internal::BuiltinComparable<u8>;
    mixin<H: Hasher<H>> internal::IntegerHashable<u8, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<u8, F>;
    mixin internal::IntegerParsable<u8>;

    /// Returns the maximum value of `u8`.
    #[inline(ir)]
    fn max_value() -> u8 {
        0xffu8
    }

    /// Returns the minimum value of `u8`.
    #[inline(ir)]
    fn min_value() -> u8 {
        0u8
    }
}

/// 16-bit unsigned integer
#[lang(builtin_u16)]
#[docs(builtin)]
struct u16 {}
impl u16 {
    mixin internal::BitOps<u16>;
    mixin internal::WithOverflow<u16>;
    mixin internal::BuiltinComparable<u16>;
    mixin<H: Hasher<H>> internal::IntegerHashable<u16, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<u16, F>;
    mixin internal::IntegerParsable<u16>;

    /// Returns the maximum value of `u16`.
    #[inline(ir)]
    fn max_value() -> u16 {
        0xffffu16
    }

    /// Returns the minimum value of `u16`.
    #[inline(ir)]
    fn min_value() -> u16 {
        0u16
    }
}

/// 32-bit unsigned integer
#[lang(builtin_u32)]
#[docs(builtin)]
struct u32 {}
impl u32 {
    mixin internal::BitOps<u32>;
    mixin internal::WithOverflow<u32>;
    mixin internal::BuiltinComparable<u32>;
    mixin<H: Hasher<H>> internal::IntegerHashable<u32, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<u32, F>;
    mixin internal::IntegerParsable<u32>;

    /// Returns the maximum value of `u32`.
    #[inline(ir)]
    fn max_value() -> u32 {
        0xffffffffu32
    }

    /// Returns the minimum value of `u32`.
    #[inline(ir)]
    fn min_value() -> u32 {
        0u32
    }
}

/// 64-bit unsigned integer
#[lang(builtin_u64)]
#[docs(builtin)]
struct u64 {}
impl u64 {
    mixin internal::BitOps<u64>;
    mixin internal::WithOverflow<u64>;
    mixin internal::BuiltinComparable<u64>;
    mixin<H: Hasher<H>> internal::IntegerHashable<u64, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<u64, F>;
    mixin internal::IntegerParsable<u64>;

    /// Returns the maximum value of `u64`.
    #[inline(ir)]
    fn max_value() -> u64 {
        0xffffffffffffffffu64
    }

    /// Returns the minimum value of `u64`.
    #[inline(ir)]
    fn min_value() -> u64 {
        0u64
    }
}

/// 128-bit unsigned integer
#[lang(builtin_u128)]
#[docs(builtin)]
struct u128 {}
impl u128 {
    mixin internal::BitOps<u128>;
    mixin internal::WithOverflow<u128>;
    mixin internal::BuiltinComparable<u128>;
    mixin<H: Hasher<H>> internal::IntegerHashable<u128, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<u128, F>;
    mixin internal::IntegerParsable<u128>;

    /// Returns the maximum value of `u128`.
    #[inline(ir)]
    fn max_value() -> u128 {
        0xffffffffffffffffffffffffffffffffu128
    }

    /// Returns the minimum value of `u128`.
    #[inline(ir)]
    fn min_value() -> u128 {
        0u128
    }
}

/// Native unsigned integer (machine word)
///
/// On 64-bit systems, `usize` is equivalent to [u64]. On 32-bit systems, `usize` is equivalent
/// to [u32].
///
/// To help writing portable code, `usize` is a distinct type and not just a type alias.
/// Conversions from `usize` to the equivalently sized unsigned integer require an explicit cast.
#[lang(builtin_usize)]
#[docs(builtin)]
struct usize {}
impl usize {
    mixin internal::BitOps<usize>;
    mixin internal::WithOverflow<usize>;
    mixin internal::BuiltinComparable<usize>;
    mixin<H: Hasher<H>> internal::IntegerHashable<usize, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<usize, F>;
    mixin internal::IntegerParsable<usize>;

    /// Returns the maximum value of `usize`.
    #[inline(ir)]
    fn max_value() -> usize {
        #[cfg(target_pointer_width = "32")]
        {
            u32::max_value() as usize
        }
        #[cfg(target_pointer_width = "64")]
        {
            u64::max_value() as usize
        }
    }

    /// Returns the minimum value of `usize`.
    #[inline(ir)]
    fn min_value() -> usize {
        #[cfg(target_pointer_width = "32")]
        {
            u32::min_value() as usize
        }
        #[cfg(target_pointer_width = "64")]
        {
            u64::min_value() as usize
        }
    }
}

/// Signed 8-bit integer
#[lang(builtin_i8)]
#[docs(builtin)]
struct i8 {}
impl i8 {
    mixin internal::WithOverflow<i8>;
    mixin internal::BuiltinComparable<i8>;
    mixin<H: Hasher<H>> internal::IntegerHashable<i8, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<i8, F>;
    mixin internal::IntegerParsable<i8>;

    /// Returns the maximum value of `i8`.
    #[inline(ir)]
    fn max_value() -> i8 {
        0x7fu8 as i8
    }

    /// Returns the minimum value of `i8`.
    #[inline(ir)]
    fn min_value() -> i8 {
        0x80u8 as i8
    }
}

/// Signed 16-bit integer
#[lang(builtin_i16)]
#[docs(builtin)]
struct i16 {}
impl i16 {
    mixin internal::WithOverflow<i16>;
    mixin internal::BuiltinComparable<i16>;
    mixin<H: Hasher<H>> internal::IntegerHashable<i16, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<i16, F>;
    mixin internal::IntegerParsable<i16>;

    /// Returns the maximum value of `i16`.
    #[inline(ir)]
    fn max_value() -> i16 {
        0x7fffu16 as i16
    }

    /// Returns the minimum value of `i16`.
    #[inline(ir)]
    fn min_value() -> i16 {
        0x8000u16 as i16
    }
}

/// Signed 32-bit integer
#[lang(builtin_i32)]
#[docs(builtin)]
struct i32 {}
impl i32 {
    mixin internal::WithOverflow<i32>;
    mixin internal::BuiltinComparable<i32>;
    mixin<H: Hasher<H>> internal::IntegerHashable<i32, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<i32, F>;
    mixin internal::IntegerParsable<i32>;

    /// Returns the maximum value of `i32`.
    #[inline(ir)]
    fn max_value() -> i32 {
        0x7fffffffu32 as i32
    }

    /// Returns the minimum value of `i32`.
    #[inline(ir)]
    fn min_value() -> i32 {
        0x80000000u32 as i32
    }
}

/// Signed 64-bit integer
#[lang(builtin_i64)]
#[docs(builtin)]
struct i64 {}
impl i64 {
    mixin internal::WithOverflow<i64>;
    mixin internal::BuiltinComparable<i64>;
    mixin<H: Hasher<H>> internal::IntegerHashable<i64, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<i64, F>;
    mixin internal::IntegerParsable<i64>;

    /// Returns the maximum value of `i64`.
    #[inline(ir)]
    fn max_value() -> i64 {
        0x7fffffffffffffffu64 as i64
    }

    /// Returns the minimum value of `i64`.
    #[inline(ir)]
    fn min_value() -> i64 {
        0x8000000000000000u64 as i64
    }
}

/// Signed 128-bit integer
#[lang(builtin_i128)]
#[docs(builtin)]
struct i128 {}
impl i128 {
    mixin internal::WithOverflow<i128>;
    mixin internal::BuiltinComparable<i128>;
    mixin<H: Hasher<H>> internal::IntegerHashable<i128, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<i128, F>;
    mixin internal::IntegerParsable<i128>;

    /// Returns the maximum value of `i128`.
    #[inline(ir)]
    fn max_value() -> i128 {
        0x7fffffffffffffffffffffffffffffffu128 as i128
    }

    /// Returns the minimum value of `i128`.
    #[inline(ir)]
    fn min_value() -> i128 {
        0x80000000000000000000000000000000u128 as i128
    }
}

/// Native signed integer (machine word)
#[lang(builtin_isize)]
#[docs(builtin)]
struct isize {}
impl isize {
    mixin internal::WithOverflow<isize>;
    mixin internal::BuiltinComparable<isize>;
    mixin<H: Hasher<H>> internal::IntegerHashable<isize, H>;
    mixin<F: Formatter<F>> internal::IntegerFormattable<isize, F>;
    mixin internal::IntegerParsable<isize>;

    /// Returns the maximum value of `isize`.
    #[inline(ir)]
    fn max_value() -> isize {
        #[cfg(target_pointer_width = "32")]
        {
            i32::max_value() as isize
        }
        #[cfg(target_pointer_width = "64")]
        {
            i64::max_value() as isize
        }
    }

    /// Returns the minimum value of `isize`.
    #[inline(ir)]
    fn min_value() -> isize {
        #[cfg(target_pointer_width = "32")]
        {
            i32::min_value() as isize
        }
        #[cfg(target_pointer_width = "64")]
        {
            i64::min_value() as isize
        }
    }
}

/// Single precision floating point type
#[lang(builtin_f32)]
#[docs(builtin)]
struct f32 {}
impl f32 {
    mixin internal::BuiltinComparable<f32>;
    // Not hashable
    mixin<F: Formatter<F>> internal::FloatFormattable<f32, F>;
    mixin internal::FloatOps<f32>;

    /// Parses a floating point number from a string.
    ///
    /// Returns `Option::none()` if the string does not represent a valid floating point
    /// number.
    ///
    /// ## Example
    /// ```
    /// assert_eq!(f32::parse("3.1415"), Option::some(3.1415f32));
    /// assert_eq!(f32::parse("inf"), Option::some(f32::infinity()));
    /// ```
    #[inline]
    fn parse(s: &[u8]) -> Option<f32> {
        string::parse_float::<f32>(s)
    }

    /// Returns `true` if the number has a negative sign, `false` otherwise.
    #[inline(always)]
    fn is_sign_negative(self: f32) -> bool {
        let as_bits: u32 = util::transmute(self);
        as_bits & 0x80000000u32 != 0
    }

    /// Returns the maximum value of `f32`.
    #[inline(ir)]
    fn max_value() -> f32 {
        3.40282347e+38f32
    }

    /// Returns the minimum value of `f32`.
    #[inline(ir)]
    fn min_value() -> f32 {
        -3.40282347e+38f32
    }

    /// Returns the smallest positive value of `f32`.
    #[inline(ir)]
    fn min_positive() -> f32 {
        1.17549435e-38f32
    }

    /// Returns the machine epsilon for `f32`.
    #[inline(ir)]
    fn epsilon() -> f32 {
        1.19209290e-07f32
    }

    /// Create `f64` from raw bits
    ///
    /// ## Example
    /// ```
    /// let f = f32::from_bits(0x40490fdb);
    /// assert_eq!(f, std::math::PI as f32);
    /// ```
    #[inline(always)]
    fn from_bits(bits: u32) -> f32 {
        util::transmute(bits)
    }

    /// Returns the raw bits of `self`
    ///
    /// ## Example
    /// ```
    /// let x = 1.0f32;
    /// assert_eq!(x.to_bits(), 0x3f800000u32);
    /// ```
    #[inline(always)]
    fn to_bits(self: f32) -> u32 {
        util::transmute(self)
    }

    /// Returns the smallest floating point number strictly greater than `self`.
    ///
    /// If `self` is NaN or positive infinity, it returns `self` unchanged.
    ///
    /// ## Example
    /// ```
    /// assert_eq!(0.0f32.next_up(), 1.0e-45f32);
    /// assert_eq!(1.0f32.next_up(), 1.0000001f32);
    /// assert_eq!((-1.0f32).next_up(), -0.99999994f32);
    /// assert_eq!(f32::neg_infinity().next_up(), -3.4028235e38f32);
    /// assert_eq!(f32::infinity().next_up(), f32::infinity());
    /// assert!(f32::nan().next_up().is_nan());
    /// ```
    fn next_up(self: f32) -> f32 {
        const TINY_BITS: u32 = 0x1; // Smallest positive f32.
        const CLEAR_SIGN_MASK: u32 = 0x7fffffff;

        let bits = self.to_bits();
        if self.is_nan() || bits == f32::infinity().to_bits() {
            return self;
        }

        let abs = bits & CLEAR_SIGN_MASK;
        let next_bits = if abs == 0 {
            TINY_BITS
        } else if bits == abs {
            bits + 1
        } else {
            bits - 1
        };
        f32::from_bits(next_bits)
    }

    /// Returns the largest floating point number strictly less than `self`.
    ///
    /// If `self` is NaN or negative infinity, it returns `self` unchanged.
    ///
    /// ## Example
    /// ```
    /// assert_eq!(0.0f32.next_down(), -1.0e-45f32);
    /// assert_eq!(1.0f32.next_down(), 0.99999994f32);
    /// assert_eq!((-1.0f32).next_down(), -1.0000001f32);
    /// assert_eq!(f32::infinity().next_down(), 3.4028235e38f32);
    /// assert_eq!(f32::neg_infinity().next_down(), f32::neg_infinity());
    /// assert!(f32::nan().next_down().is_nan());
    /// ```
    fn next_down(self: f32) -> f32 {
        const NEG_TINY_BITS: u32 = 0x80000001; // Smallest (in magnitude) negative f32.
        const CLEAR_SIGN_MASK: u32 = 0x7fffffff;

        let bits = self.to_bits();
        if self.is_nan() || bits == f32::neg_infinity().to_bits() {
            return self;
        }

        let abs = bits & CLEAR_SIGN_MASK;
        let next_bits = if abs == 0 {
            NEG_TINY_BITS
        } else if bits == abs {
            bits - 1
        } else {
            bits + 1
        };
        f32::from_bits(next_bits)
    }

    /// Inverse cosine
    #[inline(always)]
    fn acos(self: f32) -> f32 {
        libc::acosf(self)
    }

    /// Inverse sine
    #[inline(always)]
    fn asin(self: f32) -> f32 {
        libc::asinf(self)
    }

    /// Inverse tangent
    #[inline(always)]
    fn atan(self: f32) -> f32 {
        libc::atanf(self)
    }

    /// Four-quadrant inverse tangent
    #[inline(always)]
    fn atan2(self: f32, other: f32) -> f32 {
        libc::atan2f(self, other)
    }

    /// Inverse hyperbolic cosine
    #[inline(always)]
    fn atanh(self: f32) -> f32 {
        libc::atanhf(self)
    }

    /// Cube root
    #[inline(always)]
    fn cbrt(self: f32) -> f32 {
        libc::cbrtf(self)
    }

    /// Ceiling of number
    #[inline(always)]
    fn ceil(self: f32) -> f32 {
        libc::ceilf(self)
    }

    /// Cosine
    #[inline(always)]
    fn cos(self: f32) -> f32 {
        libc::cosf(self)
    }

    /// Hyperbolic cosine
    #[inline(always)]
    fn cosh(self: f32) -> f32 {
        libc::coshf(self)
    }

    /// Gauss error function
    #[inline(always)]
    fn erf(self: f32) -> f32 {
        libc::erff(self)
    }

    /// Complementary error function (1 - [erf(self)](erf))
    #[inline(always)]
    fn erfc(self: f32) -> f32 {
        libc::erfcf(self)
    }

    /// Exponential function (e^`self`)
    #[inline(always)]
    fn exp(self: f32) -> f32 {
        libc::expf(self)
    }

    /// Floor of number
    #[inline(always)]
    fn floor(self: f32) -> f32 {
        libc::floorf(self)
    }

    /// Decomposes `self` into a normalized fractional part and an integral power of two.
    ///
    /// Inverse of [ldexp].
    #[inline(always)]
    fn frexp(self: f32) -> (f32, i32) {
        let out: i32;
        let val = libc::frexpf(self, &out);
        (val, out)
    }

    /// Multiplies `self` by 2 raised to the power of `exp`.
    ///
    /// Inverse of [frexp].
    #[inline(always)]
    fn ldexp(self: f32, exp: i32) -> f32 {
        libc::ldexpf(self, exp)
    }

    /// Natural logarithm
    #[inline(always)]
    fn log(self: f32) -> f32 {
        libc::logf(self)
    }

    /// Base 2 logarithm
    #[inline(always)]
    fn log2(self: f32) -> f32 {
        libc::log2f(self)
    }

    /// Base 10 logarithm
    #[inline(always)]
    fn log10(self: f32) -> f32 {
        libc::log10f(self)
    }

    /// Decompose `self` into a whole and fractional part
    #[inline(always)]
    fn modf(self: f32) -> (f32, f32) {
        let out: f32;
        let val = libc::modff(self, &out);
        (out, val)
    }

    /// Power function
    #[inline(always)]
    fn pow(self: f32, other: f32) -> f32 {
        libc::powf(self, other)
    }

    /// Rounds `self` to the closest integer.
    ///
    /// If the number is halfway between two integers, it is rounded away from zero.
    #[inline(always)]
    fn round(self: f32) -> f32 {
        libc::roundf(self)
    }

    /// Sine function
    #[inline(always)]
    fn sin(self: f32) -> f32 {
        libc::sinf(self)
    }

    /// Hyperbolic sine function
    #[inline(always)]
    fn sinh(self: f32) -> f32 {
        libc::sinhf(self)
    }

    /// Square root
    #[inline(always)]
    fn sqrt(self: f32) -> f32 {
        libc::sqrtf(self)
    }

    /// Tangent function
    #[inline(always)]
    fn tan(self: f32) -> f32 {
        libc::tanf(self)
    }

    /// Hyperbolic tangent function
    #[inline(always)]
    fn tanh(self: f32) -> f32 {
        libc::tanhf(self)
    }

    /// Returns the integer part of `self` (round towards zero).
    #[inline(always)]
    fn trunc(self: f32) -> f32 {
        libc::truncf(self)
    }
}

/// Double precision floating point type
#[lang(builtin_f64)]
#[docs(builtin)]
struct f64 {}
impl f64 {
    mixin internal::BuiltinComparable<f64>;
    // Not hashable
    mixin<F: Formatter<F>> internal::FloatFormattable<f64, F>;
    mixin internal::FloatOps<f64>;

    /// Parses a floating point number from a string.
    ///
    /// Returns `Option::none()` if the string does not represent a valid floating point
    /// number.
    ///
    /// ## Example
    /// ```
    /// assert_eq!(f64::parse("3.1415"), Option::some(3.1415));
    /// assert_eq!(f64::parse("inf"), Option::some(f64::infinity()));
    /// ```
    #[inline]
    fn parse(s: &[u8]) -> Option<f64> {
        string::parse_float::<f64>(s)
    }

    /// @ f32::is_sign_negative
    #[inline(always)]
    fn is_sign_negative(self: f64) -> bool {
        let as_bits: u64 = util::transmute(self);
        as_bits & 0x8000000000000000u64 != 0
    }

    /// Returns the maximum value of `f64`
    #[inline(ir)]
    fn max_value() -> f64 {
        1.7976931348623157e+308f64
    }

    /// Returns the minimum value of `f64`
    #[inline(ir)]
    fn min_value() -> f64 {
        -1.7976931348623157e+308f64
    }

    /// Returns the smallest positive value of `f64`.
    #[inline(ir)]
    fn min_positive() -> f64 {
        2.2250738585072014e-308f64
    }

    /// Returns the machine epsilon for `f64`.
    #[inline(ir)]
    fn epsilon() -> f64 {
        2.2204460492503131e-16f64
    }

    /// Create `f64` from raw bits
    ///
    /// ## Example
    /// ```
    /// let f = f64::from_bits(0x400921fb54442d18);
    /// assert_eq!(f, std::math::PI);
    /// ```
    #[inline(always)]
    fn from_bits(bits: u64) -> f64 {
        util::transmute(bits)
    }

    /// Returns the raw bits of `self`
    ///
    /// ## Example
    /// ```
    /// let x = 1.0f64;
    /// assert_eq!(x.to_bits(), 0x3ff0000000000000u64);
    /// ```
    #[inline(always)]
    fn to_bits(self: f64) -> u64 {
        util::transmute(self)
    }

    /// Returns the smallest floating point number strictly greater than `self`.
    ///
    /// If `self` is NaN or positive infinity, it returns `self` unchanged.
    ///
    /// ## Example
    /// ```
    /// assert_eq!(0.0.next_up(), 5.0e-324);
    /// assert_eq!(1.0.next_up(), 1.0000000000000002);
    /// assert_eq!((-1.0).next_up(), -0.9999999999999999);
    /// assert_eq!(f64::neg_infinity().next_up(), -1.7976931348623157e308);
    /// assert_eq!(f64::infinity().next_up(), f64::infinity());
    /// assert!(f64::nan().next_up().is_nan());
    /// ```
    fn next_up(self: f64) -> f64 {
        const TINY_BITS: u64 = 0x1; // Smallest positive f64.
        const CLEAR_SIGN_MASK: u64 = 0x7fffffffffffffff;

        let bits = self.to_bits();
        if self.is_nan() || bits == f64::infinity().to_bits() {
            return self;
        }

        let abs = bits & CLEAR_SIGN_MASK;
        let next_bits = if abs == 0 {
            TINY_BITS
        } else if bits == abs {
            bits + 1
        } else {
            bits - 1
        };
        f64::from_bits(next_bits)
    }

    /// Returns the largest floating point number strictly less than `self`.
    ///
    /// If `self` is NaN or negative infinity, it returns `self` unchanged.
    ///
    /// ## Example
    /// ```
    /// assert_eq!(0.0.next_down(), -5.0e-324);
    /// assert_eq!(1.0.next_down(), 0.9999999999999999);
    /// assert_eq!((-1.0).next_down(), -1.0000000000000002);
    /// assert_eq!(f64::neg_infinity().next_down(), f64::neg_infinity());
    /// assert_eq!(f64::infinity().next_down(), 1.7976931348623157e308);
    /// assert!(f64::nan().next_down().is_nan());
    /// ```
    fn next_down(self: f64) -> f64 {
        const NEG_TINY_BITS: u64 = 0x8000000000000001; // Smallest (in magnitude) negative f64.
        const CLEAR_SIGN_MASK: u64 = 0x7fffffffffffffff;

        let bits = self.to_bits();
        if self.is_nan() || bits == f64::neg_infinity().to_bits() {
            return self;
        }

        let abs = bits & CLEAR_SIGN_MASK;
        let next_bits = if abs == 0 {
            NEG_TINY_BITS
        } else if bits == abs {
            bits - 1
        } else {
            bits + 1
        };
        f64::from_bits(next_bits)
    }

    /// @ f32::acos
    #[inline(always)]
    fn acos(self: f64) -> f64 {
        libc::acos(self)
    }

    /// @ f32::asin
    #[inline(always)]
    fn asin(self: f64) -> f64 {
        libc::asin(self)
    }

    /// @ f32::atan
    #[inline(always)]
    fn atan(self: f64) -> f64 {
        libc::atan(self)
    }

    /// @ f32::atan2
    #[inline(always)]
    fn atan2(self: f64, other: f64) -> f64 {
        libc::atan2(self, other)
    }

    /// @ f32::atanh
    #[inline(always)]
    fn atanh(self: f64) -> f64 {
        libc::atanh(self)
    }

    /// @ f32::cbrt
    #[inline(always)]
    fn cbrt(self: f64) -> f64 {
        libc::cbrt(self)
    }

    /// @ f32::ceil
    #[inline(always)]
    fn ceil(self: f64) -> f64 {
        libc::ceil(self)
    }

    /// @ f32::cos
    #[inline(always)]
    fn cos(self: f64) -> f64 {
        libc::cos(self)
    }

    /// @ f32::cosh
    #[inline(always)]
    fn cosh(self: f64) -> f64 {
        libc::cosh(self)
    }

    /// @ f32::erf
    #[inline(always)]
    fn erf(self: f64) -> f64 {
        libc::erf(self)
    }

    /// @ f32::erfc
    #[inline(always)]
    fn erfc(self: f64) -> f64 {
        libc::erfc(self)
    }

    /// @ f32::exp
    #[inline(always)]
    fn exp(self: f64) -> f64 {
        libc::exp(self)
    }

    /// @ f32::floor
    #[inline(always)]
    fn floor(self: f64) -> f64 {
        libc::floor(self)
    }

    /// @ f32::frexp
    #[inline(always)]
    fn frexp(self: f64) -> (f64, i32) {
        let out: i32;
        let val = libc::frexp(self, &out);
        (val, out)
    }

    /// @ f32::ldexp
    #[inline(always)]
    fn ldexp(self: f64, exp: i32) -> f64 {
        libc::ldexp(self, exp)
    }

    /// @ f32::log
    #[inline(always)]
    fn log(self: f64) -> f64 {
        libc::log(self)
    }

    /// @ f32::log2
    #[inline(always)]
    fn log2(self: f64) -> f64 {
        libc::log2(self)
    }

    /// @ f32::log10
    #[inline(always)]
    fn log10(self: f64) -> f64 {
        libc::log10(self)
    }

    /// @ f32::modf
    #[inline(always)]
    fn modf(self: f64) -> (f64, f64) {
        let out: f64;
        let val = libc::modf(self, &out);
        (out, val)
    }

    /// @ f32::pow
    #[inline(always)]
    fn pow(self: f64, other: f64) -> f64 {
        libc::pow(self, other)
    }

    /// @ f32::round
    #[inline(always)]
    fn round(self: f64) -> f64 {
        libc::round(self)
    }

    /// @ f32::sin
    #[inline(always)]
    fn sin(self: f64) -> f64 {
        libc::sin(self)
    }

    /// @ f32::sinh
    #[inline(always)]
    fn sinh(self: f64) -> f64 {
        libc::sinh(self)
    }

    /// @ f32::sqrt
    #[inline(always)]
    fn sqrt(self: f64) -> f64 {
        libc::sqrt(self)
    }

    /// @ f32::tan
    #[inline(always)]
    fn tan(self: f64) -> f64 {
        libc::tan(self)
    }

    /// @ f32::tanh
    #[inline(always)]
    fn tanh(self: f64) -> f64 {
        libc::tanh(self)
    }

    /// @ f32::trunc
    #[inline(always)]
    fn trunc(self: f64) -> f64 {
        libc::trunc(self)
    }
}

/// Method implementations for fixed size arrays
///
/// Working with slices is often more convenient than working with arrays. See also
/// [mem::slice] for methods on slices.
#[lang(builtin_array)]
#[docs(builtin)]
struct array {}
impl array<Arr: builtins::Array> {
    /// @ mem::AsSlice::as_slice
    #[inline(always)]
    fn as_slice(self: &Arr) -> &[element_of<Arr>] {
        self
    }

    /// @ mem::AsSlice::as_slice
    #[inline(always)]
    fn as_slice_mut(self: &mut Arr) -> &mut [element_of<Arr>] {
        self
    }

    /// Returns a pointer to the first element.
    #[inline(always)]
    fn as_ptr(self: &Arr) -> &element_of<Arr> {
        &self[0]
    }

    /// Returns a mutable pointer to the first element.
    #[inline(always)]
    fn as_ptr_mut(self: &mut Arr) -> &mut element_of<Arr> {
        &self[0]
    }

    /// Returns the number of elements in the array.
    ///
    /// Prefer to use this function instead of [mem::size_of], as it can lead to surprising results
    /// when array's element is a zero-sized type.
    ///
    /// ## Example
    /// ```
    /// let a: [u32; 8];
    /// let b: [u32; 0];
    /// let c: [(); 10]; // zero-sized
    ///
    /// assert_eq!(a.len(), 8);
    /// assert_eq!(b.len(), 0);
    /// assert_eq!(c.len(), 10);
    /// ```
    #[inline(ir)]
    fn len(self: &Arr) -> usize {
        intrinsics::length_of::<Arr>()
    }

    /// @ iter::Iterable::iter
    #[inline]
    fn iter(self: &Arr) -> mem::SliceIterator<&element_of<Arr>> {
        self.as_slice().iter()
    }

    /// @ cmp::Equatable::equals
    #[inline]
    fn equals(lhs: &Arr, rhs: &Arr) -> bool {
        lhs[..] == rhs[..]
    }

    /// @ hash::Hashable::hash
    #[inline]
    fn hash<H: Hasher<H>>(lhs: &Arr, h: &mut H) {
        for elem in lhs.iter() {
            elem.hash(h);
        }
    }

    mixin cmp::Equatable<Arr>;
}

/// Method implementations for tuples
///
/// Tuples are fixed-size collections of elements of different types. They are often used to
/// return multiple values from a function or to group values of different types together.
///
/// A single-element tuple is represented as `(T,)`, where `T` is the type of the element. An empty
/// tuple `()` is also known as [void].
#[lang(builtin_tuple)]
#[docs(builtin)]
struct tuple {}

impl tuple<Tup: Tuple> {
    /// Returns the number of elements in the tuple.
    ///
    /// ## Example
    /// ```
    /// let tuple = (1, 2, 3);
    /// assert_eq!(tuple.len(), 3);
    /// ```
    #[inline]
    fn len(self: &Tup) -> usize {
        intrinsics::length_of::<Tup>()
    }

    /// @ cmp::Equatable::equals
    #[inline]
    fn equals(lhs: &Tup, rhs: &Tup) -> bool {
        for const i in 0usize..lhs.len() {
            if lhs.(i) != rhs.(i) {
                return false;
            }
        }
        true
    }

    /// @ cmp::Comparable::compare
    #[inline]
    fn compare(lhs: &Tup, rhs: &Tup) -> Ordering {
        for const i in 0usize..lhs.len() {
            lex_compare!(lhs.(i), rhs.(i));
        }
        Ordering::Equal
    }

    /// @ hash::Hashable::hash
    #[inline]
    fn hash<H: Hasher<H>>(lhs: &Tup, h: &mut H) {
        for const i in 0usize..lhs.len() {
            lhs.(i).hash(h);
        }
    }

    mixin Equatable<Tup>;
    mixin Comparable<Tup>;
}

/// Method implementations for callable objects (named functions, function pointers, closures)
#[lang(builtin_callable)]
#[docs(builtin)]
struct callable {}
impl callable {
    /// Call a function with arguments passed as a tuple.
    ///
    /// ## Example
    /// ```
    /// fn add(a: i32, b: i32) -> i32 {
    ///     a + b
    /// }
    ///
    /// let args = (1, 2);
    /// let result = add.invoke(args);
    ///
    /// assert_eq!(result, 3);
    /// ```
    #[inline(ir)]
    fn invoke<Args, Ret, F: Fn(Args...) -> Ret>(f: F, args: Args) -> Ret {
        intrinsics::tuple_invoke(f, args)
    }

    /// Converts a pointer to closure to a C-style state and function pointer pair.
    ///
    /// This function is used to pass closures to C functions that expect a function pointer and a
    /// state pointer, that is passed as the first argument to the function when the callback is
    /// called.
    ///
    /// ## Example
    /// ```no_test
    /// use libc::{c_int, c_char};
    ///
    /// extern "C" fn sqlite3_exec(
    ///     db: &mut sqlite3,
    ///     sql: &c_char,
    ///     callback: fn(&mut void, c_int, &mut &mut c_char, &mut &mut c_char) -> c_int,
    ///     state: &mut void, // тое
    ///     errmsg: &mut &mut c_char,
    /// ) -> libc::c_int;
    ///
    /// let db = /* ... */;
    /// let file = File::open(/* ... */);
    /// defer file.close();
    ///
    /// // Prints the rows of a table to a file that's captured by the closure.
    /// let print = |&file, num_cols: c_int, values: &mut &mut c_char, _: &mut &mut c_char| {
    ///     /// ... print values to file ...
    ///     0
    /// };
    ///
    /// let (state, callback) = print.as_callback();
    /// sqlite3_exec(
    ///     &mut db,
    ///     "SELECT * FROM users\0".as_ptr() as &c_char,
    ///     callback,
    ///     state,
    ///     null
    /// );
    /// ```
    #[inline]
    fn as_callback<Args, Ret, F: Closure + Fn(Args...) -> Ret>(f: &mut F) -> (&mut void, fn(&mut void, Args...) -> Ret) {
        use underlying_function_of as u;

        (
            f as &mut void,
            util::unit::<u<F>>()
                as fn(arguments_of<u<F>>...) -> Ret
                as fn(&mut void, Args...) -> Ret,
        )
    }
}

// The following are "type-operators", pseudo-types, implemented inside the compiler
// that resolve to other types based on the type of the generic parameters. Ideally,
// these would be implemented in the standard library, but the infer system is not
// yet sufficiently powerful for this.

/// Unsigned integer type of the same size as the original type.
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::unsigned_of;
///
/// assert!(matches::<unsigned_of<i32>, u32>());
/// assert!(matches::<unsigned_of<isize>, usize>());
///
/// assert!(matches::<unsigned_of<u8>, u8>());
/// ```
type unsigned_of<T: Integer> = when typing::matches::<T, i8>() {
    u8
} else when typing::matches::<T, i16>() {
    u16
} else when typing::matches::<T, i32>() {
    u32
} else when typing::matches::<T, i64>() {
    u64
} else when typing::matches::<T, i128>() {
    u128
} else when typing::matches::<T, isize>() {
    usize
} else {
    T
};

/// Signed integer type of the same size as the original type.
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::signed_of;
///
/// assert!(matches::<signed_of<u32>, i32>());
/// assert!(matches::<signed_of<usize>, isize>());
///
/// assert!(matches::<signed_of<i8>, i8>());
/// ```
type signed_of<T: Integer> = when typing::is_same::<T, u8>() {
    i8
} else when typing::is_same::<T, u16>() {
    i16
} else when typing::is_same::<T, u32>() {
    i32
} else when typing::is_same::<T, u64>() {
    i64
} else when typing::is_same::<T, u128>() {
    i128
} else when typing::is_same::<T, usize>() {
    isize
} else {
    T
};

/// Element type of the provided array
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::element_of;
///
/// assert!(matches::<element_of<[i32; 3]>, i32>());
/// ```
type element_of<T: Array> = typeof({ let t: T; t[0] });

/// Return type of the provided function
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::return_type_of;
///
/// fn add(x: i32, y: i32) -> i32 { x + y }
///
/// assert!(matches::<return_type_of<add>, i32>());
/// assert!(matches::<return_type_of<fn() -> u8>, u8>());
/// ```
#[lang(typeop_return_type_of)]
type return_type_of<T>;

/// Tuple of argument types of the provided function
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::arguments_of;
///
/// fn add(x: i32, y: i32) -> i32 { x + y }
///
/// assert!(matches::<arguments_of<add>, (i32, i32)>());
/// assert!(matches::<arguments_of<fn() -> u8>, ()>());
/// ```
#[lang(typeop_arguments_of)]
type arguments_of<T>;

/// Tuple of the generic arguments of a given type
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::generic_args_of;
///
/// fn add<T>(x: T, y: T) -> T { x + y }
///
/// assert!(matches::<generic_args_of<add<i32>>, (i32,)>());
/// assert!(matches::<generic_args_of<Result<&[u8], i32>>, (&[u8], i32)>());
/// assert!(matches::<generic_args_of<std::cmp::Ordering>, ()>());
/// ```
#[lang(typeop_generic_args_of)]
type generic_args_of<T>;


/// Type with replaced generic arguments provided by a tuple
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::replace_generic_args_of;
///
/// let o = Option::some(42);
///
/// assert!(matches::<replace_generic_args_of<typeof(o), (bool,)>, Option<bool>>());
/// ```
#[lang(typeop_replace_generic_args_of)]
type replace_generic_args_of<T, Args: Tuple>;

/// Pointer to `T` with same constness as `Ptr`.
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::pointer_with_mut_of;
///
/// assert!(matches::<pointer_with_mut_of<void, &i32>, &void>());
/// assert!(matches::<pointer_with_mut_of<usize, &mut Option<usize>>, &mut usize>());
/// ```
#[lang(typeop_pointer_with_mut_of)]
type pointer_with_mut_of<T, Ptr: Pointer>;

/// Array of `T` with same length as `Arr`.
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::array_with_length_of;
///
/// assert!(matches::<array_with_length_of<i32, [(); 42]>, [i32; 42]>());
/// assert!(matches::<array_with_length_of<Option<bool>, [i64; 1337]>, [Option<bool>; 1337]>());
/// ```
#[lang(typeop_array_with_length_of)]
type array_with_length_of<T, Arr: Array>;

/// Backing type of an `enum` or a `const`/`static` type.
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::underlying_type_of;
///
/// enum Foo { A, B, C }
/// enum Bar { A = 0usize, B, C }
///
/// const FOO: i32 = 42;
/// static BAR: usize = 42;
///
/// assert!(matches::<underlying_type_of<Foo>, i32>());
/// assert!(matches::<underlying_type_of<Bar>, usize>());
/// assert!(matches::<underlying_type_of<FOO>, i32>());
/// assert!(matches::<underlying_type_of<BAR>, usize>());
/// ```
#[lang(typeop_underlying_type_of)]
type underlying_type_of<T: Enum | Static | Const | Closure>;

/// Underlying function of a closure
///
/// Underlying function is a regular named function that accepts the closure object as its first
/// argument by a mutable pointer.
///
/// See also [builtins::callable::as_callback] for a function that converts a pointer to a closure
/// into a C-style void pointer and a function pointer pair.
///
/// ## Example
/// ```
/// use std::builtins::underlying_function_of;
///
/// let a = 1;
/// let f = |=a, x: i32| -> i32 { x + a };
///
/// let g: underlying_function_of<typeof(f)>;
///
/// assert_eq!(
///     f(2),
///     g(&f, 2)
/// );
/// ```
#[lang(typeop_underlying_function_of)]
type underlying_function_of<T: Closure>;

/// Make a function pointer type from a tuple of arguments and the return type.
///
/// ## Example
/// ```
/// use std::typing::matches;
/// use std::builtins::function_pointer_of;
///
/// assert!(matches::<function_pointer_of<(i32, ), i32>, fn(i32) -> i32>());
/// ```
#[lang(typeop_function_pointer_of)]
type function_pointer_of<Args: Tuple, Ret = ()>;

/// Matches zero-sized types (void, named function types, empty structs, empty arrays, ...)
#[lang(proto_zero_sized)] protocol ZeroSized {}

/// Matches all primitive types
#[lang(proto_primitive)] protocol Primitive {}

/// Integer and floating point types
#[lang(proto_numeric)] protocol Numeric {}

/// Integer types
#[lang(proto_integer)] protocol Integer {}

/// Floating point types
#[lang(proto_floating_point)] protocol FloatingPoint {}

/// Signed integer types (`i8`, `i16`, `i32`, ...)
#[lang(proto_signed)] protocol Signed {}

/// Unsigned integer types (`u8`, `u16`, `u32`, ...)
#[lang(proto_unsigned)] protocol Unsigned {}

/// All pointers
#[lang(proto_pointer)] protocol Pointer {}

/// All (fixed-size) arrays
#[lang(proto_array)] protocol Array {}

/// All tuples
#[lang(proto_tuple)] protocol Tuple {}

/// All structs
#[lang(proto_struct)] protocol Struct {}

/// All unions
#[lang(proto_union)] protocol Union {}

/// All enums
#[lang(proto_enum)] protocol Enum {}

/// All ranges (`a..b`, `a..=b`, `..b`, `..=b`, ...)
#[lang(proto_range)] protocol Range {}

/// All named functions (including lambdas, but excluding closures)
#[lang(proto_named_function)] protocol NamedFunction {}

/// Function pointers
#[lang(proto_function_pointer)] protocol FunctionPointer {}

/// Closures
#[lang(proto_closure)] protocol Closure {}

/// Named constants
#[lang(proto_const)] protocol Const {}

/// Static variables
#[lang(proto_static)] protocol Static {}

/// All callable objects (named functions, closures, and function pointers)
///
/// Equivalent to a more expressive syntax `Fn(Args) -> Ret` or `Fn(Args)` when `Ret` is `()`.
///
/// `Args` is a tuple of the argument types of the function and `Ret` is the return type,
/// for example `fn foo(a: i32, b: i64) -> usize` would match `Callable<(i32, i64), usize>`.
#[lang(proto_callable)] protocol Callable<Args: Tuple, Ret = ()> {}

// These are mostly useful as type inference guides

/// Arrays with element type `T`
#[lang(proto_array_of)] protocol ArrayOf<T> {}

/// Pointers to `T` (regardless of mutability)
#[lang(proto_pointer_of)] protocol PointerOf<T> {}

/// Range over `T`
#[lang(proto_range_of)] protocol RangeOf<T: Integer> {}

/// All protocols
#[lang(proto_meta)] protocol Protocol {}

/// Matches types that are layout-compatible with `T` (same size and alignment)
#[lang(proto_same_layout_as)] protocol SameLayoutAs<T> {}

/// Matches types that are a monomorphization of the same base type as `T`
#[lang(proto_same_base_as)] protocol SameBaseAs<T> {}

/// A special protocol that matches any type
#[lang(proto_any)] protocol Any {}

/// A special protocol that never matches
#[lang(proto_none)] protocol None {}

#[docs(no_index)]
mod internal {
    /// This mixin implements Equatable and Comparable for types that have natively implemented
    /// equality and comparison operators.
    protocol BuiltinComparable<Self: builtins::Numeric> {
        /// @ cmp::Equatable::equals
        #[inline(ir)] fn equals(lhs: &Self, rhs: &Self) -> bool { *lhs == *rhs }
        /// @ cmp::Equatable::not_equals
        #[inline(ir)] fn not_equals(lhs: &Self, rhs: &Self) -> bool { *lhs != *rhs }
        /// @ cmp::Comparable::compare
        #[inline(always)]
        fn compare(lhs: &Self, rhs: &Self) -> Ordering {
            if *lhs < *rhs {
                Ordering::Less
            } else if *lhs == *rhs {
                Ordering::Equal
            } else {
                Ordering::Greater
            }
        }

        /// @ cmp::Comparable::less_than
        #[inline(ir)] fn less_than(lhs: &Self, rhs: &Self) -> bool { *lhs < *rhs }
        /// @ cmp::Comparable::less_than_or_equal
        #[inline(ir)] fn less_than_or_equal(lhs: &Self, rhs: &Self) -> bool { *lhs <= *rhs }
        /// @ cmp::Comparable::greater_than
        #[inline(ir)] fn greater_than(lhs: &Self, rhs: &Self) -> bool { *lhs > *rhs }
        /// @ cmp::Comparable::greater_than_or_equal
        #[inline(ir)] fn greater_than_or_equal(lhs: &Self, rhs: &Self) -> bool { *lhs >= *rhs }
    }

    /// Mixin for parsing integers from strings.
    protocol IntegerParsable<Self: builtins::Integer> {
        /// Parses the integer from a base-10 string.
        ///
        /// If the string does not represent a valid integer, `Option::none()` is returned.
        ///
        /// ## Example
        /// ```
        /// assert_eq!(i32::parse("10"), Option::some(10));
        /// assert_eq!(i32::parse("foo"), Option::none());
        /// ```
        #[inline]
        fn parse(s: &[u8]) -> Option<Self> {
            string::parse_integer::<Self>(s, 10)
        }

        /// Parses the integer from a string in a given base.
        ///
        /// If the string does not represent a valid integer in the given base, `Option::none()` is
        /// returned.
        ///
        /// ## Example
        /// ```
        /// assert_eq!(i32::parse_with_radix("10", 2), Option::some(2));
        /// assert_eq!(u64::parse_with_radix("deadbeef", 16), Option::some(0xdeadbeefu64));
        /// assert_eq!(i32::parse_with_radix("foo", 10), Option::none());
        /// ```
        #[inline]
        fn parse_with_radix(s: &[u8], radix: u16) -> Option<Self> {
            string::parse_integer::<Self>(s, radix)
        }
    }

    /// String formatting mixin for integers.
    protocol IntegerFormattable<Self: builtins::Integer, F: Formatter<F>> {
        /// @ fmt::Formattable::fmt
        #[inline]
        fn fmt(self: &Self, formatter: &mut F) -> Result<(), fmt::Error> {
            fmt::internal::format_integer(*self, 10, 0, formatter)
        }
    }

    /// Hashing mixin for integers.
    protocol IntegerHashable<Self: builtins::Integer, H: Hasher<H>> {
        /// @ hash::Hashable::hash
        #[inline]
        fn hash(self: &Self, hasher: &mut H) {
            use mem::{size_of,slice::from_raw};
            hasher.write(from_raw(self as &u8, size_of::<Self>()));
        }
    }

    /// String formatting mixin for floating-point types.
    protocol FloatFormattable<Self: builtins::FloatingPoint, F: Formatter<F>> {
        /// @ fmt::Formattable::fmt
        #[inline]
        fn fmt(self: &Self, formatter: &mut F) -> Result<(), fmt::Error> {
            fmt::internal::format_float(*self, formatter, 15)
        }
    }

    /// Mixin for wrapping and checked arithmetic operations.
    protocol WithOverflow<Self> {
        /// Adds two numbers, wrapping around at the boundary of the type.
        #[inline]
        fn wrapping_add(lhs: Self, rhs: Self) -> Self {
            if runtime::in_const_context() {
                ((lhs as unsigned_of<Self>) + (rhs as unsigned_of<Self>)) as Self
            } else {
                let ret: Self;
                intrinsics::codegen_func::<bool>("__builtin_add_overflow", lhs, rhs, &ret);
                ret
            }
        }

        /// Subtracts two numbers, wrapping around at the boundary of the type.
        #[inline]
        fn wrapping_sub(lhs: Self, rhs: Self) -> Self {
            if runtime::in_const_context() {
                ((lhs as unsigned_of<Self>) - (rhs as unsigned_of<Self>)) as Self
            } else {
                let ret: Self;
                intrinsics::codegen_func::<bool>("__builtin_sub_overflow", lhs, rhs, &ret);
                ret
            }
        }

        /// Multiplies two numbers, wrapping around at the boundary of the type.
        #[inline]
        fn wrapping_mul(lhs: Self, rhs: Self) -> Self {
            if runtime::in_const_context() {
                ((lhs as unsigned_of<Self>) * (rhs as unsigned_of<Self>)) as Self
            } else {
                let ret: Self;
                intrinsics::codegen_func::<bool>("__builtin_mul_overflow", lhs, rhs, &ret);
                ret
            }
        }

        /// Divides two numbers, wrapping around at the boundary of the type.
        ///
        /// The only case where such wrapping can occur is when one divides `MIN / -1` on a
        /// signed type. This is equivalent to `-MIN`, a number that is too large to represent in
        /// the type. In such a case, this function returns `MIN` itself.
        #[inline]
        fn wrapping_div(lhs: Self, rhs: Self) -> Self {
            when lhs is Unsigned {
                lhs / rhs
            } else {
                if lhs == Self::min_value() && rhs == -1 {
                    Self::min_value()
                } else {
                    lhs / rhs
                }
            }
        }

        /// Tries to add two numbers, returning `Option::none()` if overflow occurrs.
        #[inline]
        fn checked_add(lhs: Self, rhs: Self) -> Option<Self> {
            let ret: Self;
            if intrinsics::codegen_func::<bool>("__builtin_add_overflow", lhs, rhs, &ret) {
                Option::none()
            } else {
                Option::some(ret)
            }
        }

        /// Tries to subtract two numbers, returning `Option::none()` if overflow occurrs.
        #[inline]
        fn checked_sub(lhs: Self, rhs: Self) -> Option<Self> {
            let ret: Self;
            if intrinsics::codegen_func::<bool>("__builtin_sub_overflow", lhs, rhs, &ret) {
                Option::none()
            } else {
                Option::some(ret)
            }
        }

        /// Tries to multiply two numbers, returning `Option::none()` if overflow occurrs.
        #[inline]
        fn checked_mul(lhs: Self, rhs: Self) -> Option<Self> {
            let ret: Self;
            if intrinsics::codegen_func::<bool>("__builtin_mul_overflow", lhs, rhs, &ret) {
                Option::none()
            } else {
                Option::some(ret)
            }
        }

        /// Tries to divide two numbers, returning `Option::none()` if overflow occurrs or
        /// `rhs` is zero.
        ///
        /// Overflow during division can only happen when one divides `MIN / -1` on a signed type.
        #[inline]
        fn checked_div(lhs: Self, rhs: Self) -> Option<Self> {
            if rhs == 0 {
                return Option::none();
            }

            when lhs is Unsigned {
                Option::some(lhs / rhs)
            } else {
                if lhs == Self::min_value() && rhs == -1 {
                    Option::none()
                } else {
                    Option::some(lhs / rhs)
                }
            }
        }
    }

    /// Bitwise operations on unsigned integers
    protocol BitOps<Self: builtins::Unsigned> {
        /// Swaps the byte order (endianness) of the number.
        ///
        /// ## Example
        /// ```
        /// assert_eq!(0x0123u16.swap_bytes(), 0x2301);
        /// ```
        #[inline]
        fn swap_bytes(self: Self) -> Self {
            when self is usize {
                #[cfg(target_pointer_width = "64")]
                {
                    (self as u64).swap_bytes() as usize
                }
                #[cfg(target_pointer_width = "32")]
                {
                    (self as u32).swap_bytes() as usize
                }
            } else when self is u8 {
                self
            } else when self is u16 {
                (self >> 8) | (self << 8)
            } else when self is u32 {
                (self >> 24)
                | ((self >> 8) & 0x0000FF00u32)
                | ((self << 8) & 0x00FF0000u32)
                | (self << 24)
            } else when self is u64 {
                (self >> 56)
                | ((self >> 40) & 0x000000000000FF00u64)
                | ((self >> 24) & 0x0000000000FF0000u64)
                | ((self >> 8)  & 0x00000000FF000000u64)
                | ((self << 8)  & 0x000000FF00000000u64)
                | ((self << 24) & 0x0000FF0000000000u64)
                | ((self << 40) & 0x00FF000000000000u64)
                | (self << 56)
            } else when self is u128 {
                (self >> 120)
                | ((self >> 104) & 0x0000000000000000000000000000FF00u128)
                | ((self >> 88) & 0x00000000000000000000000000FF0000u128)
                | ((self >> 72) & 0x000000000000000000000000FF000000u128)
                | ((self >> 56) & 0x0000000000000000000000FF00000000u128)
                | ((self >> 40) & 0x00000000000000000000FF0000000000u128)
                | ((self >> 24) & 0x000000000000000000FF000000000000u128)
                | ((self >> 8)  & 0x0000000000000000FF00000000000000u128)
                | ((self << 8)  & 0x00000000000000FF0000000000000000u128)
                | ((self << 24) & 0x000000000000FF000000000000000000u128)
                | ((self << 40) & 0x0000000000FF00000000000000000000u128)
                | ((self << 56) & 0x00000000FF0000000000000000000000u128)
                | ((self << 72) & 0x000000FF000000000000000000000000u128)
                | ((self << 88) & 0x0000FF00000000000000000000000000u128)
                | ((self << 104) & 0x00FF0000000000000000000000000000u128)
                | (self << 120)
            } else {
                compile_fail!("unexpected integer type");
            }
        }

        /// Converts the number into a big-endian representation.
        ///
        /// If the numbers of this type are represented in big-endian order on the target
        /// architecture, then this is an identity function.
        ///
        /// ## Example
        /// ```
        /// #[cfg(target_endian = "little")]
        /// assert_eq!(0x0123u16.to_be(), 0x2301);
        ///
        /// #[cfg(target_endian = "big")]
        /// assert_eq!(0x0123u16.to_be(), 0x0123);
        /// ```
        #[inline]
        fn to_be(self: Self) -> Self {
            #[cfg(prince_of_denmark = "hamlet")]
            {
                intrinsics::compile_note("...or not to be, that is the question.");
            }
            #[cfg(target_endian = "big")]
            {
                self
            }
            #[cfg(target_endian = "little")]
            {
                self.swap_bytes()
            }
        }

        /// Converts the number from a big-endian representation.
        ///
        /// If the numbers of this type are represented in big-endian order on the target
        /// architecture, then this is an identity function.
        /// ## Example
        /// ```
        /// #[cfg(target_endian = "little")]
        /// assert_eq!(0x0123u16.from_be(), 0x2301);
        ///
        /// #[cfg(target_endian = "big")]
        /// assert_eq!(0x0123u16.from_be(), 0x0123);
        /// ```
        #[inline]
        fn from_be(self: Self) -> Self {
            self.to_be()
        }

        /// Converts the number into a little-endian representation.
        ///
        /// If the numbers of this type are represented in little-endian order on the target
        /// architecture, then this is an identity function.
        /// ## Example
        /// ```
        /// #[cfg(target_endian = "little")]
        /// assert_eq!(0x0123u16.to_le(), 0x0123);
        ///
        /// #[cfg(target_endian = "big")]
        /// assert_eq!(0x0123u16.to_le(), 0x2301);
        /// ```
        #[inline]
        fn to_le(self: Self) -> Self {
            #[cfg(target_endian = "big")]
            {
                self.swap_bytes()
            }
            #[cfg(target_endian = "little")]
            {
                self
            }
        }

        /// Converts the number from a little-endian representation.
        ///
        /// If the numbers of this type are represented in little-endian order on the target
        /// architecture, then this is an identity operation.
        /// ## Example
        /// ```
        /// #[cfg(target_endian = "little")]
        /// assert_eq!(0x0123u16.from_le(), 0x0123);
        ///
        /// #[cfg(target_endian = "big")]
        /// assert_eq!(0x0123u16.from_le(), 0x2301);
        /// ```
        #[inline]
        fn from_le(self: Self) -> Self {
            self.to_le()
        }

        /// Returns the number of ones in the binary representation of the number.
        ///
        /// ## Example
        /// ```
        /// assert_eq!(0b10101000u8.count_ones(), 3);
        /// ```
        #[inline]
        fn count_ones(self: Self) -> u32 {
            use libc::{c_int, c_ulong, c_ulonglong, c_uint};

            when self is usize {
                #[cfg(target_pointer_width = "64")]
                {
                    (self as u64).count_ones()
                }
                #[cfg(target_pointer_width = "32")]
                {
                    (self as u32).count_ones()
                }
            } else {
                let ret = when self is u128 {
                    return ((self >> 64) as u64).count_ones() + (self as u64).count_ones();
                } else when self is c_ulonglong {
                    intrinsics::codegen_func::<c_int>("__builtin_popcountll", self)
                } else when self is c_ulong {
                    intrinsics::codegen_func::<c_int>("__builtin_popcountl", self)
                } else {
                    intrinsics::codegen_func::<c_int>("__builtin_popcount", self as c_uint)
                };

                ret as u32
            }
        }

        /// Returns the number of zeros in the binary representation of the number.
        /// ## Example
        /// ```
        /// assert_eq!(0b10101000u8.count_zeros(), 5);
        /// ```
        #[inline]
        fn count_zeros(self: Self) -> u32 {
            (~self).count_ones()
        }

        /// Returns the number of leading zeros in the binary representation of the number.
        /// ## Example
        /// ```
        /// assert_eq!(0b00010000u8.leading_zeros(), 3);
        /// ```
        #[inline]
        fn leading_zeros(self: Self) -> u32 {
            use libc::{c_int, c_ulong, c_uint, c_ulonglong};
            use mem::size_of;

            when self is usize {
                #[cfg(target_pointer_width = "64")]
                {
                    (self as u64).leading_zeros()
                }
                #[cfg(target_pointer_width = "32")]
                {
                    (self as u32).leading_zeros()
                }
            } else {
                if self == 0 {
                    return (size_of::<Self>() * 8) as u32;
                }

                let ret = when self is u128 {
                    let head = (self >> 64) as u64;
                    if head == 0 {
                        return (self as u64).leading_zeros() + 64;
                    } else {
                        return head.leading_zeros();
                    }
                } else when self is c_ulonglong {
                    intrinsics::codegen_func::<c_int>("__builtin_clzll", self)
                } else when self is c_ulong {
                    intrinsics::codegen_func::<c_int>("__builtin_clzl", self)
                } else when self is c_uint {
                    intrinsics::codegen_func::<c_int>("__builtin_clz", self)
                } else {
                    let val =
                        ((self as c_uint) << (8 * (size_of::<c_uint>() - size_of::<Self>()))) |
                        (c_uint::max_value() >> (8 * size_of::<Self>()));

                    intrinsics::codegen_func::<c_int>("__builtin_clz", val)
                };

                ret as u32
            }
        }

        /// Returns the number of trailing zeros in the binary representation of the number.
        /// ## Example
        /// ```
        /// assert_eq!(0b00010000u8.trailing_zeros(), 4);
        /// ```
        #[inline]
        fn trailing_zeros(self: Self) -> u32 {
            use libc::{c_int, c_ulong, c_uint, c_ulonglong};
            use mem::size_of;

            when self is usize {
                #[cfg(target_pointer_width = "64")]
                {
                    (self as u64).trailing_zeros()
                }
                #[cfg(target_pointer_width = "32")]
                {
                    (self as u32).trailing_zeros()
                }
            } else {
                if self == 0 {
                    return (size_of::<Self>() * 8) as u32;
                }

                let ret = when self is u128 {
                    let tail = self as u64;
                    if tail == 0 {
                        return ((self >> 64) as u64).trailing_zeros() + 64;
                    } else {
                        return tail.trailing_zeros();
                    }
                } else when self is c_ulonglong {
                    intrinsics::codegen_func::<c_int>("__builtin_ctzll", self)
                } else when self is c_ulong {
                    intrinsics::codegen_func::<c_int>("__builtin_ctzl", self)
                } else when self is c_uint {
                    intrinsics::codegen_func::<c_int>("__builtin_ctz", self)
                } else {
                    let val =
                        (c_uint::max_value() << (8 * size_of::<Self>())) | (self as c_uint);

                    intrinsics::codegen_func::<c_int>("__builtin_ctz", val)
                };

                ret as u32
            }
        }

        /// Returns the number of leading ones in the binary representation of the number.
        /// ## Example
        /// ```
        /// assert_eq!(0b11111110u8.leading_ones(), 7);
        /// ```
        #[inline]
        fn leading_ones(self: Self) -> u32 {
            (~self).leading_zeros()
        }

        /// Returns the number of trailing ones in the binary representation of the number.
        /// ## Example
        /// ```
        /// assert_eq!(0b00000111u8.trailing_ones(), 3);
        /// ```
        #[inline]
        fn trailing_ones(self: Self) -> u32 {
            (~self).trailing_zeros()
        }

        /// Rotates the bits to the left by `n` bits.
        /// ## Example
        /// ```
        /// assert_eq!(0b01000111u8.rotate_left(2), 0b00011101u8);
        /// ```
        #[inline]
        fn rotate_left(self: Self, n: usize) -> Self {
            if n == 0 {
                self
            } else {
                (self << n) | (self >> ((8 * mem::size_of::<Self>()) - n))
            }
        }

        /// Rotates the bits to the right by `n` bits.
        /// ## Example
        /// ```
        /// assert_eq!(0b01000111u8.rotate_right(2), 0b11010001u8);
        /// ```
        #[inline]
        fn rotate_right(self: Self, n: usize) -> Self {
            if n == 0 {
                self
            } else {
                (self >> n) | (self << ((8 * mem::size_of::<Self>()) - n))
            }
        }
    }

    /// Mixin for common floating point functions
    protocol FloatOps<Self> {
        /// Returns `NaN`.
        #[inline(ir)]
        fn nan() -> Self {
            (0.0 as Self) / (0.0 as Self)
        }

        /// Returns a positive infinity.
        #[inline(ir)]
        fn infinity() -> Self {
            (1.0 as Self) / (0.0 as Self)
        }

        /// Returns a negative infinity.
        #[inline(ir)]
        fn neg_infinity() -> Self {
            (-1.0 as Self) / (0.0 as Self)
        }

        /// Returns `true` if the number is NaN, `false` otherwise.
        #[inline]
        fn is_nan(self: Self) -> bool {
            self != self
        }

        /// Returns `true` if the number is infinite, `false` otherwise.
        #[inline]
        fn is_infinite(self: Self) -> bool {
            !self.is_nan() && !self.is_finite()
        }

        /// Returns `true` if the number is neither infinite nor NaN, `false` otherwise.
        #[inline]
        fn is_finite(self: Self) -> bool {
            !self.is_nan() && self < Self::infinity() && self > Self::neg_infinity()
        }
    }
}

#[cfg(all(test, test_std))]
#[docs(hide)]
mod tests {
    #[test]
    fn unsigned_num_limits() {
        assert_eq!(u8::max_value() + 1, u8::min_value());
        assert_eq!(u16::max_value() + 1, u16::min_value());
        assert_eq!(u32::max_value() + 1, u32::min_value());
        assert_eq!(u64::max_value() + 1, u64::min_value());
        assert_eq!(usize::max_value() + 1, usize::min_value());
        assert_eq!(u128::max_value() + 1, u128::min_value());
    }

    #[test]
    fn signed_num_limits() {
        // Signed overflow is UB, so we round-trip via unsigned equivalent
        assert_eq!((i8::max_value() as u8 + 1) as i8, i8::min_value());
        assert_eq!((i16::max_value() as u16 + 1) as i16, i16::min_value());
        assert_eq!((i32::max_value() as u32 + 1) as i32, i32::min_value());
        assert_eq!((i64::max_value() as u64 + 1) as i64, i64::min_value());
        assert_eq!((isize::max_value() as usize + 1) as isize, isize::min_value());
        assert_eq!((i128::max_value() as u128 + 1) as i128, i128::min_value());
    }

    #[test]
    fn test_signed_of() {
        use typing::type_id;

        assert_eq!(type_id::<signed_of<u8>>(), type_id::<i8>());
        assert_eq!(type_id::<signed_of<u16>>(), type_id::<i16>());
        assert_eq!(type_id::<signed_of<u32>>(), type_id::<i32>());
        assert_eq!(type_id::<signed_of<u64>>(), type_id::<i64>());
        assert_eq!(type_id::<signed_of<usize>>(), type_id::<isize>());
        assert_eq!(type_id::<signed_of<u128>>(), type_id::<i128>());

        assert_eq!(type_id::<signed_of<i8>>(), type_id::<i8>());
        assert_eq!(type_id::<signed_of<i16>>(), type_id::<i16>());
        assert_eq!(type_id::<signed_of<i32>>(), type_id::<i32>());
        assert_eq!(type_id::<signed_of<i64>>(), type_id::<i64>());
        assert_eq!(type_id::<signed_of<isize>>(), type_id::<isize>());
        assert_eq!(type_id::<signed_of<i128>>(), type_id::<i128>());
    }

    #[test]
    fn test_unsigned_of() {
        use typing::type_id;

        assert_eq!(type_id::<unsigned_of<u8>>(), type_id::<u8>());
        assert_eq!(type_id::<unsigned_of<u16>>(), type_id::<u16>());
        assert_eq!(type_id::<unsigned_of<u32>>(), type_id::<u32>());
        assert_eq!(type_id::<unsigned_of<u64>>(), type_id::<u64>());
        assert_eq!(type_id::<unsigned_of<usize>>(), type_id::<usize>());
        assert_eq!(type_id::<unsigned_of<u128>>(), type_id::<u128>());

        assert_eq!(type_id::<unsigned_of<i8>>(), type_id::<u8>());
        assert_eq!(type_id::<unsigned_of<i16>>(), type_id::<u16>());
        assert_eq!(type_id::<unsigned_of<i32>>(), type_id::<u32>());
        assert_eq!(type_id::<unsigned_of<i64>>(), type_id::<u64>());
        assert_eq!(type_id::<unsigned_of<isize>>(), type_id::<usize>());
        assert_eq!(type_id::<unsigned_of<i128>>(), type_id::<u128>());
    }

    #[test]
    fn test_generic_args_of() {
        use typing::type_id;

        struct Foo {}

        assert_eq!(type_id::<generic_args_of<Foo>>(), type_id::<()>());
        assert_eq!(type_id::<generic_args_of<Option<Option<u8>>>>(), type_id::<(Option<u8>,)>());
        assert_eq!(type_id::<generic_args_of<io::Result<()>>>(), type_id::<((), io::Error)>());
    }

    #[test]
    fn test_swap_bytes() {
        assert_eq!(0x01u8.swap_bytes(), 0x01u8);
        assert_eq!(0x0123u16.swap_bytes(), 0x2301u16);
        assert_eq!(0x01234567u32.swap_bytes(), 0x67452301u32);
        assert_eq!(0x0123456789abcdefu64.swap_bytes(), 0xefcdab8967452301u64);
        assert_eq!(
            0x000102030405060708090a0b0c0d0e0fu128.swap_bytes(),
            0x0f0e0d0c0b0a09080706050403020100u128
        );

        use u16::to_be;

        // Totally not an excuse to work in some Shakespeare...
        #[cfg(target_endian = "little")]
        assert_eq!(0x100u16
            .to_be() | ~ to_be //, that is the question
        (0x1u16), 0xfeffu16);

        #[cfg(target_endian = "big")]
        assert_eq!(0x100u16
            .to_be() | ~ to_be //, that is the question
        (0x1u16), 0xfffeu16);
    }

    #[test]
    fn test_trailing_bits() {
        assert_eq!(0u8.trailing_zeros(), 8);
        assert_eq!(0u16.trailing_zeros(), 16);
        assert_eq!(0u32.trailing_zeros(), 32);
        assert_eq!(0u64.trailing_zeros(), 64);
        assert_eq!(0u128.trailing_zeros(), 128);

        #[cfg(target_pointer_width = "64")]
        assert_eq!(0usize.trailing_zeros(), 64);
        #[cfg(target_pointer_width = "32")]
        assert_eq!(0usize.trailing_zeros(), 32);

        assert_eq!(15u8.trailing_ones(), 4);
        assert_eq!(15u16.trailing_ones(), 4);
        assert_eq!(15u32.trailing_ones(), 4);
        assert_eq!(15u64.trailing_ones(), 4);
        assert_eq!(15u128.trailing_ones(), 4);
        assert_eq!(15usize.trailing_ones(), 4);

        assert_eq!(16u8.trailing_zeros(), 4);
        assert_eq!(16u16.trailing_zeros(), 4);
        assert_eq!(16u32.trailing_zeros(), 4);
        assert_eq!(16u64.trailing_zeros(), 4);
        assert_eq!(16u128.trailing_zeros(), 4);
        assert_eq!(16usize.trailing_zeros(), 4);
    }

    #[test]
    fn test_leading_bits() {
        assert_eq!(0u8.leading_zeros(), 8);
        assert_eq!(0u16.leading_zeros(), 16);
        assert_eq!(0u32.leading_zeros(), 32);
        assert_eq!(0u64.leading_zeros(), 64);
        assert_eq!(0u128.leading_zeros(), 128);

        #[cfg(target_pointer_width = "64")]
        assert_eq!(0usize.leading_zeros(), 64);
        #[cfg(target_pointer_width = "32")]
        assert_eq!(0usize.leading_zeros(), 32);

        assert_eq!(15u8.leading_ones(), 0);
        assert_eq!(15u16.leading_ones(), 0);
        assert_eq!(15u32.leading_ones(), 0);
        assert_eq!(15u64.leading_ones(), 0);
        assert_eq!(15u128.leading_ones(), 0);
        assert_eq!(15usize.leading_ones(), 0);

        assert_eq!(16u8.leading_zeros(), 3);
        assert_eq!(16u16.leading_zeros(), 11);
        assert_eq!(16u32.leading_zeros(), 27);
        assert_eq!(16u64.leading_zeros(), 59);
        assert_eq!(16u128.leading_zeros(), 123);
    }

    #[test]
    fn test_popcount() {
        assert_eq!(0xaau8.count_ones(), 4);
        assert_eq!(0xaaaau16.count_ones(), 8);
        assert_eq!(0xaaaaaaaau32.count_ones(), 16);
        assert_eq!(0xaaaaaaaaaaaaaaaau64.count_ones(), 32);
        assert_eq!(0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaau128.count_ones(), 64);

        assert_eq!(0xaaaaaaaausize.count_ones(), 16);

        assert_eq!(0xaau8.count_zeros(), 4);
        assert_eq!(0xaaaau16.count_zeros(), 8);
        assert_eq!(0xaaaaaaaau32.count_zeros(), 16);
        assert_eq!(0xaaaaaaaaaaaaaaaau64.count_zeros(), 32);
        assert_eq!(0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaau128.count_zeros(), 64);

        #[cfg(target_pointer_width = "64")]
        assert_eq!(0xaaaaaaaausize.count_zeros(), 48);

        #[cfg(target_pointer_width = "32")]
        assert_eq!(0xaaaaaaaausize.count_zeros(), 16);
    }

    #[test]
    fn test_array_length() {
        let f1: [u8; 0];
        let f2: [u8; 1];
        let f3: [(); 0];
        let f4: [(); 10];

        assert_eq!(f1.len(), 0);
        assert_eq!(f2.len(), 1);
        assert_eq!(f3.len(), 0);
        assert_eq!(f4.len(), 10);
    }

    #[test]
    fn test_array_hash() {
        use hash::hash_of;

        let a = [1, 2, 3];
        let b = [1, 2, 3];
        let c = [1, 2, 4];

        assert_eq!(a.hash_of(), b.hash_of());
        assert_ne!(a.hash_of(), c.hash_of());
        assert_ne!(b.hash_of(), c.hash_of());
    }

    #[test]
    fn test_f64_ops() {
        assert!(!0.0f64.is_sign_negative());
        assert!((-0.0f64).is_sign_negative());
        assert!(!(1f64).is_sign_negative());
        assert!((-1f64).is_sign_negative());

        assert!(f64::nan().is_nan());
        assert!(!0.0f64.is_nan());
        assert!(!1.0f64.is_nan());
        assert!(!(-1.0f64).is_nan());
        assert!(!f64::infinity().is_nan());
        assert!(!f64::neg_infinity().is_nan());

        assert!(!f64::nan().is_infinite());
        assert!(!0.0f64.is_infinite());
        assert!(!1.0f64.is_infinite());
        assert!(!(-1.0f64).is_infinite());
        assert!(f64::infinity().is_infinite());
        assert!(f64::neg_infinity().is_infinite());

        assert!(!f64::nan().is_finite());
        assert!(0.0f64.is_finite());
        assert!(1.0f64.is_finite());
        assert!((-1.0f64).is_finite());
        assert!(!f64::infinity().is_finite());
        assert!(!f64::neg_infinity().is_finite());
    }

    #[test]
    fn test_f32_ops() {
        assert!(!0.0f32.is_sign_negative());
        assert!((-0.0f32).is_sign_negative());
        assert!(!(1f32).is_sign_negative());
        assert!((-1f32).is_sign_negative());

        assert!(f32::nan().is_nan());
        assert!(!0.0f32.is_nan());
        assert!(!1.0f32.is_nan());
        assert!(!(-1.0f32).is_nan());
        assert!(!f32::infinity().is_nan());
        assert!(!f32::neg_infinity().is_nan());

        assert!(!f32::nan().is_infinite());
        assert!(!0.0f32.is_infinite());
        assert!(!1.0f32.is_infinite());
        assert!(!(-1.0f32).is_infinite());
        assert!(f32::infinity().is_infinite());
        assert!(f32::neg_infinity().is_infinite());

        assert!(!f32::nan().is_finite());
        assert!(0.0f32.is_finite());
        assert!(1.0f32.is_finite());
        assert!((-1.0f32).is_finite());
        assert!(!f32::infinity().is_finite());
        assert!(!f32::neg_infinity().is_finite());
    }

    #[test]
    fn test_array_size_constexpr() {
        use typing::matches;

        const SIZE = 5usize;

        let a: [u8; 0];
        let b: [u8; 1 - 1];
        let c: [u8; 1 + SIZE * 2];
        let d: [u8; 11];

        assert!(matches::<typeof(a), typeof(b)>());
        assert!(matches::<typeof(c), typeof(d)>());
        assert!(!matches::<typeof(a), typeof(c)>());
    }

    #[test]
    fn test_wrapping_add() {
        assert_eq!(u8::max_value().wrapping_add(1), 0);
        assert_eq!(u16::max_value().wrapping_add(1), 0);
        assert_eq!(u32::max_value().wrapping_add(1), 0);
        assert_eq!(u64::max_value().wrapping_add(1), 0);
        assert_eq!(u128::max_value().wrapping_add(1), 0);
        assert_eq!(usize::max_value().wrapping_add(1), 0);

        assert_eq!(i8::max_value().wrapping_add(1), i8::min_value());
        assert_eq!(i16::max_value().wrapping_add(1), i16::min_value());
        assert_eq!(i32::max_value().wrapping_add(1), i32::min_value());
        assert_eq!(i64::max_value().wrapping_add(1), i64::min_value());
        assert_eq!(i128::max_value().wrapping_add(1), i128::min_value());
        assert_eq!(isize::max_value().wrapping_add(1), isize::min_value());

    }

    #[test]
    fn test_wrapping_sub() {
        assert_eq!(u8::min_value().wrapping_sub(1), u8::max_value());
        assert_eq!(u16::min_value().wrapping_sub(1), u16::max_value());
        assert_eq!(u32::min_value().wrapping_sub(1), u32::max_value());
        assert_eq!(u64::min_value().wrapping_sub(1), u64::max_value());
        assert_eq!(u128::min_value().wrapping_sub(1), u128::max_value());
        assert_eq!(usize::min_value().wrapping_sub(1), usize::max_value());

        assert_eq!(i8::min_value().wrapping_sub(1), i8::max_value());
        assert_eq!(i16::min_value().wrapping_sub(1), i16::max_value());
        assert_eq!(i32::min_value().wrapping_sub(1), i32::max_value());
        assert_eq!(i64::min_value().wrapping_sub(1), i64::max_value());
        assert_eq!(i128::min_value().wrapping_sub(1), i128::max_value());
        assert_eq!(isize::min_value().wrapping_sub(1), isize::max_value());
    }

    #[test]
    fn test_wrapping_mul() {
        assert_eq!(u8::max_value().wrapping_mul(2), u8::max_value() - 1);
        assert_eq!(u16::max_value().wrapping_mul(2), u16::max_value() - 1);
        assert_eq!(u32::max_value().wrapping_mul(2), u32::max_value() - 1);
        assert_eq!(u64::max_value().wrapping_mul(2), u64::max_value() - 1);
        assert_eq!(u128::max_value().wrapping_mul(2), u128::max_value() - 1);
        assert_eq!(usize::max_value().wrapping_mul(2), usize::max_value() - 1);

        assert_eq!(i8::max_value().wrapping_mul(2), -2);
        assert_eq!(i16::max_value().wrapping_mul(2), -2);
        assert_eq!(i32::max_value().wrapping_mul(2), -2);
        assert_eq!(i64::max_value().wrapping_mul(2), -2);
        assert_eq!(i128::max_value().wrapping_mul(2), -2);
        assert_eq!(isize::max_value().wrapping_mul(2), -2);
    }

    #[test]
    fn test_wrapping_div() {
        assert_eq!(i8::min_value().wrapping_div(-1), i8::min_value());
        assert_eq!(i16::min_value().wrapping_div(-1), i16::min_value());
        assert_eq!(i32::min_value().wrapping_div(-1), i32::min_value());
        assert_eq!(i64::min_value().wrapping_div(-1), i64::min_value());
        assert_eq!(i128::min_value().wrapping_div(-1), i128::min_value());
        assert_eq!(isize::min_value().wrapping_div(-1), isize::min_value());
    }

    #[test]
    fn test_checked_add() {
        assert_eq!(u8::max_value().checked_add(1), Option::none());
        assert_eq!(0u8.checked_add(1), Option::some(1u8));

        assert_eq!(u16::max_value().checked_add(1), Option::none());
        assert_eq!(0u16.checked_add(1), Option::some(1u16));

        assert_eq!(u32::max_value().checked_add(1), Option::none());
        assert_eq!(0u32.checked_add(1), Option::some(1u32));

        assert_eq!(u64::max_value().checked_add(1), Option::none());
        assert_eq!(0u64.checked_add(1), Option::some(1u64));

        assert_eq!(u128::max_value().checked_add(1), Option::none());
        assert_eq!(0u128.checked_add(1), Option::some(1u128));

        assert_eq!(usize::max_value().checked_add(1), Option::none());
        assert_eq!(0usize.checked_add(1), Option::some(1usize));

        assert_eq!(i8::max_value().checked_add(1), Option::none());
        assert_eq!(0i8.checked_add(1), Option::some(1i8));

        assert_eq!(i16::max_value().checked_add(1), Option::none());
        assert_eq!(0i16.checked_add(1), Option::some(1i16));

        assert_eq!(i32::max_value().checked_add(1), Option::none());
        assert_eq!(0i32.checked_add(1), Option::some(1i32));

        assert_eq!(i64::max_value().checked_add(1), Option::none());
        assert_eq!(0i64.checked_add(1), Option::some(1i64));

        assert_eq!(i128::max_value().checked_add(1), Option::none());
        assert_eq!(0i128.checked_add(1), Option::some(1i128));

        assert_eq!(isize::max_value().checked_add(1), Option::none());
        assert_eq!(0isize.checked_add(1), Option::some(1isize));
    }

    #[test]
    fn test_checked_sub() {
        assert_eq!(u8::min_value().checked_sub(1), Option::none());
        assert_eq!(1u8.checked_sub(1), Option::some(0u8));

        assert_eq!(u16::min_value().checked_sub(1), Option::none());
        assert_eq!(1u16.checked_sub(1), Option::some(0u16));

        assert_eq!(u32::min_value().checked_sub(1), Option::none());
        assert_eq!(1u32.checked_sub(1), Option::some(0u32));

        assert_eq!(u64::min_value().checked_sub(1), Option::none());
        assert_eq!(1u64.checked_sub(1), Option::some(0u64));

        #[cfg(not(target_arch = "aarch64"))]
        {
            assert_eq!(u128::min_value().checked_sub(1), Option::none());
            assert_eq!(1u128.checked_sub(1), Option::some(0u128));
        }

        #[cfg(target_arch = "aarch64")]
        compile_note!("checked_sub is broken for 128-bit integers on aarch64");

        assert_eq!(usize::min_value().checked_sub(1), Option::none());
        assert_eq!(1usize.checked_sub(1), Option::some(0usize));

        assert_eq!(i8::min_value().checked_sub(1), Option::none());
        assert_eq!(1i8.checked_sub(1), Option::some(0i8));

        assert_eq!(i16::min_value().checked_sub(1), Option::none());
        assert_eq!(1i16.checked_sub(1), Option::some(0i16));

        assert_eq!(i32::min_value().checked_sub(1), Option::none());
        assert_eq!(1i32.checked_sub(1), Option::some(0i32));

        assert_eq!(i64::min_value().checked_sub(1), Option::none());
        assert_eq!(1i64.checked_sub(1), Option::some(0i64));

        #[cfg(not(target_arch = "aarch64"))]
        {
            assert_eq!(i128::min_value().checked_sub(1), Option::none());
            assert_eq!(1i128.checked_sub(1), Option::some(0i128));
        }

        #[cfg(target_arch = "aarch64")]
        compile_note!("checked_sub is broken for 128-bit integers on aarch64");

        assert_eq!(isize::min_value().checked_sub(1), Option::none());
        assert_eq!(1isize.checked_sub(1), Option::some(0isize));
    }

    #[test]
    fn test_checked_mul() {
        assert_eq!(u8::max_value().checked_mul(2), Option::none());
        assert_eq!(1u8.checked_mul(2), Option::some(2u8));

        assert_eq!(u16::max_value().checked_mul(2), Option::none());
        assert_eq!(1u16.checked_mul(2), Option::some(2u16));

        assert_eq!(u32::max_value().checked_mul(2), Option::none());
        assert_eq!(1u32.checked_mul(2), Option::some(2u32));

        assert_eq!(u64::max_value().checked_mul(2), Option::none());
        assert_eq!(1u64.checked_mul(2), Option::some(2u64));

        assert_eq!(u128::max_value().checked_mul(2), Option::none());
        assert_eq!(1u128.checked_mul(2), Option::some(2u128));

        assert_eq!(usize::max_value().checked_mul(2), Option::none());
        assert_eq!(1usize.checked_mul(2), Option::some(2usize));

        assert_eq!(i8::max_value().checked_mul(2), Option::none());
        assert_eq!(1i8.checked_mul(2), Option::some(2i8));

        assert_eq!(i16::max_value().checked_mul(2), Option::none());
        assert_eq!(1i16.checked_mul(2), Option::some(2i16));

        assert_eq!(i32::max_value().checked_mul(2), Option::none());
        assert_eq!(1i32.checked_mul(2), Option::some(2i32));

        assert_eq!(i64::max_value().checked_mul(2), Option::none());
        assert_eq!(1i64.checked_mul(2), Option::some(2i64));

        assert_eq!(i128::max_value().checked_mul(2), Option::none());
        assert_eq!(1i128.checked_mul(2), Option::some(2i128));

        assert_eq!(isize::max_value().checked_mul(2), Option::none());
        assert_eq!(1isize.checked_mul(2), Option::some(2isize));
    }

    #[test]
    fn test_checked_div_unsigned() {
        assert_eq!(1u8.checked_div(0), Option::none());
        assert_eq!(1u8.checked_div(1), Option::some(1u8));

        assert_eq!(1u16.checked_div(0), Option::none());
        assert_eq!(1u16.checked_div(1), Option::some(1u16));

        assert_eq!(1u32.checked_div(0), Option::none());
        assert_eq!(1u32.checked_div(1), Option::some(1u32));

        assert_eq!(1u64.checked_div(0), Option::none());
        assert_eq!(1u64.checked_div(1), Option::some(1u64));

        assert_eq!(1u128.checked_div(0), Option::none());
        assert_eq!(1u128.checked_div(1), Option::some(1u128));

        assert_eq!(1usize.checked_div(0), Option::none());
        assert_eq!(1usize.checked_div(1), Option::some(1usize));
    }

    #[test]
    fn test_checked_div_signed() {
        assert_eq!(1i8.checked_div(0), Option::none());
        assert_eq!(1i8.checked_div(1), Option::some(1i8));
        assert_eq!(i8::min_value().checked_div(-1), Option::none());

        assert_eq!(1i16.checked_div(0), Option::none());
        assert_eq!(1i16.checked_div(1), Option::some(1i16));
        assert_eq!(i16::min_value().checked_div(-1), Option::none());

        assert_eq!(1i32.checked_div(0), Option::none());
        assert_eq!(1i32.checked_div(1), Option::some(1i32));
        assert_eq!(i32::min_value().checked_div(-1), Option::none());

        assert_eq!(1i64.checked_div(0), Option::none());
        assert_eq!(1i64.checked_div(1), Option::some(1i64));
        assert_eq!(i64::min_value().checked_div(-1), Option::none());

        assert_eq!(1i128.checked_div(0), Option::none());
        assert_eq!(1i128.checked_div(1), Option::some(1i128));
        assert_eq!(i128::min_value().checked_div(-1), Option::none());

        assert_eq!(1isize.checked_div(0), Option::none());
        assert_eq!(1isize.checked_div(1), Option::some(1isize));
        assert_eq!(isize::min_value().checked_div(-1), Option::none());

        assert_eq!(1i8.checked_div(-1), Option::some(-1i8));
        assert_eq!(1i16.checked_div(-1), Option::some(-1i16));
        assert_eq!(1i32.checked_div(-1), Option::some(-1i32));
    }
}
