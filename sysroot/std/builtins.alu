//! Builtin types and their method implementations.
//!
//! This module holds impl blocks for builtin types all items with `#[lang(builtin_X)]` are
//! treated as X when lowering into IR, so they cannot actually exist as proper structs.
//!
//! Builtin protocols also cannot be directly implemented by user code, even though
//! they contain no associated functions. They are handled specially
//! by the compiler.

use cmp::{Equatable, Comparable, Ordering, lexicographic_cmp};
use hash::{Hashable, Hasher};
use fmt::{Formatter};

/// Unit type (`()`)
///
/// Unit type (also called void type) is the return type of expressions that do not return
/// a value.
#[lang(builtin_void)]
struct void {}
impl void {
    #[force_inline]
    fn equals(lhs: &void, rhs: &void) -> bool {
        true
    }

    #[force_inline]
    fn compare(lhs: &void, rhs: &void) -> Ordering {
        Ordering::Equal
    }

    #[force_inline]
    fn hash<H: Hasher<H>>(self: &void, hasher: &mut H) {
    }

    mixin Equatable<void>;
    mixin Comparable<void>;
}

/// Boolean type
#[lang(builtin_bool)]
struct bool {}
impl bool {
    #[force_inline]
    fn equals(lhs: &bool, rhs: &bool) -> bool {
        *lhs == *rhs
    }

    #[force_inline]
    fn compare(lhs: &bool, rhs: &bool) -> Ordering {
        if *lhs == *rhs {
            Ordering::Equal
        } else if *rhs {
            Ordering::Less
        } else {
            Ordering::Greater
        }
    }

    fn hash<H: Hasher<H>>(self: &bool, hasher: &mut H) {
        hasher.write(mem::slice::from_raw(self as &u8, 1));
    }

    fn fmt<F: Formatter<F>>(self: &bool, formatter: &mut F) -> Result<(), fmt::Error> {
        formatter.write_str(if *self { "true" } else { "false" })
    }

    mixin Equatable<bool>;
    mixin Comparable<u8>;
}

/// Never type (`!`)
///
/// Never type is the type of expressions that never return. For example,
/// ```
///`let a = loop {};  /// `a` is of type `!`
/// ```
///
/// It has a couple of interesting properties, notably it is a bottom type,
/// which means that values of never type can be coerced into any other type.
#[lang(builtin_never)]
struct never {}
impl never {
    /// @ cmp::Equatable::equals
    fn equals(lhs: &!, rhs: &!) -> bool {
        std::intrinsics::unreachable()
    }

    /// @ cmp::Comparable::compare
    fn compare(lhs: &!, rhs: &!) -> Ordering {
        std::intrinsics::unreachable()
    }

    /// @ hash::Hashable::hash
    fn hash<H: Hasher<H>>(self: &!, hasher: &mut H) {
        std::intrinsics::unreachable()
    }

    /// @ fmt::Formattable::fmt
    fn fmt<F: Formatter<F>>(self: &!, formatter: &mut F) -> Result<(), fmt::Error> {
        std::intrinsics::unreachable()
    }

    mixin Equatable<bool>;
    mixin Comparable<u8>;
}

/// This mixin implements Equatable and Comparable for types that have natively implemented
/// equality and comparison operators.
protocol BuiltinComparable<Self: builtins::Numeric> {
    #[force_inline] fn equals(lhs: &Self, rhs: &Self) -> bool { *lhs == *rhs }
    #[force_inline] fn not_equals(lhs: &Self, rhs: &Self) -> bool { *lhs != *rhs }
    #[force_inline]
    fn compare(lhs: &Self, rhs: &Self) -> Ordering {
        if *lhs < *rhs {
            Ordering::Less
        } else if *lhs == *rhs {
            Ordering::Equal
        } else {
            Ordering::Greater
        }
    }

    #[force_inline] fn less_than(lhs: &Self, rhs: &Self) -> bool { *lhs < *rhs }
    #[force_inline] fn less_than_or_equal(lhs: &Self, rhs: &Self) -> bool { *lhs <= *rhs }
    #[force_inline] fn greater_than(lhs: &Self, rhs: &Self) -> bool { *lhs > *rhs }
    #[force_inline] fn greater_than_or_equal(lhs: &Self, rhs: &Self) -> bool { *lhs >= *rhs }
}

protocol IntegerParsable<Self: builtins::Integer> {
    #[inline]
    fn parse(s: &[u8]) -> Option<Self> {
        string::parse_integer::<Self>(s, 10)
    }

    #[inline]
    fn parse_with_radix(s: &[u8], radix: u16) -> Option<Self> {
        string::parse_integer::<Self>(s, radix)
    }
}

protocol IntegerFormattable<Self: builtins::Integer, F: Formatter<F>> {
    #[inline]
    fn fmt(self: &Self, formatter: &mut F) -> Result<(), fmt::Error> {
        fmt::internal::format_integer(*self, 10, 0, formatter)
    }
}

protocol FloatFormattable<Self: builtins::FloatingPoint, F: Formatter<F>> {
    #[inline]
    fn fmt(self: &Self, formatter: &mut F) -> Result<(), fmt::Error> {
        fmt::internal::format_float(*self, formatter, 15)
    }
}

protocol BitOps<Self: builtins::Unsigned> {
    #[inline]
    fn to_be(self: Self) -> Self {
        #[cfg(prince_of_denmark = "hamlet")]
        {
            intrinsics::compile_note("...or not to be, that is the question.");
        }
        #[cfg(target_endian = "big")]
        {
            self
        }
        #[cfg(target_endian = "little")]
        {
            self.swap_bytes()
        }
    }

    #[inline]
    fn from_be(self: Self) -> Self {
        self.to_be()
    }

    #[inline]
    fn to_le(self: Self) -> Self {
        #[cfg(target_endian = "big")]
        {
            self.swap_bytes()
        }
        #[cfg(target_endian = "little")]
        {
            self
        }
    }

    #[inline]
    fn from_le(self: Self) -> Self {
        self.to_le()
    }

    #[inline]
    fn rotate_left(self: Self, shift: usize) -> Self {
        (self << shift) | (self >> ((8 * mem::size_of::<Self>()) - shift))
    }

    #[inline]
    fn rotate_right(self: Self, shift: usize) -> Self {
        (self >> shift) | (self << ((8 * mem::size_of::<Self>()) - shift))
    }
}

/// 8-bit unsigned integer (byte)
#[lang(builtin_u8)]
struct u8 {}
impl u8 {
    mixin BitOps<u8>;
    mixin BuiltinComparable<u8>;
    mixin<H: Hasher<H>> Hashable<u8, H>;
    mixin<F: Formatter<F>> IntegerFormattable<u8, F>;
    mixin IntegerParsable<u8>;

    #[force_inline]
    fn max_value() -> u8 {
        0xffu8
    }

    #[force_inline]
    fn min_value() -> u8 {
        0u8
    }

    #[inline]
    fn swap_bytes(self: u8) -> u8 {
        self
    }
}

/// 16-bit unsigned integer
#[lang(builtin_u16)]
struct u16 {}
impl u16 {
    mixin BitOps<u16>;
    mixin BuiltinComparable<u16>;
    mixin<H: Hasher<H>> Hashable<u16, H>;
    mixin<F: Formatter<F>> IntegerFormattable<u16, F>;
    mixin IntegerParsable<u16>;

    #[force_inline]
    fn max_value() -> u16 {
        0xffffu16
    }

    #[force_inline]
    fn min_value() -> u16 {
        0u16
    }

    #[inline]
    fn swap_bytes(self: u16) -> u16 {
        (self >> 8) | (self << 8)
    }
}

/// 32-bit unsigned integer
#[lang(builtin_u32)]
struct u32 {}
impl u32 {
    mixin BitOps<u32>;
    mixin BuiltinComparable<u32>;
    mixin<H: Hasher<H>> Hashable<u32, H>;
    mixin<F: Formatter<F>> IntegerFormattable<u32, F>;
    mixin IntegerParsable<u32>;

    #[force_inline]
    fn max_value() -> u32 {
        0xffffffffu32
    }

    #[force_inline]
    fn min_value() -> u32 {
        0u32
    }

    #[inline]
    fn swap_bytes(self: u32) -> u32 {
        (self >> 24)
        | ((self >> 8) & 0x0000FF00u32)
        | ((self << 8) & 0x00FF0000u32)
        | (self << 24)
    }
}

/// 64-bit unsigned integer
#[lang(builtin_u64)]
struct u64 {}
impl u64 {
    mixin BitOps<u64>;
    mixin BuiltinComparable<u64>;
    mixin<H: Hasher<H>> Hashable<u64, H>;
    mixin<F: Formatter<F>> IntegerFormattable<u64, F>;
    mixin IntegerParsable<u64>;

    #[force_inline]
    fn max_value() -> u64 {
        0xffffffffffffffffu64
    }

    #[force_inline]
    fn min_value() -> u64 {
        0u64
    }

    #[inline]
    fn swap_bytes(self: u64) -> u64 {
        (self >> 56)
        | ((self >> 40) & 0x000000000000FF00u64)
        | ((self >> 24) & 0x0000000000FF0000u64)
        | ((self >> 8)  & 0x00000000FF000000u64)
        | ((self << 8)  & 0x000000FF00000000u64)
        | ((self << 24) & 0x0000FF0000000000u64)
        | ((self << 40) & 0x00FF000000000000u64)
        | (self << 56)
    }
}

/// 128-bit unsigned integer
#[lang(builtin_u128)]
struct u128 {}
impl u128 {
    mixin BitOps<u128>;
    mixin BuiltinComparable<u128>;
    mixin<H: Hasher<H>> Hashable<u128, H>;
    mixin<F: Formatter<F>> IntegerFormattable<u128, F>;
    mixin IntegerParsable<u128>;

    #[force_inline]
    fn max_value() -> u128 {
        0xffffffffffffffffffffffffffffffffu128
    }

    #[force_inline]
    fn min_value() -> u128 {
        0u128
    }

    #[inline]
    fn swap_bytes(self: u128) -> u128 {
        (self >> 120)
        | ((self >> 104) & 0x0000000000000000000000000000FF00u128)
        | ((self >> 88) & 0x00000000000000000000000000FF0000u128)
        | ((self >> 72) & 0x000000000000000000000000FF000000u128)
        | ((self >> 56) & 0x0000000000000000000000FF00000000u128)
        | ((self >> 40) & 0x00000000000000000000FF0000000000u128)
        | ((self >> 24) & 0x000000000000000000FF000000000000u128)
        | ((self >> 8)  & 0x0000000000000000FF00000000000000u128)
        | ((self << 8)  & 0x00000000000000FF0000000000000000u128)
        | ((self << 24) & 0x000000000000FF000000000000000000u128)
        | ((self << 40) & 0x0000000000FF00000000000000000000u128)
        | ((self << 56) & 0x00000000FF0000000000000000000000u128)
        | ((self << 72) & 0x000000FF000000000000000000000000u128)
        | ((self << 88) & 0x0000FF00000000000000000000000000u128)
        | ((self << 104) & 0x00FF0000000000000000000000000000u128)
        | (self << 120)
    }
}

/// Native unsigned integer (machine word)
///
/// On 64-bit systems, `usize` is the same as `u64`. On 32-bit systems, `usize` is the same
/// as `u32`.
#[lang(builtin_usize)]
struct usize {}
impl usize {
    mixin BitOps<usize>;
    mixin BuiltinComparable<usize>;
    mixin<H: Hasher<H>> Hashable<usize, H>;
    mixin<F: Formatter<F>> IntegerFormattable<usize, F>;
    mixin IntegerParsable<usize>;

    #[force_inline]
    fn max_value() -> usize {
        #[cfg(target_pointer_width = "32")]
        {
            u32::max_value() as usize
        }
        #[cfg(target_pointer_width = "64")]
        {
            u64::max_value() as usize
        }
    }

    #[force_inline]
    fn min_value() -> usize {
        #[cfg(target_pointer_width = "32")]
        {
            u32::min_value() as usize
        }
        #[cfg(target_pointer_width = "64")]
        {
            u64::min_value() as usize
        }
    }


    #[inline]
    fn swap_bytes(self: usize) -> usize {
        #[cfg(target_pointer_width = "32")]
        {
            (self as u32).swap_bytes() as usize
        }
        #[cfg(target_pointer_width = "64")]
        {
            (self as u64).swap_bytes() as usize
        }
    }
}

/// Signed 8-bit integer
#[lang(builtin_i8)]
struct i8 {}
impl i8 {
    mixin BuiltinComparable<i8>;
    mixin<H: Hasher<H>> Hashable<i8, H>;
    mixin<F: Formatter<F>> IntegerFormattable<i8, F>;
    mixin IntegerParsable<i8>;

    #[force_inline]
    fn max_value() -> i8 {
        0x7fu8 as i8
    }

    #[force_inline]
    fn min_value() -> i8 {
        0x80u8 as i8
    }
}

/// Signed 16-bit integer
#[lang(builtin_i16)]
struct i16 {}
impl i16 {
    mixin BuiltinComparable<i16>;
    mixin<H: Hasher<H>> Hashable<i16, H>;
    mixin<F: Formatter<F>> IntegerFormattable<i16, F>;
    mixin IntegerParsable<i16>;

    #[force_inline]
    fn max_value() -> i16 {
        0x7fffu16 as i16
    }

    #[force_inline]
    fn min_value() -> i16 {
        0x8000u16 as i16
    }
}

/// Signed 32-bit integer
#[lang(builtin_i32)]
struct i32 {}
impl i32 {
    mixin BuiltinComparable<i32>;
    mixin<H: Hasher<H>> Hashable<i32, H>;
    mixin<F: Formatter<F>> IntegerFormattable<i32, F>;
    mixin IntegerParsable<i32>;

    #[force_inline]
    fn max_value() -> i32 {
        0x7fffffffu32 as i32
    }

    #[force_inline]
    fn min_value() -> i32 {
        0x80000000u32 as i32
    }
}

/// Signed 64-bit integer
#[lang(builtin_i64)]
struct i64 {}
impl i64 {
    mixin BuiltinComparable<i64>;
    mixin<H: Hasher<H>> Hashable<i64, H>;
    mixin<F: Formatter<F>> IntegerFormattable<i64, F>;
    mixin IntegerParsable<i64>;

    #[force_inline]
    fn max_value() -> i64 {
        0x7fffffffffffffffu64 as i64
    }

    #[force_inline]
    fn min_value() -> i64 {
        0x8000000000000000u64 as i64
    }
}

/// Signed 128-bit integer
#[lang(builtin_i128)]
struct i128 {}
impl i128 {
    mixin BuiltinComparable<i128>;
    mixin<H: Hasher<H>> Hashable<i128, H>;
    mixin<F: Formatter<F>> IntegerFormattable<i128, F>;
    mixin IntegerParsable<i128>;

    #[force_inline]
    fn max_value() -> i128 {
        0x7fffffffffffffffffffffffffffffffu128 as i128
    }

    #[force_inline]
    fn min_value() -> i128 {
        0x80000000000000000000000000000000u128 as i128
    }
}

/// Native signed integer (machine word)
#[lang(builtin_isize)]
struct isize {}
impl isize {
    mixin BuiltinComparable<isize>;
    mixin<H: Hasher<H>> Hashable<isize, H>;
    mixin<F: Formatter<F>> IntegerFormattable<isize, F>;
    mixin IntegerParsable<isize>;

    #[force_inline]
    fn max_value() -> isize {
        #[cfg(target_pointer_width = "32")]
        {
            i32::max_value() as isize
        }
        #[cfg(target_pointer_width = "64")]
        {
            i64::max_value() as isize
        }
    }

    #[force_inline]
    fn min_value() -> isize {
        #[cfg(target_pointer_width = "32")]
        {
            i32::min_value() as isize
        }
        #[cfg(target_pointer_width = "64")]
        {
            i64::min_value() as isize
        }
    }
}

protocol FloatOps<Self> {
    #[inline]
    fn nan() -> Self {
        (0.0 as Self) / (0.0 as Self)
    }

    #[inline]
    fn infinity() -> Self {
        (1.0 as Self) / (0.0 as Self)
    }

    #[inline]
    fn neg_infinity() -> Self {
        (-1.0 as Self) / (0.0 as Self)
    }

    #[inline]
    fn is_nan(self: Self) -> bool {
        self != self
    }

    #[inline]
    fn is_infinite(self: Self) -> bool {
        !self.is_nan() && !self.is_finite()
    }

    #[inline]
    fn is_finite(self: Self) -> bool {
        !self.is_nan() && self < Self::infinity() && self > Self::neg_infinity()
    }
}

/// Single precision floating point type
#[lang(builtin_f32)]
struct f32 {}
impl f32 {
    mixin BuiltinComparable<f32>;
    // Not hashable
    mixin<F: Formatter<F>> FloatFormattable<f32, F>;
    mixin FloatOps<f32>;

    #[force_inline]
    fn is_sign_negative(self: f32) -> bool {
        let as_bits: u64 = util::transmute(self);
        as_bits & 0x80000000u64 != 0
    }

    #[force_inline]
    fn max_value() -> f32 {
        3.40282347e+38f32
    }

    #[force_inline]
    fn min_value() -> f32 {
        -3.40282347e+38f32
    }

    #[force_inline]
    fn min_positive() -> f32 {
        1.17549435e-38f32
    }

    #[force_inline]
    fn epsilon() -> f32 {
        1.19209290e-07f32
    }

    #[force_inline]
    fn acos(self: f32) -> f32 {
        libc::acosf(self)
    }

    #[force_inline]
    fn asin(self: f32) -> f32 {
        libc::asinf(self)
    }

    #[force_inline]
    fn atan(self: f32) -> f32 {
        libc::atanf(self)
    }

    #[force_inline]
    fn atan2(self: f32, other: f32) -> f32 {
        libc::atan2f(self, other)
    }

    #[force_inline]
    fn atanh(self: f32) -> f32 {
        libc::atanhf(self)
    }

    #[force_inline]
    fn cbrt(self: f32) -> f32 {
        libc::cbrtf(self)
    }

    #[force_inline]
    fn ceil(self: f32) -> f32 {
        libc::ceilf(self)
    }

    #[force_inline]
    fn cos(self: f32) -> f32 {
        libc::cosf(self)
    }

    #[force_inline]
    fn cosh(self: f32) -> f32 {
        libc::coshf(self)
    }

    #[force_inline]
    fn erf(self: f32) -> f32 {
        libc::erff(self)
    }

    #[force_inline]
    fn erfc(self: f32) -> f32 {
        libc::erfcf(self)
    }

    #[force_inline]
    fn exp(self: f32) -> f32 {
        libc::expf(self)
    }


    #[force_inline]
    fn floor(self: f32) -> f32 {
        libc::floorf(self)
    }

    #[force_inline]
    fn frexp(self: f32) -> (f32, i32) {
        let out: i32;
        let val = libc::frexpf(self, &out);
        (val, out)
    }

    #[force_inline]
    fn ldexp(self: f32, exp: i32) -> f32 {
        libc::ldexpf(self, exp)
    }

    #[force_inline]
    fn log(self: f32) -> f32 {
        libc::logf(self)
    }

    #[force_inline]
    fn log2(self: f32) -> f32 {
        libc::log2f(self)
    }

    #[force_inline]
    fn log10(self: f32) -> f32 {
        libc::log10f(self)
    }

    #[force_inline]
    fn modf(self: f32) -> (f32, f32) {
        let out: f32;
        let val = libc::modff(self, &out);
        (out, val)
    }

    #[force_inline]
    fn pow(self: f32, other: f32) -> f32 {
        libc::powf(self, other)
    }

    #[force_inline]
    fn round(self: f32) -> f32 {
        libc::roundf(self)
    }

    #[force_inline]
    fn sin(self: f32) -> f32 {
        libc::sinf(self)
    }

    #[force_inline]
    fn sinh(self: f32) -> f32 {
        libc::sinhf(self)
    }

    #[force_inline]
    fn sqrt(self: f32) -> f32 {
        libc::sqrtf(self)
    }

    #[force_inline]
    fn tan(self: f32) -> f32 {
        libc::tanf(self)
    }

    #[force_inline]
    fn tanh(self: f32) -> f32 {
        libc::tanhf(self)
    }

    #[force_inline]
    fn trunc(self: f32) -> f32 {
        libc::truncf(self)
    }
}

/// Double precision floating point type
#[lang(builtin_f64)]
struct f64 {}
impl f64 {
    mixin BuiltinComparable<f64>;
    // Not hashable
    mixin<F: Formatter<F>> FloatFormattable<f64, F>;
    mixin FloatOps<f64>;

    #[force_inline]
    fn is_sign_negative(self: f64) -> bool {
        let as_bits: u64 = util::transmute(self);
        as_bits & 0x8000000000000000u64 != 0
    }

    #[force_inline]
    fn max_value() -> f64 {
        1.7976931348623157e+308f64
    }

    #[force_inline]
    fn min_value() -> f64 {
        -1.7976931348623157e+308f64
    }

    #[force_inline]
    fn min_positive() -> f64 {
        2.2250738585072014e-308f64
    }

    #[force_inline]
    fn epsilon() -> f64 {
        2.2204460492503131e-16f64
    }

    #[force_inline]
    fn acos(self: f64) -> f64 {
        libc::acos(self)
    }

    #[force_inline]
    fn asin(self: f64) -> f64 {
        libc::asin(self)
    }

    #[force_inline]
    fn atan(self: f64) -> f64 {
        libc::atan(self)
    }

    #[force_inline]
    fn atan2(self: f64, other: f64) -> f64 {
        libc::atan2(self, other)
    }

    #[force_inline]
    fn atanh(self: f64) -> f64 {
        libc::atanh(self)
    }

    #[force_inline]
    fn cbrt(self: f64) -> f64 {
        libc::cbrt(self)
    }

    #[force_inline]
    fn ceil(self: f64) -> f64 {
        libc::ceil(self)
    }

    #[force_inline]
    fn cos(self: f64) -> f64 {
        libc::cos(self)
    }

    #[force_inline]
    fn cosh(self: f64) -> f64 {
        libc::cosh(self)
    }

    #[force_inline]
    fn erf(self: f64) -> f64 {
        libc::erf(self)
    }

    #[force_inline]
    fn erfc(self: f64) -> f64 {
        libc::erfc(self)
    }

    #[force_inline]
    fn exp(self: f64) -> f64 {
        libc::exp(self)
    }

    #[force_inline]
    fn floor(self: f64) -> f64 {
        libc::floor(self)
    }

    #[force_inline]
    fn frexp(self: f64) -> (f64, i32) {
        let out: i32;
        let val = libc::frexp(self, &out);
        (val, out)
    }

    #[force_inline]
    fn ldexp(self: f64, exp: i32) -> f64 {
        libc::ldexp(self, exp)
    }

    #[force_inline]
    fn log(self: f64) -> f64 {
        libc::log(self)
    }

    #[force_inline]
    fn log2(self: f64) -> f64 {
        libc::log2(self)
    }

    #[force_inline]
    fn log10(self: f64) -> f64 {
        libc::log10(self)
    }

    #[force_inline]
    fn modf(self: f64) -> (f64, f64) {
        let out: f64;
        let val = libc::modf(self, &out);
        (out, val)
    }

    #[force_inline]
    fn pow(self: f64, other: f64) -> f64 {
        libc::pow(self, other)
    }

    #[force_inline]
    fn round(self: f64) -> f64 {
        libc::round(self)
    }

    #[force_inline]
    fn sin(self: f64) -> f64 {
        libc::sin(self)
    }

    #[force_inline]
    fn sinh(self: f64) -> f64 {
        libc::sinh(self)
    }

    #[force_inline]
    fn sqrt(self: f64) -> f64 {
        libc::sqrt(self)
    }

    #[force_inline]
    fn tan(self: f64) -> f64 {
        libc::tan(self)
    }

    #[force_inline]
    fn tanh(self: f64) -> f64 {
        libc::tanh(self)
    }

    #[force_inline]
    fn trunc(self: f64) -> f64 {
        libc::trunc(self)
    }
}

/// Fixed size arrays
#[lang(builtin_array)]
struct array {}
impl array<Arr: builtins::Array> {
    #[force_inline]
    fn as_slice(self: &Arr) -> &[element_of<Arr>] {
        self
    }

    #[force_inline]
    fn as_slice_mut(self: &mut Arr) -> &mut [element_of<Arr>] {
        self
    }

    #[inline]
    fn iter(self: &Arr) -> mem::SliceIterator<&element_of<Arr>> {
        self.as_slice().iter()
    }
}

// The following are "type-operators", pseudo-types, implemented inside the compiler
// that resolve to other types based on the type of the generic parameters. Ideally,
// these would be implemented in the standard library, but the infer system is not
// yet sufficiently powerful for this.

/// Signed integer type of the same size as the original type.
#[lang(typeop_signed_of)]
struct signed_of<T: builtins::Integer> {}

/// Element type of the provided array
#[lang(typeop_element_of)]
struct element_of<T: builtins::Array> {}

/// Unsigned integer type of the same size as the original type.
#[lang(typeop_unsigned_of)]
struct unsigned_of<T: builtins::Integer> {}

/// Type of the pointed-to value
#[lang(typeop_deref_of)]
struct deref_of<T: builtins::Pointer> {}

/// Type of the first element of the provided tuple
#[lang(typeop_tuple_head_of)]
struct tuple_head_of<T: builtins::Tuple> {}

/// Tuple type equivalent to the provided one without the first element
#[lang(typeop_tuple_tail_of)]
struct tuple_tail_of<T: builtins::Tuple> {}

/// Return type of the provided function
#[lang(typeop_return_type_of)]
struct return_type_of<T> {}

/// Tuple of argument types of the provided function
#[lang(typeop_arguments_of)]
struct arguments_of<T> {}

/// Void pointer type of the same constness as the provided pointer type.
#[lang(typeop_void_ptr_of)]
struct void_ptr_of<T: Pointer> {}


/// Matches any type
#[lang(proto_any)] protocol Any {}

/// Matches zero-sized types (void, named function types, empty structs, empty arrays, ...)
#[lang(proto_zero_sized)] protocol ZeroSized {}

/// Matches all primitive types
#[lang(proto_primitive)] protocol Primitive {}

/// Integer and floating point types
#[lang(proto_numeric)] protocol Numeric {}

/// Integer types
#[lang(proto_integer)] protocol Integer {}

/// Floating point types
#[lang(proto_floating_point)] protocol FloatingPoint {}

/// Signed integer types (`i8`, `i16`, `i32`, ...)
#[lang(proto_signed)] protocol Signed {}

/// Unsigned integer types (`u8`, `u16`, `u32`, ...)
#[lang(proto_unsigned)] protocol Unsigned {}

/// All pointers
#[lang(proto_pointer)] protocol Pointer {}

/// All (fixed-size) arrays
#[lang(proto_array)] protocol Array {}

/// All tuples
#[lang(proto_tuple)] protocol Tuple {}

/// All named functions (including lambdas, but excluding closures)
#[lang(proto_named_function)] protocol NamedFunction {}

/// Function pointers
#[lang(proto_function_pointer)] protocol FunctionPointer {}

/// All callable objects (named functions, closures, and function pointers)
///
/// `Args` is a tuple of the argument types of the function and `Ret` is the return type,
/// for example `fn foo(a: i32, b: i64) -> usize` would match `Callable<(i32, i64), usize>`.
#[lang(proto_callable)] protocol Callable<Args: Tuple, Ret> {}

// These are mostly useful as type inference guides

/// Arrays with element type `T`
#[lang(proto_array_of)] protocol ArrayOf<T> {}

/// Pointers to `T` (regardless of mutability)
#[lang(proto_pointer_of)] protocol PointerOf<T> {}


#[cfg(all(test, test_std))]
mod tests {
    #[test]
    fn unsigned_num_limits() {
        assert_eq!(u8::max_value() + 1, u8::min_value());
        assert_eq!(u16::max_value() + 1, u16::min_value());
        assert_eq!(u32::max_value() + 1, u32::min_value());
        assert_eq!(u64::max_value() + 1, u64::min_value());
        assert_eq!(usize::max_value() + 1, usize::min_value());
        assert_eq!(u128::max_value() + 1, u128::min_value());
    }

    #[test]
    fn signed_num_limits() {
        // Signed overflow is UB, so we round-trip via unsigned equivalent
        assert_eq!((i8::max_value() as u8 + 1) as i8, i8::min_value());
        assert_eq!((i16::max_value() as u16 + 1) as i16, i16::min_value());
        assert_eq!((i32::max_value() as u32 + 1) as i32, i32::min_value());
        assert_eq!((i64::max_value() as u64 + 1) as i64, i64::min_value());
        assert_eq!((isize::max_value() as usize + 1) as isize, isize::min_value());
        assert_eq!((i128::max_value() as u128 + 1) as i128, i128::min_value());
    }

    #[test]
    fn test_signed_of() {
        use rtti::type_id;

        assert_eq!(type_id::<signed_of<u8>>(), type_id::<i8>());
        assert_eq!(type_id::<signed_of<u16>>(), type_id::<i16>());
        assert_eq!(type_id::<signed_of<u32>>(), type_id::<i32>());
        assert_eq!(type_id::<signed_of<u64>>(), type_id::<i64>());
        assert_eq!(type_id::<signed_of<usize>>(), type_id::<isize>());
        assert_eq!(type_id::<signed_of<u128>>(), type_id::<i128>());

        assert_eq!(type_id::<signed_of<i8>>(), type_id::<i8>());
        assert_eq!(type_id::<signed_of<i16>>(), type_id::<i16>());
        assert_eq!(type_id::<signed_of<i32>>(), type_id::<i32>());
        assert_eq!(type_id::<signed_of<i64>>(), type_id::<i64>());
        assert_eq!(type_id::<signed_of<isize>>(), type_id::<isize>());
        assert_eq!(type_id::<signed_of<i128>>(), type_id::<i128>());
    }

    #[test]
    fn test_unsigned_of() {
        use rtti::type_id;

        assert_eq!(type_id::<unsigned_of<u8>>(), type_id::<u8>());
        assert_eq!(type_id::<unsigned_of<u16>>(), type_id::<u16>());
        assert_eq!(type_id::<unsigned_of<u32>>(), type_id::<u32>());
        assert_eq!(type_id::<unsigned_of<u64>>(), type_id::<u64>());
        assert_eq!(type_id::<unsigned_of<usize>>(), type_id::<usize>());
        assert_eq!(type_id::<unsigned_of<u128>>(), type_id::<u128>());

        assert_eq!(type_id::<unsigned_of<i8>>(), type_id::<u8>());
        assert_eq!(type_id::<unsigned_of<i16>>(), type_id::<u16>());
        assert_eq!(type_id::<unsigned_of<i32>>(), type_id::<u32>());
        assert_eq!(type_id::<unsigned_of<i64>>(), type_id::<u64>());
        assert_eq!(type_id::<unsigned_of<isize>>(), type_id::<usize>());
        assert_eq!(type_id::<unsigned_of<i128>>(), type_id::<u128>());
    }

    #[test]
    fn test_swap_bytes() {
        assert_eq!(0x01u8.swap_bytes(), 0x01u8);
        assert_eq!(0x0123u16.swap_bytes(), 0x2301u16);
        assert_eq!(0x01234567u32.swap_bytes(), 0x67452301u32);
        assert_eq!(0x0123456789abcdefu64.swap_bytes(), 0xefcdab8967452301u64);
        assert_eq!(
            0x000102030405060708090a0b0c0d0e0fu128.swap_bytes(),
            0x0f0e0d0c0b0a09080706050403020100u128
        );

        use u16::to_be;

        // Totally not an excuse to work in some Shakespeare...
        #[cfg(target_endian = "little")]
        assert_eq!(0x100u16
            .to_be() | ~ to_be
        (0x1u16), 0xfeffu16);

        #[cfg(target_endian = "big")]
        assert_eq!(0x100u16
            .to_be() | ~ to_be
        (0x1u16), 0xfffeu16);
    }

    #[test]
    fn test_deref_of() {
        use rtti::type_id;

        assert_eq!(type_id::<deref_of<&u8>>(), type_id::<u8>());
        assert_eq!(type_id::<deref_of<&mut u8>>(), type_id::<u8>());

        assert_eq!(type_id::<deref_of<deref_of<&&u8>>>(), type_id::<u8>());
        assert_eq!(type_id::<deref_of<deref_of<&&mut u8>>>(), type_id::<u8>());
        assert_eq!(type_id::<deref_of<deref_of<&mut &mut u8>>>(), type_id::<u8>());
        assert_eq!(type_id::<deref_of<deref_of<&mut &u8>>>(), type_id::<u8>());
    }
}
