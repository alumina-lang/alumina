//! Panic support macros and functions

/// Ungracefully terminate the process with an error message.
///
/// Use this macro to bail on conditions that the program cannot reasonably be expected to
/// recover from (e.g. when a condition means a certain programming bug).
///
/// Since panics cannot be recovered from, prefer to use [structured error handling](std::result::Result) as 
/// a general purpose failure handling mechanism.
///
/// When compiled in debug mode, `panic` prints the provided message along with the stack trace (on platforms
/// that support it)
///
/// # Example
/// ```
/// let value = 42;
/// switch value % 2 {
///     0 => println!("even"),    
///     1 => println!("odd"),    
///     _ => panic!("{} is somehow neither odd nor even", value),    
/// }
/// ```
/// 
/// Expressions that panic have a [never type](std::builtins::never).
macro panic($reason, $args...) {
    internal::panic_impl(
        concat!($reason), 
        file!(), 
        line!(), 
        column!(),
        &[internal::FormatArg::new(&$args)...]
    )
}

struct PanicInfo {
    file: &[u8], 
    line: i32, 
    column: i32,
    message: &[u8],
}

mod internal {
    use fmt::{Formatter, internal::{printf, FormatArg}};
    use sync::{Atomic, Ordering};

    // libc runtime backtrace support
    #[cfg(all(debug, not(no_backtrace), not(target_os = "android")))]
    {
        extern "C" fn backtrace(buffer: &mut &mut void, size: libc::c_int) -> libc::c_int;
        extern "C" fn backtrace_symbols(buffer: &mut &void, size: libc::c_int) -> &mut &mut libc::c_char;
        extern "C" fn backtrace_symbols_fd(buffer: &mut &void, size: libc::c_int, fd: libc::c_int);
    }

    /// Small formatter with as few dependencies as possible.
    ///
    /// PanicFormatter has no buffering, no checking for unwritten bytes. It just writes
    /// directly to fd 2. This is both for reliability, to allow higher-level IO
    /// code to panic safely but also to break potential circular dependencies in static
    /// initialization.
    struct PanicFormatter {}
    impl PanicFormatter {
        fn write_str(self: &mut PanicFormatter, buf: &[u8]) -> Result<(), fmt::Error> {
            if libc::write(libc::STDERR_FILENO, buf.ptr as &void, buf.len) < 0 {
                Result::err(fmt::Error::new())
            } else {
                Result::ok(())
            }
        }
        mixin Formatter<PanicFormatter>;
    }
    
    #[thread_local] static PANICKING: bool;
    #[thread_local] static THREAD_PANIC_INFO: Atomic<&mut PanicInfo>;

    fn print_panic_message( 
        fmt_str: &[u8], 
        file: &[u8], 
        line: i32, 
        column: i32, 
        args: &[FormatArg<PanicFormatter>]
    ) -> Result<(), fmt::Error> {
        let formatter = PanicFormatter {};
        
        printf(
            "panic at {}:{}:{}: ", 
            &[FormatArg::new(&file), FormatArg::new(&line), FormatArg::new(&column)], 
            &formatter
        )?;
        printf(fmt_str, args, &formatter)?;
        formatter.write_char('\n')?;

        Result::ok(())
    }

    #[cold]
    #[no_inline]
    fn panic_impl(
        fmt_str: &[u8], 
        file: &[u8], 
        line: i32, 
        column: i32, 
        args: &[FormatArg<PanicFormatter>]
    ) -> ! {
        #[cfg(panic_trap)]
        std::intrinsics::trap();

        #[cfg(panic_abort)]
        libc::abort();

        #[cfg(all(not(panic_trap), not(panic_abort)))] {
            if mem::replace(&PANICKING, true) {
                // If we panic during a panic handler, nuclear abort.
                std::intrinsics::trap();
            }

            #[cfg(threading)] {
                let panic_info = THREAD_PANIC_INFO.exchange(null, Ordering::SeqCst);
                if panic_info != null {
                    // If we are in a "managed" thread, we don't abort the process, but rather we just
                    // populate the panic info that was put there by the thread constructor. This allows
                    // the panic to be handled when the thread is joined.
                    panic_info.file = file;
                    panic_info.line = line;
                    panic_info.column = column;
                    libc::pthread_exit(panic_info as &mut void);
                }
            }
    
            // Swallow errors from print_panic_message, because at this point, what can we do, panic?
            // We still bail early if it fails.
            let _ = print_panic_message(fmt_str, file, line, column, args);
            #[cfg(all(debug, not(no_backtrace), not(target_os = "android")))]
            {
                let buf: [&mut void; 128];
                let size = backtrace(&buf[0], 128);
                backtrace_symbols_fd(&buf[0] as &mut &void, size, libc::STDERR_FILENO);
            }
            
            libc::abort();
        }
    }
}
