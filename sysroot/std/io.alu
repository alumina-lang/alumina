//! Streams and other byte I/O functionality

#[cfg(any(target_os="linux", target_os="macos", target_os="android"))]
{
    use unix::{
        Error, FileDescriptor, Pipe, StdioStream
    }
}

use fmt::{write, writeln};

/// Buffer for formatted standard I/O.
///
/// We use a single small thread local buffer for convenience stdio formatting macros.
/// This buffer has limited a purpose (if you need a larger buffer, use [io::StdioStream]
/// directly). As many formatters write individual characters, doing a syscall for every
/// one would be a performance killer.
#[thread_local] static FMT_BUF: [u8; 256];

/// Prints a formatted string to standard output.
///
/// # Example
/// ```
/// print!("Hello, world");
/// ```
macro print($fmt_str, $arg...) {
    let fmt = BufferedWriter::from_slice(&StdioStream::stdout(), &FMT_BUF);
    write!(&fmt, $fmt_str, $arg...).unwrap();
    fmt.flush().unwrap();
}

/// Prints a formatted string to standard output with newline.
///
/// # Example
/// ```
/// println!("Hello, world");
/// ```
macro println($fmt_str, $arg...) {
    let fmt = BufferedWriter::from_slice(&StdioStream::stdout(), &FMT_BUF);
    writeln!(&fmt, $fmt_str, $arg...).unwrap();
    fmt.flush().unwrap();
}

/// Prints a formatted string to standard error.
///
/// # Example
/// ```
/// eprint!("Something went wrong :(");
/// ```
macro eprint($fmt_str, $arg...) {
    let fmt = BufferedWriter::from_slice(&StdioStream::stderr(), &FMT_BUF);
    write!(&fmt, $fmt_str, $arg...).unwrap();
    fmt.flush().unwrap();
}

/// Prints a formatted string to standard error with newline.
///
/// # Example
/// ```
/// eprintln!("Something went wrong :(");
/// ```
macro eprintln($fmt_str, $arg...) {
    let fmt = BufferedWriter::from_slice(&StdioStream::stderr(), &FMT_BUF);
    writeln!(&fmt, $fmt_str, $arg...).unwrap();
    fmt.flush().unwrap();
}

/// Types that are wrappers over a file descriptor.
protocol AsFileDescriptor<Self> {
    fn as_fd(self: &Self) -> FileDescriptor;
}


/// Types that implement readable stream semantics.
protocol Readable<Self> {
    use string::StringBuf;
    use internal::default_read_exact;

    /// Reads from the stream into a provided buffer.
    ///
    /// If successful, returns the number of bytes read. This may be less than the size
    /// of the provided buffer.
    fn read(self: &mut Self, buf: &mut [u8]) -> Result<usize, Error>;

    /// Fills the provided buffer by reading from the stream.
    ///
    /// If stream had less bytes available than the size of the buffer, this method
    /// will return an `Error::eof()`.
    fn read_exact(self: &mut Self, buf: &mut [u8]) -> Result<(), Error> {
        self.default_read_exact(buf)
    }

    /// Reads the entire stream into a `StringBuf`.
    ///
    /// If successful, returns the number of bytes that were read.
    fn read_to_end(self: &mut Self, buf: &mut StringBuf) -> Result<usize, Error> {;
        let start_len = buf.len();
        let start_cap = buf.capacity();

        loop {
            if buf.capacity() == buf.len() {
                buf.reserve(32);
            }
            let read = self.read(buf.spare_capacity())?;
            if read == 0 {
                return Result::ok(buf.len() - start_len);
            } else {
                buf._length = buf.len() + read;
            }

            // Optimization for the case where the initial vector had exactly
            // enough capacity - avoid doubling the vector if the next read will
            // return EOF by using a small stack buffer instead.
            if buf.capacity() == buf.len() && buf.capacity() == start_cap {
                let probe: [u8; 32];
                let read = self.read(probe.as_slice_mut())?;
                if read == 0 {
                    return Result::ok(buf.len() - start_len);
                } else {
                    buf.extend_from_slice(probe.as_slice()[..read])
                }
            }
        }
    }
}

/// Types that implement writable stream semantics.
protocol Writable<Self> {
    /// Write the buffer to the stream.
    ///
    /// Returns the number of bytes written. This may be less than the size of the buffer.
    /// See also [write_all], which can be used to write the entire buffer.
    fn write(self: &mut Self, buf: &[u8]) -> Result<usize, Error>;

    /// Writes all the bytes in the buffer to the stream.
    ///
    /// If EOF is reached, returns `Error::eof()`.
    fn write_all(self: &mut Self, buf: &[u8]) -> Result<(), Error> {

        while buf.len > 0 {
            let written_bytes = self.write(buf)?;
            if written_bytes == 0 {
                return Result::err(Error::eof());
            }
            buf = buf[written_bytes..];
        }

        Result::ok(())
    }

    /// Flush the stream
    ///
    /// This may be a no-op, depending on the stream.
    fn flush(self: &mut Self) -> Result<(), Error>;
}

/// Reference point for the seek operation.
enum SeekFrom {
    Beginning,
    Current,
    End
}

/// Streams that can be fast-forwarded or rewound to an arbitrary offset.
protocol Seekable<Self> {
    /// Jump to a specified position in the stream.
    ///
    /// Returns the new position in the stream from the beginning.
    fn seek(self: &mut Self, whence: SeekFrom, offset: i64) -> Result<u64, Error>;

    /// Rewind the stream to the beginning.
    fn rewind(self: &mut Self) -> Result<(), Error> {
        self.seek(SeekFrom::Beginning, 0)?;

        Result::ok(())
    }

    /// Returns the current position in the stream from the beginning.
    fn position(self: &mut Self) -> Result<u64, Error> {
        self.seek(SeekFrom::Current, 0)
    }
}

/// A readable stream backed by an in-memory string slice.
struct SliceReader {
    slice: &[u8],
    pos: usize
}

impl SliceReader {
    fn new(slice: &[u8]) -> SliceReader {
        SliceReader {
            slice: slice,
            pos: 0
        }
    }

    /// @ Readable::read
    fn read(self: &mut SliceReader, buf: &mut [u8]) -> Result<usize, Error> {
        let len = cmp::min(buf.len, self.slice.len - self.pos);

        if len > 0 {
            self.slice[self.pos..self.pos + len].copy_to_nonoverlapping(&buf[0]);
            self.pos += len;
        }

        Result::ok(len)
    }

    /// @ BufferedReadable::fill_buffer
    fn fill_buffer(self: &mut SliceReader) -> Result<&[u8], Error> {
        Result::ok(self.slice[self.pos..] as &[u8])
    }

    /// @ BufferedReadable::consume
    fn consume(self: &mut SliceReader, amount: usize) {
        self.pos = cmp::min(self.pos + amount, self.slice.len);
    }

    /// @ Seekable::seek
    fn seek(self: &mut SliceReader, whence: SeekFrom, offset: i64) -> Result<u64, Error> {
        let new_offset = switch whence {
            SeekFrom::Beginning => offset,
            SeekFrom::Current => self.pos as i64 + offset,
            SeekFrom::End => self.slice.len as i64 + offset,
            _ => unreachable!()
        };

        if new_offset < 0 || (new_offset as usize) > self.slice.len {
            Result::err(Error::eof())
        } else {
            self.pos = new_offset as usize;
            Result::ok(new_offset as u64)
        }
    }

    /// @ Seekable::position
    fn position(self: &mut SliceReader) -> Result<u64, ()> {
        Result::ok(self.pos as u64)
    }

    mixin Seekable<SliceReader>;
    mixin Readable<SliceReader>;
    mixin BufferedReadable<SliceReader>;
}

/// A writable stream backed by [std::string::StringBuf].
struct StringWriter {
    string: &mut string::StringBuf,
}

impl StringWriter {
    fn new(string: &mut string::StringBuf) -> StringWriter {
        StringWriter {
            string: string
        }
    }

    /// @ Writable::write
    fn write(self: &mut StringWriter, buf: &[u8]) -> Result<usize, Error> {
        self.string.extend_from_slice(buf);
        Result::ok(buf.len)
    }

    /// @ Writable::flush
    fn flush(self: &mut StringWriter) -> Result<(), Error> {
        Result::ok(())
    }

    mixin Writable<StringWriter>;
}

/// Streams that have an internal buffer.
///
/// Streams implementing this protocol enables them to be used by method such as [read_until],
/// which is aware of the internal buffer.
protocol BufferedReadable<Self: Readable<Self>> {
    /// Return the current contents of the buffer, reading additional
    /// data from the stream if necessary.
    ///
    /// Does not move the internal buffer position.
    fn fill_buffer(self: &mut Self) -> Result<&[u8], Error>;

    /// Mark `amount` bytes as consumed.
    fn consume(self: &mut Self, amount: usize)
}

/// A buffered wrapper over an underlying stream.
struct BufferedReader<R: Readable<R>> {
    inner: &mut R,
    buf: &mut [u8],
    pos: usize,
    cap: usize,
}

impl BufferedReader<R: Readable<R>> {
    use std::mem::slice;
    use internal::default_read_exact;

    /// Create a BufferedReader with a heap-allocated buffer of the given size.
    fn new(inner: &mut R, buf_size: usize) -> BufferedReader<R> {
        from_slice(inner, slice::alloc::<u8>(buf_size))
    }

    /// Creates a BufferedReader from an existing-buffer, potentially
    /// avoiding a heap allocation.
    fn from_slice(inner: &mut R, buf: &mut [u8]) -> BufferedReader<R> {
        BufferedReader {
            inner: inner,
            buf: buf,
            pos: 0,
            cap: 0,
        }
    }

    /// @ BufferedReadable::fill_buffer
    fn fill_buffer(self: &mut BufferedReader<R>) -> Result<&[u8], Error> {
        if self.pos == self.cap {
            self.cap = self.inner.read(self.buf)?;
            self.pos = 0;
        }

        Result::ok(self.buf[self.pos..self.cap] as &[u8])
    }

    /// @ BufferedReadable::consume
    fn consume(self: &mut BufferedReader<R>, amount: usize) {
        self.pos = cmp::min(self.pos + amount, self.cap);
    }

    /// @ Readable::read
    fn read(self: &mut BufferedReader<R>, buf: &mut [u8]) -> Result<usize, Error> {
        let slice = self.fill_buffer()?;

        let nread = cmp::min(buf.len, slice.len);
        if nread > 0 {
            slice[..nread].copy_nonoverlapping(&buf[0]);
            self.consume(nread);
        }

        Result::ok(nread)
    }

    /// @ Readable::read_exact
    fn read_exact(self: &mut BufferedReader<R>, buf: &mut [u8]) -> Result<(), Error> {
        if self.cap - self.pos >= buf.len {
            if buf.len > 0 {
                self.buf[self.pos..self.pos + buf.len].copy_nonoverlapping(&buf[0]);
                self.consume(buf.len);
            }
            return Result::ok(());
        }

        self.default_read_exact(buf)
    }

    /// @ std::mem::Freeable::free
    fn free(self: &mut BufferedReader<R>) {
        self.buf.free();
    }

    /// @ std::mem::Movable::move
    fn move(self: &mut BufferedReader<R>) -> BufferedReader<R> {
        let ret = *self;
        self.buf = mem::slice::empty();
        ret
    }

    mixin Readable<BufferedReader<R>>;
}

impl BufferedReader<R: Seekable<R>> {
    /// @ Seekable::seek
    fn seek(self: &mut BufferedReader<R>, whence: SeekFrom, offset: i64) -> Result<u64, Error> {
        let res = if whence == SeekFrom::Current {
            let remainder = (self.cap - self.pos) as i64;
            let res = self.inner.seek(SeekFrom::Current, offset - remainder)?;
            res
        } else {
            self.inner.seek(whence, offset)?
        };

        self.cap = 0;
        self.pos = 0;

        Result::ok(res)
    }

    mixin Seekable<BufferedReader<R>>;
}

/// A buffered wrapper over an underlying writable stream.
struct BufferedWriter<W: Writable<W>> {
    buf: &mut [u8],
    pos: usize,
    inner: &mut W
}

impl BufferedWriter<W: Writable<W>> {
    use mem::slice;

    /// Create a BufferedWriter with a heap-allocated buffer of the given size.
    fn new(inner: &mut W, buf_size: usize) -> BufferedWriter<W> {
        from_slice(inner, slice::alloc::<u8>(buf_size))
    }

    /// Creates a BufferedWriter from an existing-buffer, potentially
    /// avoiding a heap allocation.
    fn from_slice(inner: &mut W, buf: &mut [u8]) -> BufferedWriter<W> {
        BufferedWriter {
            inner: inner,
            buf: buf,
            pos: 0
        }
    }

    #[cold]
    #[inline(never)]
    fn write_full(self: &mut BufferedWriter<W>, buf: &[u8]) -> result::Result<usize, Error> {
        if buf.len > self.buf.len - self.pos {
            self._flush_buffer()?;
        }

        if buf.len >= self.buf.len  {
            // Bypass the buffer if we need to write more than buffer size
            self.inner.write(buf)
        } else {
            self._write_to_buffer(buf);
            Result::ok(buf.len)
        }
    }

    /// @ Writable::write
    #[inline]
    fn write(self: &mut BufferedWriter<W>, buf: &[u8]) -> result::Result<usize, Error> {
        if buf.len < self.buf.len - self.pos {
            self._write_to_buffer(buf);
            Result::ok(buf.len)
        } else {
            self.write_full(buf)
        }
    }

    /// @ Writable::write_all
    #[inline]
    fn write_all(self: &mut BufferedWriter<W>, buf: &[u8]) -> result::Result<(), Error> {
        if buf.len < self.buf.len - self.pos {
            self._write_to_buffer(buf);
            Result::ok(())
        } else {
            self._write_all_full(buf)
        }
    }

    /// @ Writable::flush
    fn flush(self: &mut BufferedWriter<W>) -> result::Result<(), Error> {
        self._flush_buffer()?;
        self.inner.flush()
    }

    #[inline]
    fn _write_to_buffer(self: &mut BufferedWriter<W>, buf: &[u8]) {
        if buf.len > 0 {
            // This guard is technically redundant, but to avoid the debug assertion
            // when indexing past the end of the buffer with 0-length writes.
            buf.copy_to_nonoverlapping(&self.buf[self.pos]);
            self.pos += buf.len;
        }
    }

    fn _flush_buffer(self: &mut BufferedWriter<W>) -> result::Result<(), Error> {
        // This will return an EOF error, if we are not able to write everything.
        // since we have accepted bytes that are not written to the underlying
        // writer and not signalled an EOF.
        self.inner.write_all(self.buf[..self.pos])?;
        self.pos = 0;

        Result::ok(())
    }

    #[cold]
    #[inline(never)]
    fn _write_all_full(self: &mut BufferedWriter<W>, buf: &[u8]) -> result::Result<(), Error> {
        if buf.len > self.buf.len - self.pos {
            self._flush_buffer()?;
        }

        if buf.len >= self.buf.len {
            // Bypass the buffer if we need to write more than buffer size
            self.inner.write_all(buf)
        } else {
            self._write_to_buffer(buf);
            Result::ok(())
        }
    }

    /// @ std::mem::Freeable::free
    fn free(self: &mut BufferedWriter<W>) {
        self.buf.free()
    }

    /// @ std::mem::Movable::move
    fn move(self: &mut BufferedWriter<W>) -> BufferedWriter<W> {
        let ret = *self;
        self.buf = slice::empty();
        ret
    }
}

// BufferedWriter implements Formatter, so it can be used as a sink in write!(...)
impl BufferedWriter<W: Writable<W>> {
    /// @ std::fmt::Formatter::write_str
    #[inline]
    fn write_str(self: &mut BufferedWriter<W>, buf: &[u8]) -> Result<(), fmt::Error> {
        self.write_all(buf).map_err(fmt::Error::from::<Error>)
    }

    mixin fmt::Formatter<BufferedWriter<W>>;
}


const DEFAULT_BUFFER_SIZE: usize = 8192;

// Extension methods

/// Copy the entire stream `src` into `dst`
///
/// Internally allocates a buffer with the size of [DEFAULT_BUFFER_SIZE].
fn copy<S: Readable<S>, D: Writable<D>>(src: &mut S, dst: &mut D) -> result::Result<u64, Error> {
    let buf = mem::slice::alloc::<u8>(DEFAULT_BUFFER_SIZE);
    defer buf.free();

    copy_using(src, dst, buf)
}

/// Copy the entire stream `src` into `dst` using a provided buffer.
fn copy_using<S: Readable<S>, D: Writable<D>>(src: &mut S, dst: &mut D, buffer: &mut [u8]) -> result::Result<u64, Error> {
    let read = 0u64;
    loop {
        let n = src.read(buffer)?;
        read += n as u64;
        if n == 0 {
            break;
        }
        dst.write_all(buffer[0..n])?;
    }

    Result::ok(read)
}

/// Reads a single byte from the stream.
///
/// Returns `Error::eof` if the stream has no bytes left.
fn read_byte<R: Readable<R>>(reader: &mut R) -> result::Result<u8, Error> {
    let buf: [u8; 1];
    reader.read_exact(&buf)?;

    Result::ok(buf[0])
}

/// Reads the stream into `buf` until a specific byte is encountered.
///
/// The `delim` terminator is included.
fn read_until<R: BufferedReadable<R>>(r: &mut R, delim: u8, buf: &mut string::StringBuf) -> result::Result<usize, Error> {
    use string::find_char;

    let read = 0usize;
    loop {
        let available = r.fill_buffer()?;
        let ret = available.find_char(delim);

        let (done, used) = if ret.is_some {
            buf.extend_from_slice(available[..ret.inner + 1]);
            (true, ret.inner + 1)
        } else {
            buf.extend_from_slice(available);
            (false, available.len)
        };

        r.consume(used);
        read += used;
        if done || used == 0 {
            return Result::ok(read);
        }
    }
}

/// Iterator that reads the inner stream line by line.
///
/// An iterator over the lines of a buffered reader. The iterator maintains an internal
/// heap-allocated buffer of the line's contents, which is reused between lines.
struct LineIterator<R: BufferedReadable<R>> {
    line_buf: string::StringBuf,
    reader: &mut R,
}

impl LineIterator<R: BufferedReadable<R>> {
    use std::iter::Iterator;

    /// Create a line iterator with a pre-allocated buffer.
    fn with_line_buffer(reader: &mut R, line_buf: string::StringBuf) -> LineIterator<R> {
        LineIterator {
            reader: reader,
            line_buf: line_buf
        }
    }

    /// Create a line iterator with a default buffer.
    fn new(reader: &mut R) -> LineIterator<R> {
        with_capacity(reader, 0)
    }

    /// Create a line iterator with a given capacity
    fn with_capacity(reader: &mut R, capacity: usize) -> LineIterator<R> {
        with_line_buffer(reader, collections::Vector::with_capacity(capacity))
    }

    /// @ std::iter::Iterator::next
    fn next(self: &mut LineIterator<R>) -> Option<Result<&[u8], Error>> {
        self.line_buf.clear();

        let res = self.reader.read_until('\n', &self.line_buf);
        if !res.is_ok {
            return Option::some(Result::err(res.unwrap_err()));
        }

        if res.unwrap() == 0 {
            return Option::none();
        }

        if self.line_buf.iter().next_back() == Option::some('\n') {
            self.line_buf.pop();
            if self.line_buf.iter().next_back() == Option::some('\r') {
                self.line_buf.pop();
            }
        }

        Option::some(Result::ok(self.line_buf.as_slice()))
    }

    /// @ std::mem::Freeable::free
    fn free(self: &mut LineIterator<R>) {
        self.line_buf.free();
    }

    /// @ std::mem::Movable::move
    fn move(self: &mut LineIterator<R>) -> LineIterator<R> {
        LineIterator::<R> {
            reader: self.reader,
            line_buf: self.line_buf.move()
        }
    }

    mixin iter::Iterator<LineIterator<R>, Result<&[u8], Error>>;
    mixin iter::IteratorExt<LineIterator<R>, Result<&[u8], Error>>;
}

fn lines<R: BufferedReadable<R>>(reader: &mut R) -> LineIterator<R> {
    LineIterator::new(reader)
}

mod internal {
    fn default_read_exact<T: Readable<T>>(self: &mut T, buf: &mut [u8]) -> Result<(), Error> {
        while buf.len > 0 {
            let read_bytes = self.read(buf)?;
            if read_bytes == 0 {
                return Result::err(Error::eof());
            }
            buf = buf[read_bytes..];
        }

        Result::ok(())
    }
}


#[cfg(all(test, test_std))]
mod tests {
    static BUF: [u8; 1024];
    use string::StringBuf;

    macro read_n($reader, $n) {
        let read = $reader.read(BUF.as_slice_mut()[..$n]).unwrap();
        BUF.as_slice()[..read]
    }

    #[test]
    fn test_slice_reader() {
        let text = SliceReader::new("Lorem ipsum dolor sit amet");
        assert_eq!(read_n!(text, 12), "Lorem ipsum ");
        assert_eq!(read_n!(text, 14), "dolor sit amet");
        assert_eq!(read_n!(text, 100), "");

        let buf = BUF.as_slice_mut();
        let text = SliceReader::new("Lorem ipsum dolor sit amet");
        assert_eq!(text.read_exact(buf[..100]), Result::err(Error::eof()));

        let text = SliceReader::new("Lorem ipsum dolor sit amet");
        assert_eq!(text.read_exact(buf[..26]), Result::ok(()));

        let text = SliceReader::new("Lorem ipsum dolor sit amet");
        let read : StringBuf = StringBuf::new();
        defer read.free();

        text.read_to_end(&read).unwrap();
        assert_eq!(read.as_slice(), "Lorem ipsum dolor sit amet");
    }

    #[test]
    fn test_slice_reader_seek() {
        let text = SliceReader::new("Lorem ipsum dolor sit amet");
        assert_eq!(read_n!(text, 12), "Lorem ipsum ");

        assert_eq!(text.seek(SeekFrom::Beginning, 1).unwrap(), 1);
        assert_eq!(read_n!(text, 12), "orem ipsum d");

        assert_eq!(text.seek(SeekFrom::Current, -5).unwrap(), 8);
        assert_eq!(read_n!(text, 12), "sum dolor si");

        assert_eq!(text.seek(SeekFrom::End, -12).unwrap(), 14);
        assert_eq!(read_n!(text, 12), "lor sit amet");
    }


    #[test]
    fn test_lines() {
        let text = SliceReader::new("Lorem\nipsum\ndolor\nsit\namet");
        let iter = lines(&text);
        defer iter.free();

        assert_eq!(iter.next(), Option::some(Result::ok("Lorem")));
        assert_eq!(iter.next(), Option::some(Result::ok("ipsum")));
        assert_eq!(iter.next(), Option::some(Result::ok("dolor")));
        assert_eq!(iter.next(), Option::some(Result::ok("sit")));
        assert_eq!(iter.next(), Option::some(Result::ok("amet")));
        assert_eq!(iter.next(), Option::none());
    }


    #[test]
    fn test_read_byte() {
        let text = SliceReader::new("foo");

        assert_eq!(text.read_byte(), Result::ok('f'));
        assert_eq!(text.read_byte(), Result::ok('o'));
        assert_eq!(text.read_byte(), Result::ok('o'));
        assert_eq!(text.read_byte(), Result::err(Error::eof()));
    }

    #[test]
    fn test_copy() {
        let src = SliceReader::new("Lorem ipsum dolor sit amet");
        let dst: StringBuf = StringBuf::new();

        copy(&src, &StringWriter::new(&dst)).unwrap();
        assert_eq!(dst.as_slice(), "Lorem ipsum dolor sit amet");
    }
}
