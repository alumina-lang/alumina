//! Ranges and iterators.
//!
//! Iterators provide an abstraction for types that can be used to access their elements
//! one-by-one, for example in `for` loop. The most common examples are ranges and collections.
//!
//! ```
//! for i in 0..10 {
//!     println!("{}", i);
//! }
//!
//! for i in &["a", "b", "c"] {
//!     println!("{}", i);
//! }
//! ```
//!
//! There is distinction between an [iterable type](Iterable) and an [iterator](Iterator). Iterators are
//! consumable objects that can only be used to iterate once. Iterable types are ones that can
//! produce an iterator when needed.
//!
//! Iterators can also be combined to create more complex types of iterators. See [IteratorExt] protocol
//! for a reference of methods that can be used to combine iterators.

use builtins::Integer;
use option::Option;
use builtins::Callable;

/// Iterators.
///
/// Types that implement `Iterator` can be used in a for-loop. Types that implement `Iterator` should
/// also mix in the [IteratorExt] protocol so that the combinator methods can be used.
#[lang(proto_iterator)]
protocol Iterator<Self, T> {
    /// Returns the next item, if any.
    ///
    /// If the iterator has reached the end, it returns none.
    fn next(self: &mut Self) -> Option<T>;

    /// Returns the number of remaining elements, if available.
    ///
    /// This is used for efficiently pre-allocating storage in collections
    /// that are created from iterators to avoid copies.
    ///
    /// It the number of remaining elements is unknown, the method should
    /// return `Option::none()`.
    fn size_hint(self: &Self) -> Option<usize> {
        Option::none()
    }
}

/// Iterators that can be consumed from both ends.
protocol DoubleEndedIterator<Self: Iterator<Self, T>, T> {
    /// Returns the next item from the back, if any.
    ///
    /// If the iterator has reached the beginning, it returns none.
    fn next_back(self: &mut Self) -> Option<T>;
}

/// Extension mixin for [DoubleEndedIterator] types.
protocol DoubleEndedIteratorExt<Self: DoubleEndedIterator<Self, T>, T> {
    /// "Reverse" the iterator.
    ///
    /// `rev` returns a wrapper over an iterator that has `next` and `next_back` methods
    /// reversed.
    fn rev(self: &mut Self) -> RevIterator<Self, T> {
        RevIterator { it: self }
    }
}

protocol Iterable<Self, It: Iterator<It, T>, T> {
    fn iter(self: &Self) -> It;
}

protocol IterableRef<Self, It: Iterator<It, &T>, T> {
    fn iter_ref(self: &Self) -> It;
}

protocol IterableMut<Self, It: Iterator<It, &mut T>, T> {
    fn iter_mut(self: &mut Self) -> It;
}

/// Reverse iterator.
///
/// See [DoubleEndedIteratorExt::rev].
struct RevIterator<It: DoubleEndedIterator<It, T>, T> {
    it: &mut It
}

impl RevIterator<It: DoubleEndedIterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut RevIterator<It, T>) -> Option<T> {
        self.it.next_back()
    }

    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut RevIterator<It, T>) -> Option<T> {
        self.it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &RevIterator<It, T>) -> Option<usize> {
        self.it.size_hint()
    }

    mixin Iterator<RevIterator<It, T>, T>;
    mixin IteratorExt<RevIterator<It, T>, T>;
    mixin DoubleEndedIterator<RevIterator<It, T>, T>;
    mixin DoubleEndedIteratorExt<RevIterator<It, T>, T>;
}

/// Map iterator.
///
/// See [IteratorExt::map].
struct MapIterator<It: Iterator<It, T>, F: Callable<(T), U>, T, U> {
    it: &mut It,
    fun: F,
}

impl MapIterator<It: Iterator<It, T>, F: Callable<(T), U>, T, U> {
    /// @ Iterator::next
    fn next(self: &mut MapIterator<It, F, T, U>) -> Option<U> {
        self.it.next().map(self.fun)
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &MapIterator<It, F, T, U>) -> Option<usize> {
        self.it.size_hint()
    }

    mixin Iterator<MapIterator<It, F, T, U>, U>;
    mixin IteratorExt<MapIterator<It, F, T, U>, U>;
}

impl MapIterator<It: DoubleEndedIterator<It, T>, F: Callable<(T), U>, T, U> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut MapIterator<It, F, T, U>) -> Option<U> {
        self.it.next_back().map(self.fun)
    }

    mixin DoubleEndedIterator<MapIterator<It, F, T, U>, U>;
    mixin DoubleEndedIteratorExt<MapIterator<It, F, T, U>, U>;
}

/// Iterator that takes elements while a predicate is true.
///
/// See [IteratorExt::take_while].
struct TakeWhileIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    it: &mut It,
    fun: F,
}

impl TakeWhileIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    /// @ Iterator::next
    fn next(self: &mut TakeWhileIterator<It, F, T>) -> Option<T> {
        self.it.next().and_then(|=self, x: T| -> Option<T> {
            if self.fun(x) {
                Option::some(x)
            } else {
                Option::none()
            }
        })
    }

    mixin Iterator<TakeWhileIterator<It, F, T>, T>;
    mixin IteratorExt<TakeWhileIterator<It, F, T>, T>;
}

/// Iterator that skips elements while a predicate is true.
///
/// See [IteratorExt::skip_while].
struct SkipWhileIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    it: &mut It,
    fun: F,
    finished: bool,
}

impl SkipWhileIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    /// @ Iterator::next
    fn next(self: &mut SkipWhileIterator<It, F, T>) -> Option<T> {
        loop {
            let v = self.it.next();
            if self.finished || !v.is_some {
                return v;
            } else if self.fun(v.inner) {
                continue
            } else {
                self.finished = true;
                return v
            }
        }
    }

    mixin Iterator<SkipWhileIterator<It, F, T>, T>;
    mixin IteratorExt<SkipWhileIterator<It, F, T>, T>;
}

/// Filter map iterator.
///
/// See [IteratorExt::filter_map].
struct FilterMapIterator<It: Iterator<It, T>, F: Callable<(T), Option<U>>, T, U> {
    it: &mut It,
    fun: F,
}

impl FilterMapIterator<It: Iterator<It, T>, F: Callable<(T), Option<U>>, T, U> {
    /// @ Iterator::next
    fn next(self: &mut FilterMapIterator<It, F, T, U>) -> Option<U> {
        use option::try;

        loop {
            let value = self.it.next()?;
            let mapped = self.fun(value);

            if mapped.is_some {
                return mapped
            }
        }
    }

    mixin Iterator<FilterMapIterator<It, F, T, U>, U>;
    mixin IteratorExt<FilterMapIterator<It, F, T, U>, U>;
}

/// Filter iterator.
///
/// See [IteratorExt::filter].
struct FilterIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    it: &mut It,
    fun: F,
}

impl FilterIterator<It: Iterator<It, T>, F: Callable<(T), bool>, T> {
    /// @ Iterator::next
    fn next(self: &mut FilterIterator<It, F, T>) -> Option<T> {
        use option::try;

        loop {
            let value = self.it.next()?;
            if self.fun(value) {
                return Option::some(value)
            }
        }
    }

    mixin Iterator<FilterIterator<It, F, T>, T>;
    mixin IteratorExt<FilterIterator<It, F, T>, T>;
}

impl FilterIterator<It: DoubleEndedIterator<It, T>, F: Callable<(T), bool>, T> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut FilterIterator<It, F, T>) -> Option<T> {
        use option::try;

        loop {
            let value = self.it.next_back()?;
            if self.fun(value) {
                return Option::some(value)
            }
        }
    }

    mixin DoubleEndedIterator<FilterIterator<It, F, T>, T>;
    mixin DoubleEndedIteratorExt<FilterIterator<It, F, T>, T>;
}

/// Iterator that skips a specified number of elements.
///
/// See [IteratorExt::skip].
struct SkipIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    n: usize,
}

impl SkipIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut SkipIterator<It, T>) -> Option<T> {
        while self.n > 0 {
            self.n -= 1;
            if !self.it.next().is_some {
                return Option::none();
            }
        }

        self.it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &SkipIterator<It, T>) -> Option<usize> {
        self.it.size_hint().map(|=self, v: usize| -> usize {
            if self.n > v {
                0
            } else {
                v - self.n
            }
        })
    }

    mixin Iterator<SkipIterator<It, T>, T>;
    mixin IteratorExt<SkipIterator<It, T>, T>;
}

/// Step by iterator.
///
/// See [IteratorExt::step_by].
struct StepByIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    n: usize,
    index: usize,
}

impl StepByIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut StepByIterator<It, T>) -> Option<T> {
        use option::try;
        loop {
            self.index = (self.index + 1) % self.n;
            if self.index > 0 {
                self.it.next()?;
            } else {
                break;
            }
        }
        self.it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &StepByIterator<It, T>) -> Option<usize> {
        self.it.size_hint().map(|=self, v: usize| -> usize {
            (v + self.index) / self.n
        })
    }

    mixin Iterator<StepByIterator<It, T>, T>;
    mixin IteratorExt<StepByIterator<It, T>, T>;
}

/// Fused iterator.
///
/// See [IteratorExt::fuse].
struct FusedIterator<It: Iterator<It, T>, T> {
    done: bool,
    it: &mut It,
}

impl FusedIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut FusedIterator<It, T>) -> Option<T> {
        if self.done {
            Option::none()
        } else {
            let v = self.it.next();
            self.done = !v.is_some;
            v
        }
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &FusedIterator<It, T>) -> Option<usize> {
        if self.done {
            Option::some(0usize)
        } else {
            self.it.size_hint()
        }
    }

    mixin Iterator<FusedIterator<It, T>, T>;
    mixin IteratorExt<FusedIterator<It, T>, T>;
}

impl FusedIterator<It: DoubleEndedIterator<It, T>, T> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut FusedIterator<It, T>) -> Option<T> {
        if self.done {
            Option::none()
        } else {
            let v = self.it.next_back();
            self.done = !v.is_some;
            v
        }
    }

    mixin DoubleEndedIterator<FusedIterator<It, T>, T>;
    mixin DoubleEndedIteratorExt<FusedIterator<It, T>, T>;
}

/// Iterator that takes a specified number of elements.
///
/// See [IteratorExt::take].
struct TakeIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    n: usize,
}

impl TakeIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut TakeIterator<It, T>) -> Option<T> {
        if self.n == 0 {
            return Option::none();
        }

        self.n -= 1;
        self.it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &TakeIterator<It, T>) -> Option<usize> {
        self.it.size_hint().map(|=self, v: usize| -> usize {
            cmp::min(v, self.n)
        })
    }

    mixin Iterator<TakeIterator<It, T>, T>;
    mixin IteratorExt<TakeIterator<It, T>, T>;
}

/// Enumerate iterator.
///
/// See [IteratorExt::enumerate].
struct EnumerateIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    n: usize,
}

impl EnumerateIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut EnumerateIterator<It, T>) -> Option<(usize, T)> {
        use option::try;

        let val = self.it.next()?;
        let res = (self.n, val);
        self.n += 1;
        Option::some(res)
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &EnumerateIterator<It, T>) -> Option<usize> {
        self.it.size_hint()
    }

    mixin Iterator<EnumerateIterator<It, T>, (usize, T)>;
    mixin IteratorExt<EnumerateIterator<It, T>, (usize, T)>;
}

/// Chain iterator.
///
/// See [IteratorExt::chain].
struct ChainIterator<It1: Iterator<It1, T>, It2: Iterator<It2, T>, T> {
    it1: FusedIterator<It1, T>,
    it2: FusedIterator<It2, T>,
}

impl ChainIterator<It1: Iterator<It1, T>, It2: Iterator<It2, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut ChainIterator<It1, It2, T>) -> Option<T> {
        let v = self.it1.next();
        if v.is_some {
            v
        } else {
            self.it2.next()
        }
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &ChainIterator<It1, It2, T>) -> Option<usize> {
        let h1 = self.it1.size_hint();
        let h2 = self.it2.size_hint();

        if h1.is_some && h2.is_some {
            Option::some(h1.inner + h2.inner)
        } else {
            Option::none()
        }
    }

    mixin Iterator<ChainIterator<It1, It2, T>, T>;
    mixin IteratorExt<ChainIterator<It1, It2, T>, T>;
}

impl ChainIterator<It1: DoubleEndedIterator<It1, T>, It2: DoubleEndedIterator<It2, T>, T> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut ChainIterator<It1, It2, T>) -> Option<T> {
        let v = self.it2.next_back();
        if v.is_some {
            v
        } else {
            self.it1.next_back()
        }
    }

    mixin DoubleEndedIterator<ChainIterator<It1, It2, T>, T>;
    mixin DoubleEndedIteratorExt<ChainIterator<It1, It2, T>, T>;
}

/// Inspect iterator.
///
/// See [IteratorExt::inspect].
struct InspectIterator<It: Iterator<It, T>, F: Callable<(T), ()>, T> {
    it: &mut It,
    func: F,
}

impl InspectIterator<It: Iterator<It, T>, F: Callable<(T), ()>, T> {
    /// @ Iterator::next
    fn next(self: &mut InspectIterator<It, F, T>) -> Option<T> {
        let v = self.it.next();
        if v.is_some {
            self.func(v.inner);
        }
        v
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &InspectIterator<It, F, T>) -> Option<usize> {
        self.it.size_hint()
    }

    mixin Iterator<InspectIterator<It, F, T>, T>;
    mixin IteratorExt<InspectIterator<It, F, T>, T>;
}

/// A group iterator for [GroupByIterator].
///
/// See [IteratorExt::group_by].
struct Grouping<It: Iterator<It, T>, F: Callable<(T), K>, T, K: cmp::Equatable<K>> {
    parent: &mut GroupByIterator<It, F, T, K>,
    key: K
}

impl Grouping<It: Iterator<It, T>, F: Callable<(T), K>, T, K: cmp::Equatable<K>> {
    /// @ Iterator::next
    fn next(self: &mut Grouping<It, F, T, K>) -> Option<T> {
        use option::try;

        let v = self.parent.it.peek();
        if !v.is_some {
            self.parent.last_group = Option::none();
            return self.parent.it.next();
        }

        if self.key != self.parent.func(v.inner) {
            self.parent.last_group = Option::none();
            Option::none()
        } else {
            self.parent.it.next()
        }
    }

    mixin Iterator<Grouping<It, F, T, K>, T>;
    mixin IteratorExt<Grouping<It, F, T, K>, T>;
}

/// Grouping iterator
///
/// See [IteratorExt::group_by].
struct GroupByIterator<It: Iterator<It, T>, F: Callable<(T), K>, T, K: cmp::Equatable<K>> {
    it: PeekableIterator<It, T>,
    last_group: Option<Grouping<It, F, T, K>>,
    func: F
}

impl GroupByIterator<It: Iterator<It, T>, F: Callable<(T), K>, T, K: cmp::Equatable<K>> {
    /// @ Iterator::next
    fn next(self: &mut GroupByIterator<It, F, T, K>) -> Option<Grouping<It, F, T, K>> {
        let needs_drain = self.last_group.move();
        if needs_drain.is_some {
            for _ in needs_drain.inner {
            }
        }

        let v = self.it.peek();
        if !v.is_some {
            self.it.next();
            return Option::none();
        }

        self.last_group = Option::some(Grouping::<It, F, T, K> {
            parent: self,
            key: self.func(v.inner)
        });

        self.last_group
    }

    mixin Iterator<GroupByIterator<It, F, T, K>, Grouping<It, F, T, K>>;
    mixin IteratorExt<GroupByIterator<It, F, T, K>, Grouping<It, F, T, K>>;
}

/// Peekable iterator
///
/// See [IteratorExt::peekable].
struct PeekableIterator<It: Iterator<It, T>, T> {
    it: &mut It,
    peeked: Option<T>,
}

impl PeekableIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut PeekableIterator<It, T>) -> Option<T> {
        if self.peeked.is_some {
            self.peeked.move()
        } else {
            self.it.next()
        }
    }

    /// Return the next element in the iterator without consuming it.
    fn peek(self: &mut PeekableIterator<It, T>) -> Option<T> {
        if !self.peeked.is_some {
            self.peeked = self.it.next();
        }
        self.peeked
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &PeekableIterator<It, T>) -> Option<usize> {
        self.it.size_hint().map(|=self, x: usize| -> usize {
            if self.peeked.is_some {
                x + 1
            } else {
                x
            }
        })
    }

    mixin Iterator<PeekableIterator<It, T>, T>;
    mixin IteratorExt<PeekableIterator<It, T>, T>;
}

protocol IteratorExt<Self: Iterator<Self, T>, T> {
    /// Return self.
    ///
    /// Each iterator is itself an iterable object, though only once. This
    /// helper function is there so that iterators can be used ergonomically
    /// in for loops (which de-sugar to a call to `.iter()`)
    fn iter(self: &mut Self) -> &mut Self {
        self
    }

    /// Return an iterator that returns `Option::none()` forever after the
    /// first one is returned.
    ///
    /// Iterators can validly reset back to returning values after they are
    /// exhausted. This method "caps it off" after they are first exhausted.
    fn fuse(self: &mut Self) -> FusedIterator<Self, T> {
        FusedIterator {
            done: false,
            it: self
        }
    }

    /// Returns an iterator that yields all elements of `self` and then all elements of `other`.
    /// # Example
    /// ```
    /// let range = (0..2).iter().chain(&(10..12).iter());
    /// assert_eq!(range.size_hint(), Option::some(4usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(1));
    /// assert_eq!(range.next(), Option::some(10));
    /// assert_eq!(range.next(), Option::some(11));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn chain<Other: Iterator<Other, T>>(self: &mut Self, other: &mut Other) -> ChainIterator<Self, Other, T> {
        ChainIterator {
            it1: FusedIterator { done: false, it: self },
            it2: FusedIterator { done: false, it: other }
        }
    }

    /// Returns an iterator that skips first `n` values.
    ///
    /// If the underlying iterator yields fewer than or exactly `n` values, then the
    /// iterator will yield no values.
    ///
    /// # Example
    /// ```
    /// let range = (0..5).iter().skip(2);
    /// assert_eq!(range.size_hint(), Option::some(3usize));
    ///
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(3));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn skip(self: &mut Self, n: usize) -> SkipIterator<Self, T> {
        SkipIterator {
            it: self,
            n: n,
        }
    }

    /// Returns an iterator that steps by `n` values.
    ///
    /// First value will always be yielded, then every `n`-th value.
    /// # Example
    /// ```
    /// let range = (0..5).iter().step_by(2);
    /// assert_eq!(range.size_hint(), Option::some(3usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn step_by(self: &mut Self, n: usize) -> StepByIterator<Self, T> {
        assert!(n > 0);

        StepByIterator {
            it: self,
            index: n - 1,
            n: n,
        }
    }

    /// Returns an iterator that yields at most `n` elements.

    /// # Example
    /// ```
    /// let range = (0..5).iter().take(2);
    /// assert_eq!(range.size_hint(), Option::some(2usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(1));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn take(self: &mut Self, n: usize) -> TakeIterator<Self, T> {
        TakeIterator {
            it: self,
            n: n,
        }
    }

    /// Returns an iterator that attaches a sequence number of each item.
    ///
    /// # Example
    /// ```
    /// let range = (10..15).iter().enumerate();
    /// assert_eq!(range.size_hint(), Option::some(5usize));
    ///
    /// assert_eq!(range.next(), Option::some((0usize, 10)));
    /// assert_eq!(range.next(), Option::some((1usize, 11)));
    /// assert_eq!(range.next(), Option::some((2usize, 12)));
    /// assert_eq!(range.next(), Option::some((3usize, 13)));
    /// assert_eq!(range.next(), Option::some((4usize, 14)));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn enumerate(self: &mut Self) -> EnumerateIterator<Self, T> {
        EnumerateIterator {
            it: self,
            n: 0,
        }
    }

    /// Returns the last value of the iterator.
    fn last(self: &mut Self) -> Option<T> {
        when Self: DoubleEndedIterator<Self, T> {
            self.next_back()
        } else {
            let value: Option<T> = Option::none();
            loop {
                let next = self.next();
                if next.is_some {
                    value = next;
                } else {
                    return value;
                }
            }
        }
    }

    /// Returns the `n`-th value of the iterator.
    fn nth(self: &mut Self, n: usize) -> Option<T> {
        use option::try;
        for i in 0usize..n {
            self.next()?;
        }
        self.next()
    }

    /// Counts the number of elements in this iterator.
    fn count(self: &mut Self) -> usize {
        let n = 0usize;
        loop {
            if !self.next().is_some {
                return n;
            }
            n += 1;
        }
    }

    fn inspect<F: Callable<(T), ()>>(it: &mut Self, func: F) -> InspectIterator<Self, F, T> {
        InspectIterator {
            it: it,
            func: func,
        }
    }

    /// Returns an iterator that yields the elements while a predicate is true.
    ///
    /// # Example
    /// ```
    /// let range = (0..5).iter().take_while(|x: i32| -> bool { x < 3 });
    /// assert_eq!(range.size_hint(), Option::none());
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(1));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn take_while<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> TakeWhileIterator<Self, F, T> {
        TakeWhileIterator { it: iter, fun: fun }
    }

    /// Returns an iterator that skips the elements while a predicate is true.
    /// # Example
    /// ```
    /// let range = (0..5).iter().skip_while(|x: i32| -> bool { x < 3 });
    /// assert_eq!(range.size_hint(), Option::none());
    ///
    /// assert_eq!(range.next(), Option::some(3));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn skip_while<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> SkipWhileIterator<Self, F, T> {
        SkipWhileIterator { it: iter, fun: fun, finished: false }
    }

    /// Returns an iterator that transforms the elements of this iterator.
    /// # Example
    /// ```
    /// let range = (0..5).iter().map(|x: i32| -> i32 { x * 2 });
    /// assert_eq!(range.size_hint(), Option::some(5usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::some(6));
    /// assert_eq!(range.next(), Option::some(8));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn map<U, F: Callable<(T), U>>(iter: &mut Self, fun: F) -> MapIterator<Self, F, T, U> {
        MapIterator { it: iter, fun: fun }
    }

    /// Executes a function on each element of this iterator.
    fn foreach<F: Callable<(T), ()>>(iter: &mut Self, fun: F) {
        loop {
            let val = iter.next();
            if val.is_some {
                fun(val.inner);
            } else {
                break;
            }
        }
    }

    /// Returns an iterator that yields the elements of this iterator that match a predicate.
    /// # Example
    /// ```
    /// let range = (0..5).iter().filter(|x: i32| -> bool { x % 2 == 0 });
    /// assert_eq!(range.size_hint(), Option::none());
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn filter<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> FilterIterator<Self, F, T> {
        FilterIterator { it: iter, fun: fun }
    }

    fn filter_map<U, F: Callable<(T), Option<U>>>(iter: &mut Self, fun: F) -> FilterMapIterator<Self, F, T, U> {
        FilterMapIterator { it: iter, fun: fun }
    }

    fn reduce<U, F: Callable<(U, T), U>>(iter: &mut Self, initial: U, func: F) -> U {
        loop {
            let next = iter.next();
            if !next.is_some {
                break
            }
            initial = func(initial, next.inner);
        }
        initial
    }

    fn all<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> bool {
        loop {
            let next = iter.next();
            if !next.is_some {
                break
            }
            if !fun(next.inner) {
                return false
            }
        }
        true
    }

    fn any<F: Callable<(T), bool>>(iter: &mut Self, fun: F) -> bool {
        loop {
            let next = iter.next();
            if !next.is_some {
                break
            }
            if fun(next.inner) {
                return true
            }
        }
        false
    }

    fn to_vector(self: &mut Self) -> collections::Vector<T> {
        collections::Vector::from_iter::<T, Self>(self)
    }

    fn fill_slice(self: &mut Self, slice: &mut [T]) -> usize {
        let index = 0usize;
        loop {
            if slice.len <= index {
                break;
            }
            let next = self.next();
            if !next.is_some {
                break;
            }
            slice[index] = next.inner;
            index += 1;
        }

        index
    }

    fn peekable(self: &mut Self) -> PeekableIterator<Self, T> {
        PeekableIterator {
            it: self,
            peeked: Option::none(),
        }
    }


    fn group_by<F: Callable<(T), K>, K: cmp::Equatable<K>>(self: &mut Self, func: F) -> GroupByIterator<Self, F, T, K> {
        GroupByIterator {
            it: self.peekable(),
            last_group: Option::none(),
            func: func
        }
    }
}

/// An empty iterator.
///
/// See [empty] for details.
struct EmptyIterator<T> {}

impl EmptyIterator<T> {
    /// @ Iterator::next
    fn next(self: &mut EmptyIterator<T>) -> Option<T> {
        Option::none()
    }

    fn size_hint(self: &EmptyIterator<T>) -> Option<usize> {
        Option::some(0usize)
    }

    mixin Iterator<EmptyIterator<T>, T>;
    mixin IteratorExt<EmptyIterator<T>, T>;
}

struct FromFnIterator<F: Callable<(), Option<T>>, T> {
    func: F,
}

impl FromFnIterator<F: Callable<(), Option<T>>, T> {
    /// @ Iterator::next
    fn next(self: &mut FromFnIterator<F, T>) -> Option<T> {
        self.func()
    }

    mixin Iterator<FromFnIterator<F, T>, T>;
    mixin IteratorExt<FromFnIterator<F, T>, T>;
}

/// Returns an iterator that produces no elements.
///
/// # Example
/// ```
/// let range = std::iter::empty::<()>();
///
/// assert_eq!(range.next(), Option::none());
/// ```
fn empty<T>() -> EmptyIterator<T> {
    EmptyIterator::<T> {}
}

/// Returns an iterator that produces no elements.
fn from_fn<F: Callable<(), Option<T>>, T>(func: F) -> FromFnIterator<F, T> {
    FromFnIterator::<F, T> { func: func }
}

struct RepeatIterator<T> {
    value: T
}

impl RepeatIterator<T> {
    /// @ Iterator::next
    fn next(self: &mut RepeatIterator<T>) -> Option<T> {
        Option::some(self.value)
    }

    fn next_back(self: &mut RepeatIterator<T>) -> Option<T> {
        Option::some(self.value)
    }

    fn size_hint(self: &RepeatIterator<T>) -> Option<usize> {
        Option::some(usize::max_value())
    }

    mixin Iterator<RepeatIterator<T>, T>;
    mixin IteratorExt<RepeatIterator<T>, T>;
}

/// Returns an iterator that repeats the same value indefinitely.
///
/// # Example
/// ```
/// let range = std::iter::repeat(42);
///
/// assert_eq!(range.next(), Option::some(42));
/// assert_eq!(range.next(), Option::some(42));
/// assert_eq!(range.next(), Option::some(42));
/// // ...
/// ```
fn repeat<T>(value: T) -> RepeatIterator<T> {
    RepeatIterator { value: value }
}

struct OnceIterator<T> {
    value: Option<T>
}

impl OnceIterator<T> {
    /// @ Iterator::next
    fn next(self: &mut OnceIterator<T>) -> Option<T> {
        self.value.next()
    }

    fn next_back(self: &mut OnceIterator<T>) -> Option<T> {
        self.value.next()
    }

    fn size_hint(self: &OnceIterator<T>) -> Option<usize> {
        if self.value.is_some {
            Option::some(1usize)
        } else {
            Option::some(0usize)
        }
    }

    mixin Iterator<OnceIterator<T>, T>;
    mixin IteratorExt<OnceIterator<T>, T>;
}

/// Returns an iterator that repeats a single element exactly once.
///
/// # Example
/// ```
/// let iter = std::iter::once(42);
///
/// assert_eq!(iter.next(), Option::some(42));
/// assert_eq!(iter.next(), Option::none());
/// ```
fn once<T>(value: T) -> OnceIterator<T> {
    OnceIterator { value: Option::some(value) }
}


#[lang(range_full)]
struct RangeFull<T: Integer> {

}

#[lang(range_from)]
struct RangeFrom<T: Integer> {
    lower: T,
}

#[lang(range_to)]
struct RangeTo<T: Integer> {
    upper: T,
}

#[lang(range)]
struct Range<T: Integer> {
    lower: T,
    upper: T,
}


impl Range<T: Integer> {
    #[force_inline]
    #[lang(range_new)]
    fn new(lower: T, upper: T) -> Range<T> {
        Range {
            lower: lower,
            upper: upper,
        }
    }

    #[force_inline]
    fn iter(self: &Range<T>) -> RangeIter<T> {
        RangeIter {
            current: self.lower,
            upper: self.upper,
        }
    }

    fn len(self: &Range<T>) -> T {
        self.upper - self.lower
    }
}

impl RangeFrom<T: Integer> {
    #[force_inline]
    #[lang(range_from_new)]
    fn new(lower: T) -> RangeFrom<T> {
        RangeFrom {
            lower: lower,
        }
    }

    #[force_inline]
    fn iter(self: &RangeFrom<T>) -> RangeIter<T> {
        RangeIter {
            current: self.lower,
            upper: T::max_value(),
        }
    }

    fn len(self: &RangeFrom<T>) -> T {
        T::max_value() - self.lower
    }
}

impl RangeTo<T: Integer> {
    #[force_inline]
    #[lang(range_to_new)]
    fn new(upper: T) -> RangeTo<T> {
        RangeTo {
            upper: upper,
        }
    }

    #[force_inline]
    fn iter(self: &RangeTo<T>) -> RangeIter<T> {
        RangeIter {
            current: T::min_value(),
            upper: self.upper,
        }
    }

    fn len(self: &RangeTo<T>) -> T {
        self.upper - T::min_value()
    }
}

impl RangeFull<T: Integer> {
    #[force_inline]
    #[lang(range_full_new)]
    fn new() -> RangeFull<T> {
        RangeFull {}
    }

    #[force_inline]
    fn iter(self: &RangeFull<T>) -> RangeIter<T> {
        RangeIter {
            current: T::min_value(),
            upper: T::max_value(),
        }
    }

    fn len(self: &RangeFull<T>) -> T {
        T::max_value() - T::min_value()
    }
}

struct RangeIter<T: Integer> {
    current: T,
    upper: T,
}

impl RangeIter<T: Integer> {
    /// @ Iterator::next
    #[force_inline]
    fn next(self: &mut RangeIter<T>) -> Option<T> {
        if self.current < self.upper {
            let current = self.current;
            self.current += 1;
            Option::some(current)
        } else {
            Option::none()
        }
    }

    #[force_inline]
    fn next_back(self: &mut RangeIter<T>) -> Option<T> {
        if self.current < self.upper {
            self.upper -= 1;
            Option::some(self.upper)
        } else {
            Option::none()
        }
    }

    fn size_hint(self: &RangeIter<T>) -> Option<usize> {
        if self.current < self.upper {
            Option::some(self.upper as usize - self.current as usize)
        } else {
            Option::some(0usize)
        }
    }

    mixin Iterator<RangeIter<T>, T>;
    mixin IteratorExt<RangeIter<T>, T>;
    mixin DoubleEndedIterator<RangeIter<T>, T>;
    mixin DoubleEndedIteratorExt<RangeIter<T>, T>;
}


#[cfg(all(test, test_std))]
mod tests {
    #[test]
    fn test_range() {
        let range = (0..5).iter();
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_map() {
        let range = (0..5).iter().map(|x: i32| -> i32 { x * 2 });
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(6));
        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_map_rev() {
        let range = (0..5).iter().map(|x: i32| -> i32 { x * 2 }).rev();
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::some(6));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter() {
        let range = (0..5).iter().filter(|x: i32| -> bool { x % 2 == 0 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter_rev() {
        let range = (0..5).iter().filter(|x: i32| -> bool { x % 2 == 0 }).rev();
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter_map() {
        let range = (0..5).iter().filter_map(|x: i32| -> Option<i32> {
            if x % 2 == 0 {
                Option::some(x * 2)
            } else {
                Option::none()
            }
        });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_reduce() {
        let range = (0..5).iter().reduce(0, |acc: i32, x: i32| -> i32 {
            acc + x
        });
        assert_eq!(range, 10);
    }

    #[test]
    fn test_empty() {
        let range = empty::<()>();
        assert_eq!(range.size_hint(), Option::some(0usize));

        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_all() {
        assert_eq!(empty::<i32>().all(|v: i32| -> bool { v > 10 }), true)
        assert_eq!((0..5).iter().all(|v: i32| -> bool { v > 10 }), false);
        assert_eq!((0..5).iter().all(|v: i32| -> bool { v >= 0 }), true);
    }

    #[test]
    fn test_any() {
        assert_eq!(empty::<i32>().any(|v: i32| -> bool { v > 10 }), false)
        assert_eq!((0..5).iter().any(|v: i32| -> bool { v > 3 }), true);
        assert_eq!((0..5).iter().any(|v: i32| -> bool { v > 10 }), false);
    }

    #[test]
    fn test_repeat() {
        let range = repeat(1);
        assert_eq!(range.size_hint(), Option::some(usize::max_value()));

        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        // ...
    }

    #[test]
    fn test_skip() {
        let range = (0..5).iter().skip(2);
        assert_eq!(range.size_hint(), Option::some(3usize));

        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
        // ...
    }

    #[test]
    fn test_take() {
        let range = (0..5).iter().take(2);
        assert_eq!(range.size_hint(), Option::some(2usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_count() {
        assert_eq!((0..5).iter().count(), 5usize);
    }

    #[test]
    fn test_last() {
        assert_eq!((0..5).iter().last(), Option::some(4));
        assert_eq!(empty::<i32>().last(), Option::none());
    }

    #[test]
    fn test_chain() {
        let range = (0..2).iter().chain(&(10..12).iter());
        assert_eq!(range.size_hint(), Option::some(4usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(10));
        assert_eq!(range.next(), Option::some(11));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_chain_rev() {
        let range = (0..2).iter().chain(&(10..12).iter()).rev();
        assert_eq!(range.size_hint(), Option::some(4usize));

        assert_eq!(range.next(), Option::some(11));
        assert_eq!(range.next(), Option::some(10));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_enumerate() {
        let range = (10..15).iter().enumerate();
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some((0usize, 10)));
        assert_eq!(range.next(), Option::some((1usize, 11)));
        assert_eq!(range.next(), Option::some((2usize, 12)));
        assert_eq!(range.next(), Option::some((3usize, 13)));
        assert_eq!(range.next(), Option::some((4usize, 14)));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_foreach() {
        let sum = 0;
        (0..5).iter().foreach(|&sum, x: i32| {
            sum += x;
        });

        assert_eq!(sum, 10);
    }

    #[test]
    fn test_inspect() {
        let sum1 = 0;
        let sum2 = 0;
        let sum3 = 0;
        let count = (0..5)
            .iter()
            .inspect(|&sum1, x: i32| { sum1 += x })
            .inspect(|&sum2, x: i32| { sum2 += x * x })
            .inspect(|&sum3, x: i32| { sum3 += x * x * x })
            .count();

        assert_eq!(sum1, 10);
        assert_eq!(sum2, 30);
        assert_eq!(sum3, 100);
    }

    #[test]
    fn test_to_vector() {
        let vec = (0..5).iter().to_vector();
        assert_eq!(vec.as_slice(), &[0, 1, 2, 3, 4]);
    }

    #[test]
    fn test_take_while() {
        let range = (0..5).iter().take_while(|x: i32| -> bool { x < 3 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_skip_while() {
        let range = (0..5).iter().skip_while(|x: i32| -> bool { x < 3 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_step_by() {
        let range = (0..5).iter().step_by(2);
        assert_eq!(range.size_hint(), Option::some(3usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_nth() {
        assert_eq!((0..5).iter().nth(0), Option::some(0));
        assert_eq!((0..5).iter().nth(1), Option::some(1));
        assert_eq!((0..5).iter().nth(10), Option::none());
    }

    #[test]
    fn test_once() {
        let range = once(0);
        assert_eq!(range.size_hint(), Option::some(1usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn fill_slice() {
        let buf: [i32; 10];
        let slice = buf.as_slice_mut();

        let written = (0..5).iter().fill_slice(slice);
        assert_eq!(written, 5);
        assert_eq!(slice[..5], &[0, 1, 2, 3, 4]);

        let written = (10..200).iter().fill_slice(slice);
        assert_eq!(written, 10);
        assert_eq!(slice, &[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);
    }

    #[test]
    fn test_peekable() {
        let range = (0..3).iter().peekable();
        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.peek(), Option::some(0));

        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_group_by() {
        let values: &[(i32, i32)] = &[
            (0, 0),
            (1, 0),
            (1, 1),
            (2, 0),
            (2, 1),
            (2, 2)
        ];

        let groups = values.iter().group_by(|v: (i32, i32)| -> i32 { v.0 });

        assert_eq!(groups.size_hint(), Option::none());
        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((0, 0)));
        assert_eq!(group.next(), Option::none());

        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((1, 0)));
        assert_eq!(group.next(), Option::some((1, 1)));
        assert_eq!(group.next(), Option::none());

        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((2, 0)));
        assert_eq!(group.next(), Option::some((2, 1)));
        assert_eq!(group.next(), Option::some((2, 2)));
        assert_eq!(group.next(), Option::none());

        assert!(!groups.next().is_some);
    }

    #[test]
    fn test_group_by_draining() {
        let values: &[(i32, i32)] = &[
            (0, 0),
            (1, 0),
            (1, 1),
            (2, 0),
            (2, 1),
            (2, 2)
        ];

        let groups = values.iter().group_by(|v: (i32, i32)| -> i32 { v.0 });

        assert_eq!(groups.size_hint(), Option::none());
        let group = groups.next().unwrap();
        let group = groups.next().unwrap();
        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((2, 0)));
        assert_eq!(group.next(), Option::some((2, 1)));
        assert_eq!(group.next(), Option::some((2, 2)));
        assert_eq!(group.next(), Option::none());

        assert!(!groups.next().is_some);
    }

    #[test]
    fn test_rev() {
        let range = (0..5).iter().rev();
        assert_eq!(range.size_hint(), Option::some(5usize));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());

        let range = (0..5).iter().rev().rev();
        assert_eq!(range.size_hint(), Option::some(5usize));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());

        let range = [0, 1, 2, 3, 4].iter().rev();
        assert_eq!(range.size_hint(), Option::some(5usize));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_from_fn() {
        let index = 5;
        let iter = from_fn(|&index| -> Option<i32> {
            if index == 0 {
                Option::none()
            } else {
                index -= 1;
                Option::some(index)
            }
        });

        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(0));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_fuse() {
        let index = 0;
        let iter = from_fn(|&index| -> Option<()> {
            index += 1;
            if index % 2 == 0 {
                Option::none()
            } else {
                Option::some(())
            }
        }).fuse();

        assert_eq!(iter.next(), Option::some(()));
        assert_eq!(iter.next(), Option::none());
        assert_eq!(iter.next(), Option::none());
        assert_eq!(iter.next(), Option::none());
    }
}
