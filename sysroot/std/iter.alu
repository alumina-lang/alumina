//! Iterators.
//!
//! Iterators provide an abstraction for types that can be used to access their elements
//! one-by-one, for example in `for` loop. The most common examples are [ranges](std::range) and collections.
//!
//! ```
//! for i in 0..10 {
//!     println!("{}", i);
//! }
//!
//! for i in &["a", "b", "c"] {
//!     println!("{}", i);
//! }
//! ```
//!
//! There is distinction between an [iterable type](Iterable) and an [iterator](Iterator). Iterators are
//! consumable objects that can only be used to iterate once. Iterable types are ones that can
//! produce an iterator when needed.
//!
//! Iterators can also be combined to create more complex types of iterators. See [IteratorExt] mixin
//! for a reference of methods that can be used to combine iterators.

use builtins::Integer;
use option::Option;

/// Iterators.
///
/// See [module-level documentation](std::iter) for more details.
///
/// # Implementing an iterator
///
/// Types that have [Iterator] semantics should implement [Iterator::next] at a minimum. When the iterator can
/// cheaply determine the number of remaining elements, it should also implement [Iterator::size_hint]. This
/// enables the collections constructed from iterators to efficiently reserve space for the elements and
/// avoid reallocations. If [Iterator::size_hint] returns a value, it should be exact.
///
/// All types implementing [Iterator] should also mix in [IteratorExt], which provides a number of useful
/// extension methods.
///
/// See also [DoubleEndedIterator] for iterators that can be iterated in reverse order.
///
/// ## Example
/// ```
/// struct Countdown { counter: i32 }
///
/// impl Countdown {
///     use std::cmp::max;
///     use std::iter::{Iterator, IteratorExt};
///
///     fn next(self: &mut Countdown) -> Option<i32> {
///         if self.counter <= 0 {
///             Option::none()
///         } else {
///             let ret = Option::some(self.counter);
///             self.counter -= 1;
///             ret
///         }
///     }
///
///     fn size_hint(self: &Countdown) -> Option<usize> {
///         Option::some(max(0, self.counter) as usize)
///     }
///
///     mixin Iterator<Countdown, i32>;
///     mixin IteratorExt<Countdown, i32>;
/// }
///
/// // use `(1..=5).rev()` in real code
/// let countdown = Countdown { counter: 5 };
///
/// for i in countdown {
///     println!("{}", i);
/// }
/// println!("Ignition and Liftoff!");
/// ```
protocol Iterator<Self, T> {
    /// Returns the next item, if any.
    ///
    /// If the iterator has reached the end, it returns `Option::none()`.
    ///
    /// See [Iterator] for more information.
    fn next(self: &mut Self) -> Option<T>;

    /// Returns the number of remaining elements, if available.
    ///
    /// See [Iterator] for more information.
    fn size_hint(self: &Self) -> Option<usize> {
        Option::none()
    }
}

/// Iterators that can be consumed from both ends.
///
/// # Implementing a double-ended iterator
///
/// Iterators that can be iterated from both ends efficiently should implement this protocol.
/// [DoubleEndedIterator::next_back] is the method that is used to iterate in reverse order. The
/// convention is that [Iterator::next] and [DoubleEndedIterator::next_back] "meet in the middle",
/// so that each element is visited once regardless of the direction of iteration.
///
/// All types implementing [DoubleEndedIterator] should also mix in [DoubleEndedIteratorExt], which provides
/// relevant extension methods, notably [DoubleEndedIteratorExt::rev], which reverses the direction of
/// iteration.
///
/// ## Example
/// ```
/// struct Range { lower: i32, upper: i32 }
///
/// impl Range {
///     use std::iter::{Iterator, IteratorExt, DoubleEndedIterator, DoubleEndedIteratorExt};
///
///     fn next(self: &mut Range) -> Option<i32> {
///         if self.lower < self.upper {
///             let result = self.lower;
///             self.lower += 1;
///             Option::some(result)
///         } else {
///             Option::none()
///         }
///     }
///
///     fn next_back(self: &mut Range) -> Option<i32> {
///         if self.lower < self.upper {
///             self.upper -= 1;
///             Option::some(self.upper)
///         } else {
///             Option::none()
///         }
///     }
///
///     mixin Iterator<Range, i32>;
///     mixin IteratorExt<Range, i32>;
///     mixin DoubleEndedIterator<Range, i32>;
///     mixin DoubleEndedIteratorExt<Range, i32>;
/// }
/// ```
protocol DoubleEndedIterator<Self: Iterator<Self, T>, T> {
    /// Returns the next item from the back, if any.
    ///
    /// If the iterator has reached the beginning, it returns none.
    ///
    /// See [DoubleEndedIterator] for more information.
    fn next_back(self: &mut Self) -> Option<T>;
}

/// Extension mixin for [DoubleEndedIterator] types.
protocol DoubleEndedIteratorExt<Self: DoubleEndedIterator<Self, T>, T> {
    /// "Reverse" the iterator.
    ///
    /// `rev` returns a wrapper over an iterator that has `next` and `next_back` methods
    /// reversed.
    fn rev(self: &mut Self) -> RevIterator<Self, T> {
        RevIterator { _it: self }
    }
}

/// Types that can be iterated.
///
/// Types that implement `Iterable` can produce an iterator when called with
/// the `iter` method.
protocol Iterable<Self, It: Iterator<It, T>, T> {
    /// Returns an iterator over the elements of this iterable.
    ///
    /// See [Iterable] for details.
    fn iter(self: &Self) -> It;
}

/// Types that can produce an iterator over pointers to their elements.
protocol IterableRef<Self, It: Iterator<It, &T>, T> {
    /// Returns an iterator over the pointers of the items of this iterable.
    ///
    /// See [IterableRef] for details.
    fn iter_ref(self: &Self) -> It;
}

/// Types that can produce an iterator over mutable pointers to their elements.
protocol IterableMut<Self, It: Iterator<It, &mut T>, T> {
    /// Returns an iterator over mutable pointers to the elements of the collection.
    ///
    /// See [IterableMut] for details.
    fn iter_mut(self: &mut Self) -> It;
}

/// Reverse iterator.
///
/// See [DoubleEndedIteratorExt::rev].
struct RevIterator<It: DoubleEndedIterator<It, T>, T> {
    _it: &mut It
}

impl RevIterator<It: DoubleEndedIterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut RevIterator<It, T>) -> Option<T> {
        self._it.next_back()
    }

    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut RevIterator<It, T>) -> Option<T> {
        self._it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &RevIterator<It, T>) -> Option<usize> {
        self._it.size_hint()
    }

    mixin Iterator<RevIterator<It, T>, T>;
    mixin IteratorExt<RevIterator<It, T>, T>;
    mixin DoubleEndedIterator<RevIterator<It, T>, T>;
    mixin DoubleEndedIteratorExt<RevIterator<It, T>, T>;
}

/// Map iterator.
///
/// See [IteratorExt::map].
struct MapIterator<It: Iterator<It, T>, F: Fn(T) -> U, T, U> {
    _it: &mut It,
    _fun: F,
}

impl MapIterator<It: Iterator<It, T>, F: Fn(T) -> U, T, U> {
    /// @ Iterator::next
    fn next(self: &mut MapIterator<It, F, T, U>) -> Option<U> {
        self._it.next().map(self._fun)
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &MapIterator<It, F, T, U>) -> Option<usize> {
        self._it.size_hint()
    }

    mixin Iterator<MapIterator<It, F, T, U>, U>;
    mixin IteratorExt<MapIterator<It, F, T, U>, U>;
}

impl MapIterator<It: DoubleEndedIterator<It, T>, F: Fn(T) -> U, T, U> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut MapIterator<It, F, T, U>) -> Option<U> {
        self._it.next_back().map(self._fun)
    }

    mixin DoubleEndedIterator<MapIterator<It, F, T, U>, U>;
    mixin DoubleEndedIteratorExt<MapIterator<It, F, T, U>, U>;
}

/// Iterator that takes elements while a predicate is true.
///
/// See [IteratorExt::take_while].
struct TakeWhileIterator<It: Iterator<It, T>, F: Fn(T) -> bool, T> {
    _it: &mut It,
    _fun: F,
}

impl TakeWhileIterator<It: Iterator<It, T>, F: Fn(T) -> bool, T> {
    /// @ Iterator::next
    fn next(self: &mut TakeWhileIterator<It, F, T>) -> Option<T> {
        self._it.next().and_then(|=self, x: T| -> Option<T> {
            if self._fun(x) {
                Option::some(x)
            } else {
                Option::none()
            }
        })
    }

    mixin Iterator<TakeWhileIterator<It, F, T>, T>;
    mixin IteratorExt<TakeWhileIterator<It, F, T>, T>;
}

/// Iterator that skips elements until a predicate becomes false.
///
/// See [IteratorExt::skip_while].
struct SkipWhileIterator<It: Iterator<It, T>, F: Fn(T) -> bool, T> {
    _it: &mut It,
    _fun: F,
    _finished: bool,
}

impl SkipWhileIterator<It: Iterator<It, T>, F: Fn(T) -> bool, T> {
    /// @ Iterator::next
    fn next(self: &mut SkipWhileIterator<It, F, T>) -> Option<T> {
        loop {
            let v = self._it.next();
            if self._finished || v.is_none() {
                return v;
            } else if self._fun(v.unwrap()) {
                continue
            } else {
                self._finished = true;
                return v
            }
        }
    }

    mixin Iterator<SkipWhileIterator<It, F, T>, T>;
    mixin IteratorExt<SkipWhileIterator<It, F, T>, T>;
}

/// Filter map iterator.
///
/// See [IteratorExt::filter_map].
struct FilterMapIterator<It: Iterator<It, T>, F: Fn(T) -> Option<U>, T, U> {
    _it: &mut It,
    _fun: F,
}

impl FilterMapIterator<It: Iterator<It, T>, F: Fn(T) -> Option<U>, T, U> {
    /// @ Iterator::next
    fn next(self: &mut FilterMapIterator<It, F, T, U>) -> Option<U> {
        use option::try;

        loop {
            let value = self._it.next()?;
            let mapped = self._fun(value);

            if mapped.is_some() {
                return mapped
            }
        }
    }

    mixin Iterator<FilterMapIterator<It, F, T, U>, U>;
    mixin IteratorExt<FilterMapIterator<It, F, T, U>, U>;
}


impl FilterMapIterator<It: DoubleEndedIterator<It, T>, F: Fn(T) -> Option<U>, T, U> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut FilterMapIterator<It, F, T, U>) -> Option<U> {
        use option::try;

        loop {
            let value = self._it.next_back()?;
            let mapped = self._fun(value);

            if mapped.is_some() {
                return mapped
            }
        }
    }

    mixin DoubleEndedIterator<FilterMapIterator<It, F, T, U>, U>;
    mixin DoubleEndedIteratorExt<FilterMapIterator<It, F, T, U>, U>;
}

/// Filter iterator.
///
/// See [IteratorExt::filter].
struct FilterIterator<It: Iterator<It, T>, F: Fn(T) -> bool, T> {
    _it: &mut It,
    _fun: F,
}

impl FilterIterator<It: Iterator<It, T>, F: Fn(T) -> bool, T> {
    /// @ Iterator::next
    fn next(self: &mut FilterIterator<It, F, T>) -> Option<T> {
        use option::try;

        loop {
            let value = self._it.next()?;
            if self._fun(value) {
                return Option::some(value)
            }
        }
    }

    mixin Iterator<FilterIterator<It, F, T>, T>;
    mixin IteratorExt<FilterIterator<It, F, T>, T>;
}

impl FilterIterator<It: DoubleEndedIterator<It, T>, F: Fn(T) -> bool, T> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut FilterIterator<It, F, T>) -> Option<T> {
        use option::try;

        loop {
            let value = self._it.next_back()?;
            if self._fun(value) {
                return Option::some(value)
            }
        }
    }

    mixin DoubleEndedIterator<FilterIterator<It, F, T>, T>;
    mixin DoubleEndedIteratorExt<FilterIterator<It, F, T>, T>;
}

/// Iterator that skips a specified number of elements.
///
/// See [IteratorExt::skip].
struct SkipIterator<It: Iterator<It, T>, T> {
    _it: &mut It,
    _n: usize,
}

impl SkipIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut SkipIterator<It, T>) -> Option<T> {
        while self._n > 0 {
            self._n -= 1;
            if self._it.next().is_none() {
                return Option::none();
            }
        }

        self._it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &SkipIterator<It, T>) -> Option<usize> {
        self._it.size_hint().map(|=self, v: usize| -> usize {
            if self._n > v {
                0
            } else {
                v - self._n
            }
        })
    }

    mixin Iterator<SkipIterator<It, T>, T>;
    mixin IteratorExt<SkipIterator<It, T>, T>;
}

/// Step by iterator.
///
/// See [IteratorExt::step_by].
struct StepByIterator<It: Iterator<It, T>, T> {
    _it: &mut It,
    _n: usize,
    _index: usize,
}

impl StepByIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut StepByIterator<It, T>) -> Option<T> {
        use option::try;
        loop {
            self._index = (self._index + 1) % self._n;
            if self._index > 0 {
                self._it.next()?;
            } else {
                break;
            }
        }
        self._it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &StepByIterator<It, T>) -> Option<usize> {
        self._it.size_hint().map(|=self, v: usize| -> usize {
            (v + self._index) / self._n
        })
    }

    mixin Iterator<StepByIterator<It, T>, T>;
    mixin IteratorExt<StepByIterator<It, T>, T>;
}

/// Fused iterator.
///
/// See [IteratorExt::fuse].
struct FusedIterator<It: Iterator<It, T>, T> {
    _done: bool,
    _it: &mut It,
}

impl FusedIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut FusedIterator<It, T>) -> Option<T> {
        if self._done {
            Option::none()
        } else {
            let v = self._it.next();
            self._done = v.is_none();
            v
        }
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &FusedIterator<It, T>) -> Option<usize> {
        if self._done {
            Option::some(0usize)
        } else {
            self._it.size_hint()
        }
    }

    mixin Iterator<FusedIterator<It, T>, T>;
    mixin IteratorExt<FusedIterator<It, T>, T>;
}

impl FusedIterator<It: DoubleEndedIterator<It, T>, T> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut FusedIterator<It, T>) -> Option<T> {
        if self._done {
            Option::none()
        } else {
            let v = self._it.next_back();
            self._done = v.is_none();
            v
        }
    }

    mixin DoubleEndedIterator<FusedIterator<It, T>, T>;
    mixin DoubleEndedIteratorExt<FusedIterator<It, T>, T>;
}

/// Iterator that takes a specified number of elements.
///
/// See [IteratorExt::take].
struct TakeIterator<It: Iterator<It, T>, T> {
    _it: &mut It,
    _n: usize,
}

impl TakeIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut TakeIterator<It, T>) -> Option<T> {
        if self._n == 0 {
            return Option::none();
        }

        self._n -= 1;
        self._it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &TakeIterator<It, T>) -> Option<usize> {
        self._it.size_hint().map(|=self, v: usize| -> usize {
            cmp::min(v, self._n)
        })
    }

    mixin Iterator<TakeIterator<It, T>, T>;
    mixin IteratorExt<TakeIterator<It, T>, T>;
}

/// Enumerate iterator.
///
/// See [IteratorExt::enumerate].
struct EnumerateIterator<It: Iterator<It, T>, T> {
    _it: &mut It,
    _n: usize,
}

impl EnumerateIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut EnumerateIterator<It, T>) -> Option<(usize, T)> {
        use option::try;

        let val = self._it.next()?;
        let res = (self._n, val);
        self._n += 1;
        Option::some(res)
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &EnumerateIterator<It, T>) -> Option<usize> {
        self._it.size_hint()
    }

    mixin Iterator<EnumerateIterator<It, T>, (usize, T)>;
    mixin IteratorExt<EnumerateIterator<It, T>, (usize, T)>;
}

/// Chain iterator.
///
/// See [IteratorExt::chain].
struct ChainIterator<It1: Iterator<It1, T>, It2: Iterator<It2, T>, T> {
    _it1: FusedIterator<It1, T>,
    _it2: FusedIterator<It2, T>,
}

impl ChainIterator<It1: Iterator<It1, T>, It2: Iterator<It2, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut ChainIterator<It1, It2, T>) -> Option<T> {
        self._it1.next().or_else(|=self| -> Option<T> { self._it2.next() })
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &ChainIterator<It1, It2, T>) -> Option<usize> {
        self._it1.size_hint()
            .zip(self._it2.size_hint())
            .map(|v: (usize, usize)| -> usize {
                v.0 + v.1
            })
    }

    mixin Iterator<ChainIterator<It1, It2, T>, T>;
    mixin IteratorExt<ChainIterator<It1, It2, T>, T>;
}

impl ChainIterator<It1: DoubleEndedIterator<It1, T>, It2: DoubleEndedIterator<It2, T>, T> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut ChainIterator<It1, It2, T>) -> Option<T> {
        let v = self._it2.next_back();
        if v.is_some() {
            v
        } else {
            self._it1.next_back()
        }
    }

    mixin DoubleEndedIterator<ChainIterator<It1, It2, T>, T>;
    mixin DoubleEndedIteratorExt<ChainIterator<It1, It2, T>, T>;
}

/// Merge iterator.
///
/// See [IteratorExt::merge_sorted].
struct MergeIterator<It1: Iterator<It1, T>, It2: Iterator<It2, T>, T: cmp::Comparable<T>> {
    _it1: Option<PeekableIterator<It1, T>>,
    _it2: Option<PeekableIterator<It2, T>>,
}

impl MergeIterator<It1: Iterator<It1, T>, It2: Iterator<It2, T>, T: cmp::Comparable<T>> {
    /// @ Iterator::next
    fn next(self: &mut MergeIterator<It1, It2, T>) -> Option<T> {
        if self._it1.is_none() {
            return self._it2.as_mut_ptr().unwrap().next();
        } else if self._it2.is_none() {
            return self._it1.as_mut_ptr().unwrap().next();
        }

        let it1 = self._it1.as_mut_ptr().unwrap();
        let it2 = self._it2.as_mut_ptr().unwrap();

        let v1 = it1.peek();
        let v2 = it2.peek();

        if v1.is_none() {
            it1.next();
            self._it1 = Option::none();

            it2.next()
        } else if v2.is_none() {
            it2.next();
            self._it2 = Option::none();

            it1.next()
        } else if v1.unwrap() <= v2.unwrap() {
            it1.next()
        } else {
            it2.next()
        }
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &MergeIterator<It1, It2, T>) -> Option<usize> {
        if self._it1.is_none() {
            self._it2.as_ptr().unwrap().size_hint()
        } else if self._it2.is_none() {
            self._it1.as_ptr().unwrap().size_hint()
        } else {
            self._it1.as_ptr().unwrap().size_hint()
                .zip(self._it2.as_ptr().unwrap().size_hint())
                .map(|v: (usize, usize)| -> usize {
                    v.0 + v.1
                })
        }
    }

    mixin Iterator<MergeIterator<It1, It2, T>, T>;
    mixin IteratorExt<MergeIterator<It1, It2, T>, T>;
}


impl MergeIterator<It1: DoubleEndedIterator<It1, T>, It2: DoubleEndedIterator<It2, T>, T: cmp::Comparable<T>> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut MergeIterator<It1, It2, T>) -> Option<T> {
        if self._it1.is_none() {
            return self._it2.as_mut_ptr().unwrap().next_back();
        } else if self._it2.is_none() {
            return self._it1.as_mut_ptr().unwrap().next_back();
        }

        let it1 = self._it1.as_mut_ptr().unwrap();
        let it2 = self._it2.as_mut_ptr().unwrap();

        let v1 = it1.peek_back();
        let v2 = it2.peek_back();

        if v1.is_none() {
            it1.next_back();
            self._it1 = Option::none();

            it2.next_back()
        } else if v2.is_none() {
            it2.next_back();
            self._it2 = Option::none();

            it1.next_back()
        } else if v1.unwrap() > v2.unwrap() {
            // Strict greater than to ensure "stable" ordering.
            it1.next_back()
        } else {
            it2.next_back()
        }
    }

    mixin DoubleEndedIterator<MergeIterator<It1, It2, T>, T>;
    mixin DoubleEndedIteratorExt<MergeIterator<It1, It2, T>, T>;
}


/// Inspect iterator.
///
/// See [IteratorExt::inspect].
struct InspectIterator<It: Iterator<It, T>, F: Fn(T), T> {
    _it: &mut It,
    _func: F,
}

impl InspectIterator<It: Iterator<It, T>, F: Fn(T), T> {
    /// @ Iterator::next
    fn next(self: &mut InspectIterator<It, F, T>) -> Option<T> {
        let v = self._it.next();
        if v.is_some() {
            self._func(v.unwrap());
        }
        v
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &InspectIterator<It, F, T>) -> Option<usize> {
        self._it.size_hint()
    }

    mixin Iterator<InspectIterator<It, F, T>, T>;
    mixin IteratorExt<InspectIterator<It, F, T>, T>;
}

/// A group iterator for [GroupByIterator].
///
/// See [IteratorExt::group_by].
struct Grouping<It: Iterator<It, T>, F: Fn(T) -> K, T, K: cmp::Equatable<K>> {
    _parent: &mut GroupByIterator<It, F, T, K>,
    key: K
}

impl Grouping<It: Iterator<It, T>, F: Fn(T) -> K, T, K: cmp::Equatable<K>> {
    /// @ Iterator::next
    fn next(self: &mut Grouping<It, F, T, K>) -> Option<T> {
        let v = self._parent._it.peek();
        if v.is_none() {
            self._parent._last_group = Option::none();
            return self._parent._it.next();
        }

        if self.key != self._parent._func(v.unwrap()) {
            self._parent._last_group = Option::none();
            Option::none()
        } else {
            self._parent._it.next()
        }
    }

    mixin Iterator<Grouping<It, F, T, K>, T>;
    mixin IteratorExt<Grouping<It, F, T, K>, T>;
}

/// Grouping iterator
///
/// See [IteratorExt::group_by].
struct GroupByIterator<It: Iterator<It, T>, F: Fn(T) -> K, T, K: cmp::Equatable<K>> {
    _it: PeekableIterator<It, T>,
    _last_group: Option<Grouping<It, F, T, K>>,
    _func: F
}

impl GroupByIterator<It: Iterator<It, T>, F: Fn(T) -> K, T, K: cmp::Equatable<K>> {
    /// @ Iterator::next
    fn next(self: &mut GroupByIterator<It, F, T, K>) -> Option<Grouping<It, F, T, K>> {
        let needs_drain = self._last_group.move();
        if needs_drain.is_some() {
            for _ in needs_drain.unwrap() {
            }
        }

        let v = self._it.peek();
        if v.is_none() {
            self._it.next();
            return Option::none();
        }

        self._last_group = Option::some(Grouping::<It, F, T, K> {
            _parent: self,
            key: self._func(v.unwrap())
        });

        self._last_group
    }

    mixin Iterator<GroupByIterator<It, F, T, K>, Grouping<It, F, T, K>>;
    mixin IteratorExt<GroupByIterator<It, F, T, K>, Grouping<It, F, T, K>>;
}

/// A chunk yielded by [ChunksIterator].
///
/// See [IteratorExt::chunks].
struct Chunk<It: Iterator<It, T>, T> {
    _it: &mut TakeIterator<PeekableIterator<It, T>, T>,
}

impl Chunk<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut Chunk<It, T>) -> Option<T> {
        self._it.next()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &Chunk<It, T>) -> Option<usize> {
        self._it.size_hint()
    }

    mixin Iterator<Chunk<It, T>, T>;
    mixin IteratorExt<Chunk<It, T>, T>;
}

/// Chunking iterator
///
/// See [IteratorExt::chunks].
struct ChunksIterator<It: Iterator<It, T>, T> {
    _chunk_size: usize,
    _it: PeekableIterator<It, T>,
    _last_chunk: Option<TakeIterator<PeekableIterator<It, T>, T>>,
}

impl ChunksIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut ChunksIterator<It, T>) -> Option<Chunk<It, T>> {
        let needs_drain = self._last_chunk.move();
        if needs_drain.is_some() {
            for _ in needs_drain.unwrap() {
            }
            self._last_chunk = Option::none();
        }

        let v = self._it.peek();
        if v.is_none() {
            self._it.next();
            return Option::none();
        }

        self._last_chunk = Option::some(self._it.take(self._chunk_size));
        let result = Chunk {
            _it: self._last_chunk.as_mut_ptr().unwrap()
        };

        Option::some(result)
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &ChunksIterator<It, T>) -> Option<usize> {
        self._it.size_hint().map(|=self, s: usize| -> usize {
            let full_size = (s + self._chunk_size - 1) / self._chunk_size;
            if self._last_chunk.is_some() {
                full_size - 1
            } else {
                full_size
            }
        })
    }

    mixin Iterator<ChunksIterator<It, T>, Chunk<It, T,>>;
    mixin IteratorExt<ChunksIterator<It, T>, Chunk<It, T>>;
}

/// Peekable iterator
///
/// See [IteratorExt::peekable].
struct PeekableIterator<It: Iterator<It, T>, T> {
    _it: &mut It,
    _peeked: Option<T>,
    _peeked_back: when typing::matches::<It, DoubleEndedIterator<It, T>>() {
        Option<T>
    } else {
        ()
    },
}

impl PeekableIterator<It: Iterator<It, T>, T> {
    /// @ Iterator::next
    fn next(self: &mut PeekableIterator<It, T>) -> Option<T> {
        if self._peeked.is_some() {
            self._peeked.move()
        } else {
            when *self._it is DoubleEndedIterator<It, T> {
                let next = self._it.next();
                if next.is_none() {
                    self._peeked_back.move()
                } else {
                    next
                }
            } else {
                self._it.next()
            }
        }
    }

    /// Return the next element in the iterator without consuming it.
    fn peek(self: &mut PeekableIterator<It, T>) -> Option<T> {
        when *self._it is DoubleEndedIterator<It, T> {
            if self._peeked.is_none() {
                self._peeked = self._it.next();
                if self._peeked.is_some(){
                    self._peeked
                } else {
                    self._peeked_back
                }
            } else {
                self._peeked
            }
        } else {
            if self._peeked.is_none() {
                self._peeked = self._it.next();
            }
            self._peeked
        }
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &PeekableIterator<It, T>) -> Option<usize> {
        self._it.size_hint().map(|=self, x: usize| -> usize {
            when *self._it is DoubleEndedIterator<It, T> {
                x
                + (self._peeked.is_some() as usize)
                + (self._peeked_back.is_some() as usize)
            } else {
                if self._peeked.is_some() {
                    x + 1
                } else {
                    x
                }
            }
        })
    }

    mixin Iterator<PeekableIterator<It, T>, T>;
    mixin IteratorExt<PeekableIterator<It, T>, T>;
}

impl PeekableIterator<It: DoubleEndedIterator<It, T>, T> {
    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut PeekableIterator<It, T>) -> Option<T> {
        if self._peeked_back.is_some() {
            self._peeked_back.move()
        } else {
            let next_back = self._it.next_back();
            if next_back.is_none() {
                self._peeked.move()
            } else {
                next_back
            }
        }
    }

    /// Return the next element from the back in the iterator without consuming it.
    fn peek_back(self: &mut PeekableIterator<It, T>) -> Option<T> {
        if self._peeked_back.is_none() {
            self._peeked_back = self._it.next_back();
            if self._peeked_back.is_some(){
                self._peeked_back
            } else {
                self._peeked
            }
        } else {
            self._peeked_back
        }
    }

    mixin DoubleEndedIterator<PeekableIterator<It, T>, T>;
    mixin DoubleEndedIteratorExt<PeekableIterator<It, T>, T>;
}

/// Zip iterator
///
/// See [IteratorExt::zip].
struct ZipIterator<It1: Iterator<It1, T1>, It2: Iterator<It2, T2>, T1, T2> {
    _it1: &mut It1,
    _it2: &mut It2,
}

impl ZipIterator<It1: Iterator<It1, T1>, It2: Iterator<It2, T2>, T1, T2> {
    /// @ Iterator::next
    fn next(self: &mut ZipIterator<It1, It2, T1, T2>) -> Option<(T1, T2)> {
        self._it1.next().zip(self._it2.next())
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &ZipIterator<It1, It2, T1, T2>,) -> Option<usize> {
        self._it1.size_hint()
            .zip(self._it2.size_hint())
            .map(|v: (usize, usize)| -> usize {
                std::cmp::min(v.0, v.1)
            })
    }

    mixin Iterator<ZipIterator<It1, It2, T1, T2>, (T1, T2)>;
    mixin IteratorExt<ZipIterator<It1, It2, T1, T2>, (T1, T2)>;
}

/// Flatten iterator
///
/// See [IteratorExt::flatten].
struct FlattenIterator<It: Iterator<It, T>, T, Ret> {
    _it: &mut It,
    _elem: Option<T>,
    _elem_iter: typeof((null as &mut T).iter()) // maybe uninitialized
}

impl FlattenIterator<It: Iterator<It, T>, T, Ret> {
    /// @ Iterator::next
    fn next(self: &mut FlattenIterator<It, T, Ret>) -> Option<Ret> {
        use option::try;

        loop {
            if self._elem.is_none() {
                // We store the element, as the iterator may require a stable pointer to it.
                self._elem = Option::some(self._it.next()?);
                self._elem_iter = self._elem
                    .as_mut_ptr()
                    .unwrap()
                    .iter();
            }

            let v = self._elem_iter.next();
            if v.is_some() {
                return v;
            } else {
                self._elem = Option::none()
            }
        }
    }

    mixin Iterator<FlattenIterator<It, T, Ret>, Ret>;
    mixin IteratorExt<FlattenIterator<It, T, Ret>, Ret>;
}

/// Type of the element that an [Iterable] yields.
/// ```
/// use std::collections::Vector;
/// use std::iter::iterable_yield_t;
///
/// let v: Vector<&[u8]> = Vector::new();
/// defer v.free();
///
/// v.push("Hello, world!");
///
/// let v: iterable_yield_t<Vector<&[u8]>> /* = &[u8] */ = v.iter().next().unwrap();
/// ```
type iterable_yield_t<T> = typeof((null as &mut T).iter().next()._inner);

/// Type of the element that an [Iterator] yields.
///
/// ## Example
/// ```
/// use std::iter::iterator_yield_t;
/// use std::range::Range;
///
/// let _: iterator_yield_t<Range<i32>>; // = i32
/// ```
type iterator_yield_t<T> = typeof((null as &mut T).next()._inner);

/// Extension mixin for [Iterator] types.
///
/// Contains various useful combinators and functions to work with iterators.
///
/// All structs that implement [Iterator] should also mix in this protocol.
protocol IteratorExt<Self: Iterator<Self, T>, T> {
    /// Return self.
    ///
    /// Each iterator is itself an [iterable](Iterable) object, though only once. This
    /// helper function is there so that iterators can be used ergonomically
    /// in for loops (which de-sugar to a call to `.iter()`)
    ///
    /// See also [Iterable::iter].
    fn iter(self: &mut Self) -> &mut Self {
        self
    }

    /// Return an iterator that returns `Option::none()` forever after the
    /// first one is returned.
    ///
    /// Iterators can validly reset back to returning values after they are
    /// exhausted. This method "caps it off" after they are first exhausted.
    fn fuse(self: &mut Self) -> FusedIterator<Self, T> {
        FusedIterator {
            _done: false,
            _it: self
        }
    }

    /// Returns an iterator that yields all elements of `self` and then all elements of `other`.
    /// ## Example
    /// ```
    /// let range = (0..2).chain(&(10..12));
    /// assert_eq!(range.size_hint(), Option::some(4usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(1));
    /// assert_eq!(range.next(), Option::some(10));
    /// assert_eq!(range.next(), Option::some(11));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn chain<Other: Iterator<Other, T>>(self: &mut Self, other: &mut Other) -> ChainIterator<Self, Other, T> {
        ChainIterator {
            _it1: FusedIterator { _done: false, _it: self },
            _it2: FusedIterator { _done: false, _it: other }
        }
    }

    /// Returns an iterator that merges two sorted iterators into one sorted iterator.
    ///
    /// `T` must implement [cmp::Comparable]. If the two iterators are not sorted, the
    /// resulting order is unspecified.
    ///
    /// The merge is stable, meaning that the order of equal elements is preserved, with
    /// the elements from `self` coming before the elements from `other` (and vice-versa
    /// if the iterator is reversed/used with [DoubleEndedIterator::next_back]).
    ///
    /// ## Example
    /// ```
    /// let range = [0, 2, 4].iter().merge_sorted(&[1, 3].iter());
    /// assert_eq!(range.size_hint(), Option::some(5usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(1));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(3));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn merge_sorted<Other: Iterator<Other, T>>(self: &mut Self, other: &mut Other) -> MergeIterator<Self, Other, T> {
        MergeIterator {
            _it1: Option::some(self.peekable()),
            _it2: Option::some(other.peekable())
        }
    }

    /// Returns an iterator that skips first `n` values.
    ///
    /// If the underlying iterator yields fewer than or exactly `n` values, then the
    /// iterator will yield no values.
    ///
    /// ## Example
    /// ```
    /// let range = (0..5).skip(2);
    /// assert_eq!(range.size_hint(), Option::some(3usize));
    ///
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(3));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn skip(self: &mut Self, n: usize) -> SkipIterator<Self, T> {
        SkipIterator {
            _it: self,
            _n: n,
        }
    }

    /// Returns an iterator that steps by `n` values.
    ///
    /// First value will always be yielded, then every `n`-th value.
    /// ## Example
    /// ```
    /// let range = (0..5).step_by(2);
    /// assert_eq!(range.size_hint(), Option::some(3usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn step_by(self: &mut Self, n: usize) -> StepByIterator<Self, T> {
        assert!(n > 0);

        StepByIterator {
            _it: self,
            _index: n - 1,
            _n: n,
        }
    }

    /// Returns an iterator that yields at most `n` elements.

    /// ## Example
    /// ```
    /// let range = (0..5).take(2);
    /// assert_eq!(range.size_hint(), Option::some(2usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(1));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn take(self: &mut Self, n: usize) -> TakeIterator<Self, T> {
        TakeIterator {
            _it: self,
            _n: n,
        }
    }

    /// Returns an iterator that attaches a sequence number of each item.
    ///
    /// ## Example
    /// ```
    /// let range = (10..15).enumerate();
    /// assert_eq!(range.size_hint(), Option::some(5usize));
    ///
    /// assert_eq!(range.next(), Option::some((0usize, 10)));
    /// assert_eq!(range.next(), Option::some((1usize, 11)));
    /// assert_eq!(range.next(), Option::some((2usize, 12)));
    /// assert_eq!(range.next(), Option::some((3usize, 13)));
    /// assert_eq!(range.next(), Option::some((4usize, 14)));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn enumerate(self: &mut Self) -> EnumerateIterator<Self, T> {
        EnumerateIterator {
            _it: self,
            _n: 0,
        }
    }

    /// Returns the last value of the iterator.
    ///
    /// This method always exhausts the iterator. For iterators that implement [DoubleEndedIterator],
    /// it may be more efficient to use [DoubleEndedIterator::next_back].
    ///
    /// ## Example
    /// ```
    /// let last = (0..5).last();
    ///
    /// assert_eq!(last, Option::some(4));
    /// ```
    fn last(self: &mut Self) -> Option<T> {
        let value: Option<T> = Option::none();
        loop {
            let next = self.next();
            if next.is_some() {
                value = next;
            } else {
                return value;
            }
        }
    }

    /// Returns the `n`-th value of the iterator.
    ///
    /// ## Example
    /// ```
    /// let nth = (10..100).nth(2);
    ///
    /// assert_eq!(nth, Option::some(12));
    /// ```
    fn nth(self: &mut Self, n: usize) -> Option<T> {
        use option::try;
        for _ in 0usize..n {
            self.next()?;
        }
        self.next()
    }

    /// Counts the number of elements in this iterator.
    ///
    /// ## Example
    /// ```
    /// let count = (100..105).count();
    ///
    /// assert_eq!(count, 5);
    /// ```
    fn count(self: &mut Self) -> usize {
        let n = 0usize;
        loop {
            if self.next().is_none() {
                return n;
            }
            n += 1;
        }
    }

    /// Inspects each element of the iterator.
    ///
    /// Presented chain of iterator combinators, [inspect] can be used to execute
    /// a callback on every element of an iterator. This is useful for debugging.
    ///
    /// The elements are passed through unmodified.
    /// ## Example
    /// ```
    /// let last = (0..3)
    ///     .iter()
    ///     .inspect(|i: i32| { println!("I see {}", i) })
    ///     .last();
    ///
    /// println!("Last: {}", last);
    ///
    /// // Prints:
    /// // I see 0
    /// // I see 1
    /// // I see 2
    /// // Last: 2
    /// ```
    fn inspect<F: Fn(T)>(it: &mut Self, func: F) -> InspectIterator<Self, F, T> {
        InspectIterator {
            _it: it,
            _func: func,
        }
    }

    /// Returns an iterator that yields the elements while a predicate is true.
    ///
    /// ## Example
    /// ```
    /// let range = (0..5).take_while(|x: i32| -> bool { x < 3 });
    /// assert_eq!(range.size_hint(), Option::none());
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(1));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn take_while<F: Fn(T) -> bool>(iter: &mut Self, fun: F) -> TakeWhileIterator<Self, F, T> {
        TakeWhileIterator { _it: iter, _fun: fun }
    }

    /// Returns an iterator that skips the elements while a predicate is true.
    /// ## Example
    /// ```
    /// let range = (0..5).skip_while(|x: i32| -> bool { x < 3 });
    /// assert_eq!(range.size_hint(), Option::none());
    ///
    /// assert_eq!(range.next(), Option::some(3));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn skip_while<F: Fn(T) -> bool>(iter: &mut Self, fun: F) -> SkipWhileIterator<Self, F, T> {
        SkipWhileIterator { _it: iter, _fun: fun, _finished: false }
    }

    /// Returns an iterator that transforms the elements of this iterator.
    /// ## Example
    /// ```
    /// let range = (0..5).map(|x: i32| -> i32 { x * 2 });
    /// assert_eq!(range.size_hint(), Option::some(5usize));
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::some(6));
    /// assert_eq!(range.next(), Option::some(8));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn map<U, F: Fn(T) -> U>(iter: &mut Self, fun: F) -> MapIterator<Self, F, T, U> {
        MapIterator { _it: iter, _fun: fun }
    }

    /// Executes a function on each element of this iterator.
    ///
    /// For readability, it is usually better to use the `for` loop, but `foreach` can be useful in cases
    /// where a function allocates memory which can be then freed using a `defer` expression.
    /// ## Example
    /// ```
    /// use std::fmt::format;
    ///
    /// (0..5)
    ///     .iter()
    ///     .foreach(|x: i32| {
    ///         let f = format!("{}", x).unwrap();
    ///         defer f.free();
    ///
    ///         println!("{}", f[..]);
    ///     });
    /// ```
    fn foreach<F: Fn(T)>(iter: &mut Self, fun: F) {
        loop {
            let val = iter.next();
            if val.is_some() {
                fun(val.unwrap());
            } else {
                break;
            }
        }
    }

    /// Returns an iterator that yields the elements of this iterator that match a predicate.
    ///
    /// ## Example
    /// ```
    /// let range = (0..5).filter(|x: i32| -> bool { x % 2 == 0 });
    /// assert_eq!(range.size_hint(), Option::none());
    ///
    /// assert_eq!(range.next(), Option::some(0));
    /// assert_eq!(range.next(), Option::some(2));
    /// assert_eq!(range.next(), Option::some(4));
    /// assert_eq!(range.next(), Option::none());
    /// ```
    fn filter<F: Fn(T) -> bool>(iter: &mut Self, fun: F) -> FilterIterator<Self, F, T> {
        FilterIterator { _it: iter, _fun: fun }
    }

    /// Returns the first item matching the predicate.
    ///
    /// If there is no item matching the predicate, returns none.
    ///
    /// ## Example
    /// ```
    /// let a = (1..10).find(|x: i32| -> bool { x * x >= 50 });
    /// let b = (1..10).find(|x: i32| -> bool { x * x >= 1000 });
    ///
    /// assert_eq!(a, Option::some(8));
    /// assert_eq!(b, Option::none());
    /// ```
    fn find<F: Fn(T) -> bool>(iter: &mut Self, fun: F) -> Option<T> {
        iter.filter(fun).next()
    }

    /// Returns the index of the first item matching the predicate.
    ///
    /// If there is no item matching the predicate, returns none.
    ///
    /// ## Example
    /// ```
    /// let arr = [1, 2, 3, 1337, 5, 6];
    ///
    /// let idx = arr
    ///     .iter()
    ///     .find_index(|x: i32| -> bool { x > 100 })
    ///     .unwrap();
    ///
    /// println!("First number larger than 100: {}", arr[idx]);
    /// ```
    fn find_index<F: Fn(T) -> bool>(iter: &mut Self, fun: F) -> Option<usize> {
        let idx = 0usize;
        for v in iter {
            if fun(v) {
                return Option::some(idx);
            }
            idx += 1;
        }
        Option::none()
    }

    /// Transforms and filters the iterator at the same time.
    ///
    /// Function `f` is called on each element of this iterator. If it returns `Option::some(...)`,
    /// that element is yielded. If it returns `Option::none()`, the element is skipped.
    ///
    /// ## Example
    /// ```
    /// let range = (0..6)
    ///     .iter()
    ///     .filter_map(|x: i32| -> Option<i32> {
    ///         if x % 2 == 1 {
    ///             Option::some(x * 100)
    ///         } else {
    ///             Option::none()
    ///         }
    ///     });
    ///
    /// assert_eq!(range.next(), Option::some(100));
    /// assert_eq!(range.next(), Option::some(300));
    /// assert_eq!(range.next(), Option::some(500));
    /// ```
    fn filter_map<U, F: Fn(T) -> Option<U>>(iter: &mut Self, fun: F) -> FilterMapIterator<Self, F, T, U> {
        FilterMapIterator { _it: iter, _fun: fun }
    }


    /// Returns an iterator of chunks of size `chunk_size`.
    ///
    /// If the iterator is not divisible by `chunk_size`, the last chunk will be smaller. Panics if
    /// `chunk_size` is 0.
    ///
    /// ## Example
    /// ```
    /// // Prints:
    /// // [ 0 1 2 ]
    /// // [ 3 4 5 ]
    /// // [ 6 ]
    /// for chunk in (0..7).chunks(3) {
    ///     print!("[ ");
    ///     for v in chunk {
    ///         print!("{} ", v);
    ///     }
    ///     println!("]");
    /// }
    /// ```
    fn chunks(self: &mut Self, chunk_size: usize) -> ChunksIterator<Self, T> {
        assert!(chunk_size > 0);

        ChunksIterator {
            _it: self.peekable(),
            _last_chunk: Option::none(),
            _chunk_size: chunk_size,
        }
    }

    /// Reduces the iterator into a single value.
    ///
    /// Equivalent to:
    /// ```pseudo_alumina
    /// let value = initial;
    /// for element in iter {
    ///     value = func(value, element);
    /// }
    /// ```
    /// ## Example
    /// ```
    /// let sum = (0..5)
    ///     .iter()
    ///     .reduce(0, |acc: i32, x: i32| -> i32 { acc + x });
    ///
    /// println!("{}", sum); // Prints: 10
    /// ```
    fn reduce<U, F: Fn(U, T) -> U>(iter: &mut Self, initial: U, func: F) -> U {
        loop {
            let next = iter.next();
            if next.is_none() {
                break
            }
            initial = func(initial, next.unwrap());
        }
        initial
    }

    /// Sums all the values in the iterator.
    ///
    /// `T` must satisfy [builtins::Numeric] protocol.
    /// ## Example
    /// ```
    /// let sum = (0..5).sum();
    ///
    /// assert_eq!(sum, 10);
    /// ```
    fn sum(iter: &mut Self) -> T {
        iter.reduce(0 as T, internal::iter_plus::<T>)
    }

    /// Returns the minimum value of the iterator.
    ///
    /// `T` must satisfy [cmp::Comparable] protocol.
    /// ## Example
    /// ```
    /// let min = [1, -5, 10, 200].iter().min();
    ///
    /// assert_eq!(min, Option::some(-5));
    /// ```
    fn min(iter: &mut Self) -> Option<T> {
        iter.reduce(Option::none::<T>(), internal::iter_min::<T>)
    }

    /// Returns the maximum value of the iterator.
    ///
    /// `T` must satisfy [cmp::Comparable] protocol.
    /// ## Example
    /// ```
    /// let max = [1, -5, 10, 200].iter().max();
    ///
    /// assert_eq!(max, Option::some(200));
    /// ```
    fn max(iter: &mut Self) -> Option<T> {
        iter.reduce(Option::none::<T>(), internal::iter_max::<T>)
    }

    /// Returns `true` if all elements of the iterator match a predicate, `false` otherwise.
    ///
    /// If iterator produces no values, `true` is returned.
    /// ## Example
    /// ```
    /// let t1 = [1, -5, 10, 200].iter().all(|x: i32| -> bool { x > 0 });
    /// let t2 = [1, -5, 10, 200].iter().all(|x: i32| -> bool { x < 1000 });
    ///
    /// assert!(!t1);
    /// assert!(t2);
    /// ```
    fn all<F: Fn(T) -> bool>(iter: &mut Self, fun: F) -> bool {
        loop {
            let next = iter.next();
            if next.is_none() {
                break
            }
            if !fun(next.unwrap()) {
                return false
            }
        }
        true
    }

    /// Returns `true` if any element of the iterator matches a predicate, `false` otherwise.
    ///
    /// If iterator produces no values, `false` is returned.
    /// ## Example
    /// ```
    /// let t1 = [1, -5, 10, 200].iter().any(|x: i32| -> bool { x > 1000 });
    /// let t2 = [1, -5, 10, 200].iter().any(|x: i32| -> bool { x < 0 });
    ///
    /// assert!(!t1);
    /// assert!(t2);
    /// ```
    fn any<F: Fn(T) -> bool>(iter: &mut Self, fun: F) -> bool {
        loop {
            let next = iter.next();
            if next.is_none() {
                break
            }
            if fun(next.unwrap()) {
                return true
            }
        }
        false
    }

    /// Collects the values of the iterator into a vector.
    ///
    /// ## Example
    /// ```
    /// let range = (0..5).to_vector();
    /// defer range.free();
    ///
    /// assert_eq!(range.len(), 5);
    /// assert_eq!(range[..], &[0, 1, 2, 3, 4]);
    /// ```
    fn to_vector(self: &mut Self) -> collections::Vector<T> {
        collections::Vector::from_iter::<T, Self>(self)
    }

    /// Fills the slice with the values of the iterator.
    ///
    /// If the number of elements in the iterator is greater than the length of the
    /// slice, the remaining values in the iterator are not consumed.
    ///
    /// If the number of elements in the iterator is less than the length of the
    /// slice, the remainder of the slice is untouched.
    ///
    /// ## Example
    /// ```
    /// let buf: [i32; 5];
    /// (0..5).fill_slice(buf[..]);
    ///
    /// assert_eq!(buf[..], &[0, 1, 2, 3, 4]);
    /// ```
    fn fill_slice(self: &mut Self, slice: &mut [T]) -> usize {
        let index = 0usize;
        loop {
            if slice.len() <= index {
                break;
            }
            let next = self.next();
            if next.is_none() {
                break;
            }
            slice[index] = next.unwrap();
            index += 1;
        }

        index
    }

    /// Returns a "peekable" iterator.
    ///
    /// Peekable iterators have an additional method, [PeekableIterator::peek], which is similar to
    /// [Iterator::next], but it does not consume the value, so a subsequent call to
    /// [Iterator::next] will return the same value.
    fn peekable(self: &mut Self) -> PeekableIterator<Self, T> {
        PeekableIterator {
            _it: self,
            _peeked: Option::none(),
            _peeked_back: when *self is DoubleEndedIterator<Self, T> {
                Option::none()
            } else {
                ()
            }
        }
    }


    /// Returns an iterator of groups grouped by a key.
    ///
    /// Requires that the items of the iterator that have the same key are contiguous (e.g.
    /// the values are sorted by key).
    ///
    /// ## Example
    /// ```
    /// fn divide_by_three(x: i32) -> i32 { x / 3 }
    ///
    /// for group in (0..10).group_by(divide_by_three) {
    ///     print!("{}:", group.key);
    ///     for value in group {
    ///         print!(" {}", value);
    ///     }
    ///     println!("");
    /// }
    ///
    /// // Prints:
    /// // 0: 0 1 2
    /// // 1: 3 4 5
    /// // 2: 6 7 8
    /// // 3: 9
    /// ```
    fn group_by<F: Fn(T) -> K, K: cmp::Equatable<K>>(self: &mut Self, func: F) -> GroupByIterator<Self, F, T, K> {
        GroupByIterator {
            _it: self.peekable(),
            _last_group: Option::none(),
            _func: func
        }
    }

    /// Combines two iterators, returning an iterator of pairs.
    ///
    /// ## Example
    /// ```
    /// let iter = (0..5).zip(&(10..15));
    ///
    /// assert_eq!(iter.size_hint(), Option::some(5usize));
    ///
    /// assert_eq!(iter.next(), Option::some((0, 10)));
    /// assert_eq!(iter.next(), Option::some((1, 11)));
    /// assert_eq!(iter.next(), Option::some((2, 12)));
    /// assert_eq!(iter.next(), Option::some((3, 13)));
    /// assert_eq!(iter.next(), Option::some((4, 14)));
    /// assert_eq!(iter.next(), Option::none());
    /// ```
    fn zip<Other>(self: &mut Self, other: &mut Other) -> ZipIterator<Self, Other, T, iterator_yield_t<Other>> {
        ZipIterator {
            _it1: self,
            _it2: other,
        }
    }

    /// Flattens an iterator over iterable types into a single iterator.
    ///
    /// ## Example
    /// ```
    /// let iter = ["Hello", " ", "World"].iter().flatten();
    ///
    /// let v = iter.to_vector();
    /// defer v.free();
    ///
    /// assert_eq!(v[..], &['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']);
    /// ```
    fn flatten(self: &mut Self) -> FlattenIterator<Self, T, iterable_yield_t<T>> {
        FlattenIterator {
            _it: self,
            _elem: Option::none(),
            _elem_iter: mem::uninitialized()
        }
    }
}

/// An empty iterator.
///
/// See [empty] for details.
struct EmptyIterator<T> {}

impl EmptyIterator<T> {
    /// @ Iterator::next
    #[inline]
    fn next(self: &mut EmptyIterator<T>) -> Option<T> {
        Option::none()
    }

    /// @ DoubleEndedIterator::next_back
    #[inline]
    fn next_back(self: &mut EmptyIterator<T>) -> Option<T> {
        Option::none()
    }

    /// @ Iterator::size_hint
    #[inline]
    fn size_hint(self: &EmptyIterator<T>) -> Option<usize> {
        Option::some(0usize)
    }

    mixin Iterator<EmptyIterator<T>, T>;
    mixin IteratorExt<EmptyIterator<T>, T>;
    mixin DoubleEndedIterator<EmptyIterator<T>, T>;
    mixin DoubleEndedIteratorExt<EmptyIterator<T>, T>;
}

/// A function wrapped in an iterator.
///
/// See [from_fn] for details.
struct FromFnIterator<F: Fn() -> Option<T>, T> {
    _func: F,
}

impl FromFnIterator<F: Fn() -> Option<T>, T> {
    /// @ Iterator::next
    fn next(self: &mut FromFnIterator<F, T>) -> Option<T> {
        self._func()
    }

    mixin Iterator<FromFnIterator<F, T>, T>;
    mixin IteratorExt<FromFnIterator<F, T>, T>;
}

/// Returns an iterator that produces no elements.
///
/// ## Example
/// ```
/// let range = std::iter::empty::<()>();
///
/// assert_eq!(range.next(), Option::none());
/// ```
fn empty<T>() -> EmptyIterator<T> {
    EmptyIterator::<T> {}
}

/// Wraps a function in an iterator.
///
/// ## Example
/// ```
/// use std::iter::from_fn;
/// use std::random::thread_rng;
///
/// let sqrt2 = from_fn(|| -> Option<f64> {
///     Option::some(thread_rng().next_float())
/// })
///     .map(|v: f64| -> f64 { v * 10.0 })
///     .filter(|v: f64| -> bool { v * v <= 2.0 })
///     .take(100000)
///     .max()
///     .unwrap();
///
/// println!("{}", sqrt2); // Prints approximately 1.4142135623730951
/// ```
fn from_fn<F: Fn() -> Option<T>, T>(func: F) -> FromFnIterator<F, T> {
    FromFnIterator::<F, T> { _func: func }
}

/// Iterator that repeats a value infinitely.
///
/// See [repeat] for more details.
struct RepeatIterator<T> {
    _value: T
}

impl RepeatIterator<T> {
    /// @ Iterator::next
    fn next(self: &mut RepeatIterator<T>) -> Option<T> {
        Option::some(self._value)
    }

    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut RepeatIterator<T>) -> Option<T> {
        Option::some(self._value)
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &RepeatIterator<T>) -> Option<usize> {
        Option::some(usize::max_value())
    }

    mixin Iterator<RepeatIterator<T>, T>;
    mixin IteratorExt<RepeatIterator<T>, T>;
}

/// Returns an iterator that repeats the same value indefinitely.
///
/// ## Example
/// ```
/// let range = std::iter::repeat(42);
///
/// assert_eq!(range.next(), Option::some(42));
/// assert_eq!(range.next(), Option::some(42));
/// assert_eq!(range.next(), Option::some(42));
/// // ...
/// ```
fn repeat<T>(value: T) -> RepeatIterator<T> {
    RepeatIterator { _value: value }
}

/// Iterator that yields a single value
///
/// See [once] for more details.
struct OnceIterator<T> {
    _value: Option<T>
}

impl OnceIterator<T> {
    /// @ Iterator::next
    fn next(self: &mut OnceIterator<T>) -> Option<T> {
        self._value.move()
    }

    /// @ DoubleEndedIterator::next_back
    fn next_back(self: &mut OnceIterator<T>) -> Option<T> {
        self._value.move()
    }

    /// @ Iterator::size_hint
    fn size_hint(self: &OnceIterator<T>) -> Option<usize> {
        if self._value.is_some() {
            Option::some(1usize)
        } else {
            Option::some(0usize)
        }
    }

    mixin Iterator<OnceIterator<T>, T>;
    mixin IteratorExt<OnceIterator<T>, T>;
}

/// Returns an iterator that repeats a single element exactly once.
///
/// ## Example
/// ```
/// let iter = std::iter::once(42);
///
/// assert_eq!(iter.next(), Option::some(42));
/// assert_eq!(iter.next(), Option::none());
/// ```
fn once<T>(value: T) -> OnceIterator<T> {
    OnceIterator { _value: Option::some(value) }
}

#[docs(no_index)]
mod internal {
    use builtins::Numeric;
    use cmp::Comparable;

    // See IteratorExt::sum
    fn iter_plus<T: builtins::Numeric>(a: T, b: T) -> T {
        a + b
    }

    // See IteratorExt::min
    fn iter_min<T: Comparable<T>>(a: Option<T>, b: T) -> Option<T> {
        if a.is_none() || a.unwrap() > b {
            Option::some(b)
        } else {
            a
        }
    }

    // See IteratorExt::max
    fn iter_max<T: Comparable<T>>(a: Option<T>, b: T) -> Option<T> {
        if a.is_none() || a.unwrap() < b {
            Option::some(b)
        } else {
            a
        }
    }

    #[lang(static_for_iter)]
    fn static_for_iter<T>(val: &mut T) -> typeof(val.iter()) {
        val.iter()
    }

    #[lang(static_for_next)]
    fn static_for_next<T>(iter: &mut T) -> iterator_yield_t<T> {
        let res = iter.next();
        if res.is_some() {
            res._inner
        } else {
            intrinsics::stop_iteration();
        }
    }

}


#[cfg(all(test, test_std))]
#[docs(hide)]
mod tests {
    #[test]
    fn test_map() {
        let range = (0..5).map(|x: i32| -> i32 { x * 2 });
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(6));
        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_map_rev() {
        let range = (0..5).map(|x: i32| -> i32 { x * 2 }).rev();
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::some(6));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter() {
        let range = (0..5).filter(|x: i32| -> bool { x % 2 == 0 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter_rev() {
        let range = (0..5).filter(|x: i32| -> bool { x % 2 == 0 }).rev();
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter_map() {
        let range = (0..5).filter_map(|x: i32| -> Option<i32> {
            if x % 2 == 0 {
                Option::some(x * 2)
            } else {
                Option::none()
            }
        });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_filter_map_rev() {
        let range = (0..5).filter_map(|x: i32| -> Option<i32> {
            if x % 2 == 0 {
                Option::some(x * 2)
            } else {
                Option::none()
            }
        }).rev();
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(8));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_reduce() {
        let range = (0..5).reduce(0, |acc: i32, x: i32| -> i32 {
            acc + x
        });
        assert_eq!(range, 10);
    }

    #[test]
    fn test_empty() {
        let range = empty::<()>();
        assert_eq!(range.size_hint(), Option::some(0usize));

        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_all() {
        assert_eq!(empty::<i32>().all(|v: i32| -> bool { v > 10 }), true);
        assert_eq!((0..5).all(|v: i32| -> bool { v > 10 }), false);
        assert_eq!((0..5).all(|v: i32| -> bool { v >= 0 }), true);
    }

    #[test]
    fn test_any() {
        assert_eq!(empty::<i32>().any(|v: i32| -> bool { v > 10 }), false);
        assert_eq!((0..5).any(|v: i32| -> bool { v > 3 }), true);
        assert_eq!((0..5).any(|v: i32| -> bool { v > 10 }), false);
    }

    #[test]
    fn test_repeat() {
        let range = repeat(1);
        assert_eq!(range.size_hint(), Option::some(usize::max_value()));

        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(1));
        // ...
    }

    #[test]
    fn test_skip() {
        let range = (0..5).skip(2);
        assert_eq!(range.size_hint(), Option::some(3usize));

        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
        // ...
    }

    #[test]
    fn test_take() {
        let range = (0..5).take(2);
        assert_eq!(range.size_hint(), Option::some(2usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_count() {
        assert_eq!((0..5).count(), 5usize);
    }

    #[test]
    fn test_last() {
        assert_eq!((0..5).last(), Option::some(4));
        assert_eq!(empty::<i32>().last(), Option::none());
    }

    #[test]
    fn test_chain() {
        let range = (0..2).chain(&(10..12));
        assert_eq!(range.size_hint(), Option::some(4usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(10));
        assert_eq!(range.next(), Option::some(11));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_chain_rev() {
        let range = (0..2).chain(&(10..12)).rev();
        assert_eq!(range.size_hint(), Option::some(4usize));

        assert_eq!(range.next(), Option::some(11));
        assert_eq!(range.next(), Option::some(10));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_enumerate() {
        let range = (10..15).enumerate();
        assert_eq!(range.size_hint(), Option::some(5usize));

        assert_eq!(range.next(), Option::some((0usize, 10)));
        assert_eq!(range.next(), Option::some((1usize, 11)));
        assert_eq!(range.next(), Option::some((2usize, 12)));
        assert_eq!(range.next(), Option::some((3usize, 13)));
        assert_eq!(range.next(), Option::some((4usize, 14)));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_foreach() {
        let sum = 0;
        (0..5).foreach(|&sum, x: i32| {
            sum += x;
        });

        assert_eq!(sum, 10);
    }

    #[test]
    fn test_inspect() {
        let sum1 = 0;
        let sum2 = 0;
        let sum3 = 0;
        (0..5)
            .iter()
            .inspect(|&sum1, x: i32| { sum1 += x })
            .inspect(|&sum2, x: i32| { sum2 += x * x })
            .inspect(|&sum3, x: i32| { sum3 += x * x * x })
            .count();

        assert_eq!(sum1, 10);
        assert_eq!(sum2, 30);
        assert_eq!(sum3, 100);
    }

    #[test]
    fn test_to_vector() {
        let vec = (0..5).to_vector();
        assert_eq!(vec[..], &[0, 1, 2, 3, 4]);
    }

    #[test]
    fn test_take_while() {
        let range = (0..5).take_while(|x: i32| -> bool { x < 3 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_skip_while() {
        let range = (0..5).skip_while(|x: i32| -> bool { x < 3 });
        assert_eq!(range.size_hint(), Option::none());

        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_step_by() {
        let range = (0..5).step_by(2);
        assert_eq!(range.size_hint(), Option::some(3usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_nth() {
        assert_eq!((0..5).nth(0), Option::some(0));
        assert_eq!((0..5).nth(1), Option::some(1));
        assert_eq!((0..5).nth(10), Option::none());
    }

    #[test]
    fn test_once() {
        let range = once(0);
        assert_eq!(range.size_hint(), Option::some(1usize));

        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn fill_slice() {
        let buf: [i32; 10];

        let written = (0..5).fill_slice(&buf);
        assert_eq!(written, 5);
        assert_eq!(buf[..5], &[0, 1, 2, 3, 4]);

        let written = (10..200).fill_slice(&buf);
        assert_eq!(written, 10);
        assert_eq!(buf[..], &[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);
    }

    #[test]
    fn test_peekable() {
        let range = (0..3).peekable();
        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.peek(), Option::some(0));

        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_peekable_rev() {
        let range = (0..3).peekable();
        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.peek_back(), Option::some(2));

        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.next_back(), Option::some(2));
        assert_eq!(range.next_back(), Option::some(1));
        assert_eq!(range.next_back(), Option::some(0));
        assert_eq!(range.next_back(), Option::none());
    }

    #[test]
    fn test_peekable_bidirectional() {
        let range = (0..3).peekable();
        assert_eq!(range.size_hint(), Option::some(3usize));

        assert_eq!(range.peek(), Option::some(0));
        assert_eq!(range.peek_back(), Option::some(2));

        assert_eq!(range.size_hint(), Option::some(3usize));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next_back(), Option::some(2));

        assert_eq!(range.size_hint(), Option::some(1usize));
        assert_eq!(range.peek(), Option::some(1));
        assert_eq!(range.peek_back(), Option::some(1));

        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next_back(), Option::none());

        assert_eq!(range.size_hint(), Option::some(0usize));
    }

    #[test]
    fn test_group_by() {
        let values: &[(i32, i32)] = &[
            (0, 0),
            (1, 0),
            (1, 1),
            (2, 0),
            (2, 1),
            (2, 2)
        ];

        let groups = values.iter().group_by(|v: (i32, i32)| -> i32 { v.0 });

        assert_eq!(groups.size_hint(), Option::none());
        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((0, 0)));
        assert_eq!(group.next(), Option::none());

        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((1, 0)));
        assert_eq!(group.next(), Option::some((1, 1)));
        assert_eq!(group.next(), Option::none());

        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((2, 0)));
        assert_eq!(group.next(), Option::some((2, 1)));
        assert_eq!(group.next(), Option::some((2, 2)));
        assert_eq!(group.next(), Option::none());

        assert!(groups.next().is_none());
    }

    #[test]
    fn test_group_by_draining() {
        let values: &[(i32, i32)] = &[
            (0, 0),
            (1, 0),
            (1, 1),
            (2, 0),
            (2, 1),
            (2, 2)
        ];

        let groups = values.iter().group_by(|v: (i32, i32)| -> i32 { v.0 });

        assert_eq!(groups.size_hint(), Option::none());
        groups.next().unwrap();
        groups.next().unwrap();
        let group = groups.next().unwrap();
        assert_eq!(group.next(), Option::some((2, 0)));
        assert_eq!(group.next(), Option::some((2, 1)));
        assert_eq!(group.next(), Option::some((2, 2)));
        assert_eq!(group.next(), Option::none());

        assert!(groups.next().is_none());
    }

    #[test]
    fn test_rev() {
        let range = (0..5).rev();
        assert_eq!(range.size_hint(), Option::some(5usize));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());

        let range = (0..5).rev().rev();
        assert_eq!(range.size_hint(), Option::some(5usize));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::none());

        let range = [0, 1, 2, 3, 4].iter().rev();
        assert_eq!(range.size_hint(), Option::some(5usize));
        assert_eq!(range.next(), Option::some(4));
        assert_eq!(range.next(), Option::some(3));
        assert_eq!(range.next(), Option::some(2));
        assert_eq!(range.next(), Option::some(1));
        assert_eq!(range.next(), Option::some(0));
        assert_eq!(range.next(), Option::none());
    }

    #[test]
    fn test_from_fn() {
        let index = 5;
        let iter = from_fn(|&index| -> Option<i32> {
            if index == 0 {
                Option::none()
            } else {
                index -= 1;
                Option::some(index)
            }
        });

        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(0));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_fuse() {
        let index = 0;
        let iter = from_fn(|&index| -> Option<()> {
            index += 1;
            if index % 2 == 0 {
                Option::none()
            } else {
                Option::some(())
            }
        }).fuse();

        assert_eq!(iter.next(), Option::some(()));
        assert_eq!(iter.next(), Option::none());
        assert_eq!(iter.next(), Option::none());
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_sum() {
        assert_eq!(empty::<i32>().sum(), 0);
        assert_eq!((0..5).sum(), 10);
    }

    #[test]
    fn test_min() {
        assert_eq!(empty::<i32>().min(), Option::none());
        assert_eq!((0..5).min(), Option::some(0));
    }

    #[test]
    fn test_max() {
        assert_eq!(empty::<i32>().max(), Option::none());
        assert_eq!((0..5).max(), Option::some(4));
    }

    #[test]
    fn test_zip() {
        let iter = (0..5).zip(&(10..15));

        assert_eq!(iter.size_hint(), Option::some(5usize));

        assert_eq!(iter.next(), Option::some((0, 10)));
        assert_eq!(iter.next(), Option::some((1, 11)));
        assert_eq!(iter.next(), Option::some((2, 12)));
        assert_eq!(iter.next(), Option::some((3, 13)));
        assert_eq!(iter.next(), Option::some((4, 14)));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_zip_shorter() {
        let iter = (0..5).zip(&once(100));

        assert_eq!(iter.size_hint(), Option::some(1usize));

        assert_eq!(iter.next(), Option::some((0, 100)));
        assert_eq!(iter.next(), Option::none());

        let iter = once(100).zip(&(0..5));

        assert_eq!(iter.size_hint(), Option::some(1usize));

        assert_eq!(iter.next(), Option::some((100, 0)));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_flatten() {
        let iter = [(0..3), (4..7), (8..11)].iter().flatten();

        assert_eq!(iter.next(), Option::some(0));
        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::some(5));
        assert_eq!(iter.next(), Option::some(6));
        assert_eq!(iter.next(), Option::some(8));
        assert_eq!(iter.next(), Option::some(9));
        assert_eq!(iter.next(), Option::some(10));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_flatten_2() {
        let iter = [Option::some(1), Option::none(), Option::some(2), Option::some(3)].iter().flatten();

        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::none());
    }


    #[test]
    fn test_flatten_3() {
        let iter = [0, 1, 2]
            .iter()
            .map(|v: i32| -> range::Range<i32> { (2*v)..(2*v + 2) })
            .flatten();

        assert_eq!(iter.next(), Option::some(0));
        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::some(5));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_flatten_4() {
        let iter = (0..5)
            .group_by(|v: i32| -> i32 { v / 2 })
            .flatten();

        assert_eq!(iter.next(), Option::some(0));
        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_find() {
        let a = (1..10).find(|x: i32| -> bool { x * x >= 50 });
        let b = (1..10).find(|x: i32| -> bool { x * x >= 1000 });

        assert_eq!(a, Option::some(8));
        assert_eq!(b, Option::none());
    }

    #[test]
    fn test_find_index() {
        let a = (1..10).find_index(|x: i32| -> bool { x * x >= 50 });
        let b = (1..10).find_index(|x: i32| -> bool { x * x >= 1000 });

        assert_eq!(a, Option::some(7usize));
        assert_eq!(b, Option::none());
    }

    #[test]
    fn test_chunks() {
        let iter = (0..10).chunks(3);
        assert_eq!(iter.size_hint(), Option::some(4usize));

        let chunk = iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(3usize));
        assert_eq!(chunk.size_hint(), Option::some(3usize));
        assert_eq!(chunk.next(), Option::some(0));
        assert_eq!(chunk.next(), Option::some(1));
        assert_eq!(chunk.next(), Option::some(2));
        assert_eq!(chunk.next(), Option::none());

        let chunk = iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(2usize));
        assert_eq!(chunk.size_hint(), Option::some(3usize));
        assert_eq!(chunk.next(), Option::some(3));
        assert_eq!(chunk.next(), Option::some(4));
        assert_eq!(chunk.next(), Option::some(5));
        assert_eq!(chunk.next(), Option::none());

        let chunk = iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(1usize));
        assert_eq!(chunk.size_hint(), Option::some(3usize));
        assert_eq!(chunk.next(), Option::some(6));
        assert_eq!(chunk.next(), Option::some(7));
        assert_eq!(chunk.next(), Option::some(8));
        assert_eq!(chunk.next(), Option::none());

        let chunk = iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(0usize));
        assert_eq!(chunk.size_hint(), Option::some(1usize));
        assert_eq!(chunk.next(), Option::some(9));
        assert_eq!(chunk.next(), Option::none());

        assert!(iter.next().is_none());
    }

    #[test]
    fn test_chunks_not_used() {
        let iter = (0..10).chunks(3);
        assert_eq!(iter.size_hint(), Option::some(4usize));

        iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(3usize));

        let chunk = iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(2usize));
        assert_eq!(chunk.size_hint(), Option::some(3usize));
        assert_eq!(chunk.next(), Option::some(3));
        assert_eq!(chunk.next(), Option::some(4));
        assert_eq!(chunk.next(), Option::some(5));
        assert_eq!(chunk.next(), Option::none());

        iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(1usize));

        iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(0usize));

        assert!(iter.next().is_none());
    }

    #[test]
    fn test_chunks_1() {
        let iter = (0..=2).chunks(1);
        assert_eq!(iter.size_hint(), Option::some(3usize));

        let chunk = iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(2usize));
        assert_eq!(chunk.size_hint(), Option::some(1usize));
        assert_eq!(chunk.next(), Option::some(0));
        assert_eq!(chunk.next(), Option::none());

        let chunk = iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(1usize));
        assert_eq!(chunk.size_hint(), Option::some(1usize));
        assert_eq!(chunk.next(), Option::some(1));
        assert_eq!(chunk.next(), Option::none());

        let chunk = iter.next().unwrap();
        assert_eq!(iter.size_hint(), Option::some(0usize));
        assert_eq!(chunk.size_hint(), Option::some(1usize));
        assert_eq!(chunk.next(), Option::some(2));
        assert_eq!(chunk.next(), Option::none());

        assert!(iter.next().is_none());
    }

    #[test]
    fn test_chunks_empty() {
        let iter = empty::<i32>().chunks(100);

        assert_eq!(iter.size_hint(), Option::some(0usize));
        assert!(iter.next().is_none());
    }

    #[test]
    fn test_chunks_0() {
        test::assert_panics!((0..10).chunks(0));
    }

    #[test]
    fn test_merge_sorted_1() {
        let iter = [1,3,5,7].iter().merge_sorted(&[2,4,6,8].iter());
        assert_eq!(iter.size_hint(), Option::some(8usize));

        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::some(5));
        assert_eq!(iter.next(), Option::some(6));
        assert_eq!(iter.next(), Option::some(7));
        assert_eq!(iter.next(), Option::some(8));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_merge_sorted_reversed() {
        let iter = [1,3,5,7].iter().merge_sorted(&[2,4,6,8].iter()).rev();
        assert_eq!(iter.size_hint(), Option::some(8usize));

        assert_eq!(iter.next(), Option::some(8));
        assert_eq!(iter.next(), Option::some(7));
        assert_eq!(iter.next(), Option::some(6));
        assert_eq!(iter.next(), Option::some(5));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_merge_sorted_2() {
        let iter = [1,2,3,4].iter().merge_sorted(&[5,6,7,8].iter());
        assert_eq!(iter.size_hint(), Option::some(8usize));

        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::some(5));
        assert_eq!(iter.next(), Option::some(6));
        assert_eq!(iter.next(), Option::some(7));
        assert_eq!(iter.next(), Option::some(8));
        assert_eq!(iter.next(), Option::none());
    }


    #[test]
    fn test_merge_sorted_3() {
        let iter = [5,6,7,8].iter().merge_sorted(&[1,2,3,4].iter());
        assert_eq!(iter.size_hint(), Option::some(8usize));

        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.next(), Option::some(5));
        assert_eq!(iter.next(), Option::some(6));
        assert_eq!(iter.next(), Option::some(7));
        assert_eq!(iter.next(), Option::some(8));
        assert_eq!(iter.next(), Option::none());
    }

    #[test]
    fn test_merge_sorted_exhausted_left() {
        let iter = [1,3].iter().merge_sorted(&[2,4,6,8].iter());
        assert_eq!(iter.size_hint(), Option::some(6usize));

        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.size_hint(), Option::some(5usize));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.size_hint(), Option::some(4usize));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.size_hint(), Option::some(3usize));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.size_hint(), Option::some(2usize));
        assert_eq!(iter.next(), Option::some(6));
        assert_eq!(iter.size_hint(), Option::some(1usize));
        assert_eq!(iter.next(), Option::some(8));
        assert_eq!(iter.size_hint(), Option::some(0usize));
        assert_eq!(iter.next(), Option::none());
        assert_eq!(iter.size_hint(), Option::some(0usize));
    }

    #[test]
    fn test_merge_sorted_exhausted_right() {
        let iter = [2,4,6,8].iter().merge_sorted(&[1,3].iter());
        assert_eq!(iter.size_hint(), Option::some(6usize));

        assert_eq!(iter.next(), Option::some(1));
        assert_eq!(iter.size_hint(), Option::some(5usize));
        assert_eq!(iter.next(), Option::some(2));
        assert_eq!(iter.size_hint(), Option::some(4usize));
        assert_eq!(iter.next(), Option::some(3));
        assert_eq!(iter.size_hint(), Option::some(3usize));
        assert_eq!(iter.next(), Option::some(4));
        assert_eq!(iter.size_hint(), Option::some(2usize));
        assert_eq!(iter.next(), Option::some(6));
        assert_eq!(iter.size_hint(), Option::some(1usize));
        assert_eq!(iter.next(), Option::some(8));
        assert_eq!(iter.size_hint(), Option::some(0usize));
        assert_eq!(iter.next(), Option::none());
        assert_eq!(iter.size_hint(), Option::some(0usize));
    }
}
