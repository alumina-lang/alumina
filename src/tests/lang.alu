//! Tests for various language features and constructs.

#[test]
fn test_linear_scope_shadowing_fn() {
    fn foo() -> i32 {
        1
    }
    assert_eq!(foo(), 1);

    fn foo() -> i32 {
        2
    }
    assert_eq!(foo(), 2);
}

#[test]
fn test_linear_scope_shadowing_impl() {
    struct Foo {}
    impl Foo {
        fn foo(self: &Foo) -> i32 {
            1
        }
    }

    assert_eq!(Foo{}.foo(), 1);

    struct Foo {}
    impl Foo {
        fn foo(self: &Foo) -> i32 {
            2
        }
    }

    assert_eq!(Foo{}.foo(), 2);
}

#[test]
fn test_linear_scope_shadowing_mixed() {
    let foo = 1;
    assert_eq!(foo, 1);

    fn foo() -> i32 {
        1
    }
    assert_eq!(foo(), 1);

    struct foo {}
    impl foo { fn foo() -> i32 { 2 } }

    assert_eq!(foo::foo(), 2);

    const foo: i32 = 3;
    assert_eq!(foo, 3);

    fn bar() -> i32 { 4 }

    use bar as foo;
    assert_eq!(foo(), 4);
}


#[test]
fn test_no_int_promotion() {
    let a = 63u8;
    assert!(a < ~a);
}

fn assert_layout<T>(size: usize, align: usize) {
    use std::mem::{align_of, size_of};

    assert_eq!(size_of::<T>(), size);
    assert_eq!(align_of::<T>(), align);

    // Check that our own layout computation agrees with C's.
    when T: !std::builtins::ZeroSized {
        assert_eq!(std::intrinsics::codegen_type_func::<T, usize>("sizeof"), size);
        assert_eq!(std::intrinsics::codegen_type_func::<T, usize>("_Alignof"), align);
    }
}

#[test]
fn test_builtin_layout() {
    assert_layout::<bool>(1, 1);
    assert_layout::<u8>(1, 1);
    assert_layout::<u16>(2, 2);
    assert_layout::<u32>(4, 4);
    assert_layout::<u64>(8, 8);

    #[cfg(target_pointer_width = "64")]
    assert_layout::<usize>(8, 8);
    #[cfg(target_pointer_width = "32")]
    assert_layout::<usize>(4, 4);

    assert_layout::<u128>(16, 16);

    assert_layout::<i8>(1, 1);
    assert_layout::<i16>(2, 2);
    assert_layout::<i32>(4, 4);
    assert_layout::<i64>(8, 8);

    #[cfg(target_pointer_width = "64")]
    assert_layout::<isize>(8, 8);
    #[cfg(target_pointer_width = "32")]
    assert_layout::<isize>(4, 4);

    assert_layout::<i128>(16, 16);

    assert_layout::<f32>(4, 4);
    assert_layout::<f64>(8, 8);

    assert_layout::<()>(0, 1);
    assert_layout::<!>(0, 1);

    #[cfg(target_pointer_width = "64")]
    {
        assert_layout::<&u8>(8, 8);
        assert_layout::<&mut u8>(8, 8);
        assert_layout::<fn()>(8, 8);
    }

    #[cfg(target_pointer_width = "32")]
    {
        assert_layout::<&u8>(4, 4);
        assert_layout::<&mut u8>(4, 4);
        assert_layout::<fn()>(4, 4);
    }

    // named functions are ZSTs
    assert_layout::<test_builtin_layout>(0, 1);
}

#[test]
fn test_struct_layout() {
    struct S {}
    assert_layout::<S>(0, 1);

    struct S { a: u8 }
    assert_layout::<S>(1, 1);

    struct S { a: u8, b: u8 }
    assert_layout::<S>(2, 1);

    struct S { a: u8, b: u32, c: u8 }
    assert_layout::<S>(12, 4);

    struct S { a: u32, b: u8, c: u8 }
    assert_layout::<S>(8, 4);

    struct S { a: (), b: u32, c: () }
    assert_layout::<S>(4, 4);

    struct S { a: (), b: u128, c: () }
    assert_layout::<S>(16, 16);

    #[packed] struct S { a: u32, b: u8, c: u8 }
    assert_layout::<S>(6, 1);

    // tuple is still padded internally, but struct is not
    #[packed] struct S { a: u32, b: (u8, u128), c: u8 }
    assert_layout::<S>(37, 1);

    #[packed] struct Inner { a: u8, b: u128 }
    #[packed] struct S { a: u32, b: Inner, c: u8 }
    assert_layout::<S>(22, 1);

    #[align(2)] struct S { val: u8 }
    assert_layout::<S>(2, 2);

    #[align(4)] struct S { val: u8 }
    assert_layout::<S>(4, 4);

    #[align(8)] struct S { val: u8 }
    assert_layout::<S>(8, 8);

    #[align(16)] struct S { val: u8 }
    assert_layout::<S>(16, 16);

    #[align(32)] struct S { val: u8 }
    assert_layout::<S>(32, 32);

    #[align(64)] struct S { val: u8 }
    assert_layout::<S>(64, 64);

    // align attribute is minimum, not exact alignment
    #[align(2)] struct S { a: u8, b: u32 }
    assert_layout::<S>(8, 4);
}

#[test]
fn test_union_layout() {
    union U { }
    assert_layout::<U>(0, 1);

    union U { a: () }
    assert_layout::<U>(0, 1);

    union U { a: u8, b: u8 }
    assert_layout::<U>(1, 1);

    union U { a: u8, b: u32 }
    assert_layout::<U>(4, 4);

    union U { a: u32, b: u8 }
    assert_layout::<U>(4, 4);

    union U { a: u32, b: u8, c: u8 }
    assert_layout::<U>(4, 4);

    union U { a: (), b: u32, c: () }
    assert_layout::<U>(4, 4);

    union U { a: (), b: u128, c: () }
    assert_layout::<U>(16, 16);

    #[packed] union U { a: u32, b: u8, c: u8 }
    assert_layout::<U>(4, 1);

    union Inner { a: u8, b: u128 }
    #[packed] union U { a: u32, b: Inner, c: u8 }
    assert_layout::<U>(16, 1);

    #[packed] union Inner { a: u8, b: u128 }
    #[packed] union U { a: u32, b: Inner, c: u8 }
    assert_layout::<U>(16, 1);

    union U { a: [u8; 12], b: u64 }
    assert_layout::<U>(16, 8);
}

#[test]
fn test_tuple_layout() {
    assert_layout::<()>(0, 1);
    assert_layout::<(u8,)>(1, 1);

    assert_layout::<((), u64)>(8, 8);
    assert_layout::<(u8, u64)>(16, 8);
    assert_layout::<(u8, u64)>(16, 8);
}

#[test]
fn test_closure_layout() {
    let f = || {};
    assert_layout::<typeof(f)>(0, 1);

    let f = |_a: u8| {};
    assert_layout::<typeof(f)>(0, 1);

    let a: ();
    let b: u8;
    let c: u64;

    let f = |=a| { a; };
    assert_layout::<typeof(f)>(0, 1);
    let f = |=a, =b| { a; b; };
    assert_layout::<typeof(f)>(1, 1);
    let f = |=a, =b, =c| { a; b; c; };
    assert_layout::<typeof(f)>(16, 8);
}

#[test]
fn test_array_layout() {
    assert_layout::<[u8; 0]>(0, 1);
    assert_layout::<[u8; 1]>(1, 1);
    assert_layout::<[u8; 2]>(2, 1);
    assert_layout::<[u8; 3]>(3, 1);

    assert_layout::<[u64; 0]>(0, 8);
    assert_layout::<[u64; 1]>(8, 8);
    assert_layout::<[u64; 2]>(16, 8);
    assert_layout::<[u64; 3]>(24, 8);
}

#[test]
fn test_nested_zst_layout() {
    #[packed] struct S { a: u8, b: [u64; 0] }
    assert_layout::<S>(1, 1);

    // ZST structs do not affect the size of the aggregate they are nested in,
    // but they do affect the alignment.

    #[align(64)] struct BigZst {}

    struct S { a: u8, b: [u64; 0] }
    assert_layout::<S>(8, 8);

    struct S { b: BigZst }
    assert_layout::<S>(0, 64);

    struct S { a: u8, b: BigZst }
    assert_layout::<S>(64, 64);

    struct S { a: u8, b: [[u64; 0]; 1] }
    assert_layout::<S>(8, 8);

    union U { a: u8, b: [u64; 0] }
    assert_layout::<U>(8, 8);
}


// Define them in random order; not that it matters.
static A3: i32 = A2 + 1 + A1;
static A7: i32 = A6 + 1 + A5;
static A6: i32 = A5 + 1 + A4;
static A5: i32 = A4 + 1 + A3;
static A0: i32 = 1;
static A2: i32 = A1 + 1 + A0;
static A4: i32 = A3 + 1 + A2;
static A8: i32 = A7 + 1 + A6;
static A1: i32 = 1;

#[test]
fn test_static_initialization_order() {
    // https://oeis.org/A001595
    assert_eq!(A0, 1);
    assert_eq!(A1, 1);
    assert_eq!(A2, 3);
    assert_eq!(A3, 5);
    assert_eq!(A4, 9);
    assert_eq!(A5, 15);
    assert_eq!(A6, 25);
    assert_eq!(A7, 41);
    assert_eq!(A8, 67);
}
