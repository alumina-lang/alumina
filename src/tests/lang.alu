//! Tests for various language features and constructs.

#[test]
fn test_linear_scope_shadowing_fn() {
    fn foo() -> i32 {
        1
    }
    assert_eq!(foo(), 1);

    fn foo() -> i32 {
        2
    }
    assert_eq!(foo(), 2);
}

#[test]
fn test_linear_scope_shadowing_impl() {
    struct Foo {}
    impl Foo {
        fn foo(self: &Foo) -> i32 {
            1
        }
    }

    assert_eq!(Foo{}.foo(), 1);

    struct Foo {}
    impl Foo {
        fn foo(self: &Foo) -> i32 {
            2
        }
    }

    assert_eq!(Foo{}.foo(), 2);
}

#[test]
fn test_linear_scope_shadowing_mixed() {
    let foo = 1;
    assert_eq!(foo, 1);

    fn foo() -> i32 {
        1
    }
    assert_eq!(foo(), 1);

    struct foo {}
    impl foo { fn foo() -> i32 { 2 } }

    assert_eq!(foo::foo(), 2);

    const foo: i32 = 3;
    assert_eq!(foo, 3);

    fn bar() -> i32 { 4 }

    use bar as foo;
    assert_eq!(foo(), 4);
}


#[test]
fn test_no_int_promotion() {
    let a = 63u8;
    assert!(a < ~a);
}

fn assert_layout<T>(size: usize, align: usize) {
    use std::mem::{align_of, size_of};

    assert_eq!(size_of::<T>(), size);
    assert_eq!(align_of::<T>(), align);

    // Check that our own layout computation agrees with C's.
    when !std::typing::is_zero_sized::<T>() {
        assert_eq!(std::intrinsics::codegen_type_func::<T, usize>("sizeof"), size);
        assert_eq!(std::intrinsics::codegen_type_func::<T, usize>("_Alignof"), align);
    }
}

#[test]
fn test_builtin_layout() {
    assert_layout::<bool>(1, 1);
    assert_layout::<u8>(1, 1);
    assert_layout::<u16>(2, 2);
    assert_layout::<u32>(4, 4);
    assert_layout::<u64>(8, 8);

    #[cfg(target_pointer_width = "64")]
    assert_layout::<usize>(8, 8);
    #[cfg(target_pointer_width = "32")]
    assert_layout::<usize>(4, 4);

    assert_layout::<u128>(16, 16);

    assert_layout::<i8>(1, 1);
    assert_layout::<i16>(2, 2);
    assert_layout::<i32>(4, 4);
    assert_layout::<i64>(8, 8);

    #[cfg(target_pointer_width = "64")]
    assert_layout::<isize>(8, 8);
    #[cfg(target_pointer_width = "32")]
    assert_layout::<isize>(4, 4);

    assert_layout::<i128>(16, 16);

    assert_layout::<f32>(4, 4);
    assert_layout::<f64>(8, 8);

    assert_layout::<()>(0, 1);
    assert_layout::<!>(0, 1);

    #[cfg(target_pointer_width = "64")]
    {
        assert_layout::<&u8>(8, 8);
        assert_layout::<&mut u8>(8, 8);
        assert_layout::<fn()>(8, 8);
    }

    #[cfg(target_pointer_width = "32")]
    {
        assert_layout::<&u8>(4, 4);
        assert_layout::<&mut u8>(4, 4);
        assert_layout::<fn()>(4, 4);
    }

    // named functions are ZSTs
    assert_layout::<test_builtin_layout>(0, 1);
}

#[test]
fn test_struct_layout() {
    struct S {}
    assert_layout::<S>(0, 1);

    struct S { a: u8 }
    assert_layout::<S>(1, 1);

    struct S { a: u8, b: u8 }
    assert_layout::<S>(2, 1);

    struct S { a: u8, b: u32, c: u8 }
    assert_layout::<S>(12, 4);

    struct S { a: u32, b: u8, c: u8 }
    assert_layout::<S>(8, 4);

    struct S { a: (), b: u32, c: () }
    assert_layout::<S>(4, 4);

    struct S { a: (), b: u128, c: () }
    assert_layout::<S>(16, 16);

    #[packed] struct S { a: u32, b: u8, c: u8 }
    assert_layout::<S>(6, 1);

    // tuple is still padded internally, but struct is not
    #[packed] struct S { a: u32, b: (u8, u128), c: u8 }
    assert_layout::<S>(37, 1);

    #[packed] struct Inner { a: u8, b: u128 }
    #[packed] struct S { a: u32, b: Inner, c: u8 }
    assert_layout::<S>(22, 1);

    #[align(2)] struct S { val: u8 }
    assert_layout::<S>(2, 2);

    #[align(4)] struct S { val: u8 }
    assert_layout::<S>(4, 4);

    #[align(8)] struct S { val: u8 }
    assert_layout::<S>(8, 8);

    #[align(16)] struct S { val: u8 }
    assert_layout::<S>(16, 16);

    #[align(32)] struct S { val: u8 }
    assert_layout::<S>(32, 32);

    #[align(64)] struct S { val: u8 }
    assert_layout::<S>(64, 64);

    // align attribute is minimum, not exact alignment
    #[align(2)] struct S { a: u8, b: u32 }
    assert_layout::<S>(8, 4);
}

#[test]
fn test_union_layout() {
    union U { }
    assert_layout::<U>(0, 1);

    union U { a: () }
    assert_layout::<U>(0, 1);

    union U { a: u8, b: u8 }
    assert_layout::<U>(1, 1);

    union U { a: u8, b: u32 }
    assert_layout::<U>(4, 4);

    union U { a: u32, b: u8 }
    assert_layout::<U>(4, 4);

    union U { a: u32, b: u8, c: u8 }
    assert_layout::<U>(4, 4);

    union U { a: (), b: u32, c: () }
    assert_layout::<U>(4, 4);

    union U { a: (), b: u128, c: () }
    assert_layout::<U>(16, 16);

    #[packed] union U { a: u32, b: u8, c: u8 }
    assert_layout::<U>(4, 1);

    union Inner { a: u8, b: u128 }
    #[packed] union U { a: u32, b: Inner, c: u8 }
    assert_layout::<U>(16, 1);

    #[packed] union Inner { a: u8, b: u128 }
    #[packed] union U { a: u32, b: Inner, c: u8 }
    assert_layout::<U>(16, 1);

    union U { a: [u8; 12], b: u64 }
    assert_layout::<U>(16, 8);
}

#[test]
fn test_tuple_layout() {
    assert_layout::<()>(0, 1);
    assert_layout::<(u8,)>(1, 1);

    assert_layout::<((), u64)>(8, 8);
    assert_layout::<(u8, u64)>(16, 8);
    assert_layout::<(u8, u64)>(16, 8);
}

#[test]
#[allow(pure_statement)]
fn test_closure_layout() {
    let f = || {};
    assert_layout::<typeof(f)>(0, 1);

    let f = |_a: u8| {};
    assert_layout::<typeof(f)>(0, 1);

    let a: ();
    let b: u8;
    let c: u64;

    let f = |=a| { a; };
    assert_layout::<typeof(f)>(0, 1);
    let f = |=a, =b| { a; b; };
    assert_layout::<typeof(f)>(1, 1);
    let f = |=a, =b, =c| { a; b; c; };
    assert_layout::<typeof(f)>(16, 8);
}

#[test]
fn test_array_layout() {
    assert_layout::<[u8; 0]>(0, 1);
    assert_layout::<[u8; 1]>(1, 1);
    assert_layout::<[u8; 2]>(2, 1);
    assert_layout::<[u8; 3]>(3, 1);

    assert_layout::<[u64; 0]>(0, 8);
    assert_layout::<[u64; 1]>(8, 8);
    assert_layout::<[u64; 2]>(16, 8);
    assert_layout::<[u64; 3]>(24, 8);
}

#[test]
fn test_nested_zst_layout() {
    #[packed] struct S { a: u8, b: [u64; 0] }
    assert_layout::<S>(1, 1);

    // ZST structs do not affect the size of the aggregate they are nested in,
    // but they do affect the alignment.

    #[align(64)] struct BigZst {}

    struct S { a: u8, b: [u64; 0] }
    assert_layout::<S>(8, 8);

    struct S { b: BigZst }
    assert_layout::<S>(0, 64);

    struct S { a: u8, b: BigZst }
    assert_layout::<S>(64, 64);

    struct S { a: u8, b: [[u64; 0]; 1] }
    assert_layout::<S>(8, 8);

    union U { a: u8, b: [u64; 0] }
    assert_layout::<U>(8, 8);
}


// Define them in random order; not that it matters.
static A3: i32 = A2 + 1 + A1;
static A7: i32 = A6 + 1 + A5;
static A6: i32 = A5 + 1 + A4;
static A5: i32 = A4 + 1 + A3;
static A0: i32 = 1;
static A2: i32 = A1 + 1 + A0;
static A4: i32 = A3 + 1 + A2;
static A8: i32 = A7 + 1 + A6;
static A1: i32 = 1;

#[test]
fn test_static_initialization_order() {
    // https://oeis.org/A001595
    assert_eq!(A0, 1);
    assert_eq!(A1, 1);
    assert_eq!(A2, 3);
    assert_eq!(A3, 5);
    assert_eq!(A4, 9);
    assert_eq!(A5, 15);
    assert_eq!(A6, 25);
    assert_eq!(A7, 41);
    assert_eq!(A8, 67);
}



#[test]
fn test_const_eval_basic() {
    const A = 1;
    assert_eq!(A, 1);

    const A = 1 + 1;
    assert_eq!(A, 2);

    const A = {
        let a = 1;
        a + 2
    };

    assert_eq!(A, 3);

    const A = "hello world";
    assert_eq!(A, "hello world");

    const A = [1, 2, 3];
    assert_eq!(A, [1, 2, 3]);

    const A = [1, 2, 3][1];
    assert_eq!(A, 2);

    const A = [1, 2, 3][1] + 1;
    assert_eq!(A, 3);

    const A = "hello world"[2..5];
    assert_eq!(A, "llo");

    const A = "hello world"[2..5].len();
    assert_eq!(A, 3);
}


fn fib(n: i32) -> i32 {
    if n < 2 {
        n
    } else {
        fib(n - 1) + fib(n - 2)
    }
}

#[test]
fn test_const_eval_fancy() {
    const FIB_50 = {
        let a = 0u64;
        let b = 1u64;

        for _ in 0..50 {
            let c = a + b;
            a = b;
            b = c;
        }

        a
    };
    assert_eq!(FIB_50, 12586269025u64);

    const FIB_10 = fib(10);
    assert_eq!(FIB_10, 55);
}


#[test]
fn test_const_eval_uninitialized() {
    const MATRIX = {
        let a: [[i32; 3]; 3];

        for i in 0usize..3 {
            for j in 0usize..3 {
                a[i][j] = (i + j) as i32;
            }
        }

        a
    };

    assert_eq!(MATRIX, [
        [0, 1, 2],
        [1, 2, 3],
        [2, 3, 4],
    ]);
}

#[test]
fn test_const_eval_pointer_arithmetic() {
    const VALUES: ([i32; 5], isize) = {
        let a = [1, 2, 3, 4, 5];
        let ptr = &a[0];

        *ptr = -1;
        *(ptr + 1) = -2;
        *(ptr + 4) = -10;

        (a, &a[0] - &a[5])
    };


    assert_eq!(VALUES.0, [-1, -2, 3, 4, -10]);
    assert_eq!(VALUES.1, -5);
}

#[test]


#[test]
fn test_const_eval_library_functions() {
    fn calc() -> ([i32; 10], bool) {
        let rng = std::random::Pcg32 {
            state: 0xa285d44c06ab9542,
            increment: 0x71bc6da31db36d8d,
        };

        let ret: [i32; 10];
        (0..10)
            .map(|&rng, _: i32| -> i32 { rng.next(0..10) })
            .fill_slice(&ret);

        (ret, std::runtime::in_const_context())
    }

    const RANDOM_VALUES = calc();
    let random_values = calc();

    assert_eq!(RANDOM_VALUES.0, random_values.0);

    assert!(RANDOM_VALUES.1);
    assert!(!random_values.1);
}

#[test]
fn test_const_eval_const() {
    const A: [i32; 3] = [1, 2, 3];
    const B: &i32 = &A[2];

    const C: i32 = 5;
    const D: &i32 = &C;

    assert_eq!(*B, 3);
    assert_eq!(*D, 5);
}


#[test]
fn test_const_zst() {
    struct S<T> {
        a: T,
        b: i32,
    };

    const A = ();
    const B1: [i32; 0] = [];
    const B2: [(); 3] = [(), (), ()];
    const C = ((),(()),((())));
    const D1 = S { a: (), b: 5 };
    const D2 = S { a: [(), (), ()], b: 5 };
    const E = ((), 5);

    const F = &A;
    const G1 = &B1;
    const G2 = &B2[1];
    const H = &C;
    const I1 = &D1.a;
    const I2 = &D2.a[1];
    const J = &E.0;

    assert_eq!(A, ());
    assert_eq!(B1, []);
    assert_eq!(B2, [(), (), ()]);
    assert_eq!(C, ((),(()),((()))));
    assert_eq!(D1.b, 5);
    assert_eq!(D2.b, 5);
    assert_eq!(E.1, 5);

    assert_eq!(F, &());
    assert_eq!(G1, &[]);
    assert_eq!(G2, &());
    assert_eq!(H, &((),(()),((()))));
    assert_eq!(I1, &());
    assert_eq!(I2, &());
    assert_eq!(J, &());
}

#[test]
fn test_const_eval_intrinsics() {
    std::compile_note!("this is a warning"[3..7]);
}
