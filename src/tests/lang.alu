//! Tests for various language features and constructs.

#[test]
fn test_linear_scope_shadowing_fn() {
    fn foo() -> i32 {
        1
    }
    assert_eq!(foo(), 1);

    fn foo() -> i32 {
        2
    }
    assert_eq!(foo(), 2);
}

#[test]
fn test_linear_scope_shadowing_impl() {
    struct Foo {}
    impl Foo {
        fn foo(self: &Foo) -> i32 {
            1
        }
    }

    assert_eq!(Foo{}.foo(), 1);

    struct Foo {}
    impl Foo {
        fn foo(self: &Foo) -> i32 {
            2
        }
    }

    assert_eq!(Foo{}.foo(), 2);
}

#[test]
fn test_linear_scope_shadowing_mixed() {
    let foo = 1;
    assert_eq!(foo, 1);

    fn foo() -> i32 {
        1
    }
    assert_eq!(foo(), 1);

    struct foo {}
    impl foo { fn foo() -> i32 { 2 } }

    assert_eq!(foo::foo(), 2);

    const foo: i32 = 3;
    assert_eq!(foo, 3);

    fn bar() -> i32 { 4 }

    use bar as foo;
    assert_eq!(foo(), 4);
}

#[test]
fn test_align_attribute() {
    use std::mem::align_of;

    #[align(1)] struct A1 { val: u8 }
    #[align(2)] struct A2 { val: u8 }
    #[align(4)] struct A4 { val: u8 }
    #[align(8)] struct A8 { val: u8 }
    #[align(16)] struct A16 { val: u8 }
    #[align(32)] struct A32 { val: u8 }
    #[align(64)] struct A64 { val: u8 }

    assert_eq!(align_of::<A1>(), 1);
    assert_eq!(align_of::<A2>(), 2);
    assert_eq!(align_of::<A4>(), 4);
    assert_eq!(align_of::<A8>(), 8);
    assert_eq!(align_of::<A16>(), 16);
    assert_eq!(align_of::<A32>(), 32);
    assert_eq!(align_of::<A64>(), 64);
}

#[test]
fn test_packed_attribute() {
    use std::mem::align_of;

    struct S1 { val: u8, ptr: &void }
    #[packed] struct S2 { val: u8, ptr: &void }

    let s1: S1;
    let s2: S2;

    assert!((&s1.ptr as usize) - (&s1 as usize) > 1usize);
    assert_eq!((&s2.ptr as usize) - (&s2 as usize), 1usize);
}


#[test]
fn test_no_int_promotion() {
    let a = 63u8;
    assert!(a < ~a);
}
