// DO NOT EDIT THIS FILE. IT IS AUTOMATICALLY GENERATED.
// Make changes in tools/tree-sitter-codegen/main.alu

use std::collections::HashMap;
use tree_sitter::{TSSymbol, Node};

enum NodeKind {
    Invalid,
    SourceFile,
    UseDeclaration,
    UseWildcard,
    Mixin,
    AssignmentExpression,
    StructInitializerItem,
    ScopedTypeIdentifier,
    UseList,
    TopLevelBlock,
    ExpressionStatement,
    GenericTypeWithTurbofish,
    BooleanLiteral,
    CompoundAssignmentExpr,
    DeferExpression,
    ParameterTypeList,
    Pattern,
    Arguments,
    CallExpression,
    TypeArguments,
    ContinueExpression,
    MacroDefinition,
    BinaryExpression,
    ProtocolBound,
    StructInitializer,
    Block,
    SliceOf,
    FloatLiteral,
    ArrayOf,
    ScopedUseList,
    ArrayExpression,
    VoidLiteral,
    Attributes,
    MetaArguments,
    RangeExpression,
    DereferenceExpression,
    TypeCheck,
    MacroParameterList,
    TypeIdentifier,
    MacroInvocation,
    ConstDeclaration,
    LoopExpression,
    Super,
    StructExpression,
    UseAsClause,
    ProtocolDefinition,
    Parameter,
    FieldExpression,
    PtrLiteral,
    EnumDefinition,
    TupleType,
    ElseClause,
    TypeDefinition,
    TypeCastExpression,
    UnaryExpression,
    GenericType,
    Identifier,
    IndexExpression,
    LetDeclaration,
    StaticDeclaration,
    MacroParameter,
    PrimitiveType,
    ModDefinition,
    NeverType,
    WhileExpression,
    StringLiteral,
    ImplBlock,
    ScopedIdentifier,
    SwitchExpression,
    MacroIdentifier,
    GenericArgument,
    BreakExpression,
    EtCeteraExpression,
    FunctionPointer,
    EmptyStatement,
    ClosureExpression,
    SwitchBody,
    ClosureParameters,
    ReferenceExpression,
    MetaItem,
    AttributeItem,
    GenericArgumentList,
    ReturnExpression,
    IfExpression,
    SwitchArm,
    StructDefinition,
    Statement,
    TupleExpression,
    EnumItem,
    GenericFunction,
    PointerOf,
    ParenthesizedExpression,
    CharLiteral,
    ForExpression,
    IntegerLiteral,
    StructField,
    FunctionDefinition,
    ParameterList,
}

enum FieldKind {
    Abi = 1u16,
    Alias = 2u16,
    Alternative = 3u16,
    Argument = 4u16,
    Arguments = 5u16,
    Arm = 6u16,
    Attributes = 7u16,
    Body = 8u16,
    Bound = 9u16,
    Condition = 10u16,
    Consequence = 11u16,
    Default = 12u16,
    Element = 13u16,
    EtCetera = 14u16,
    Extern = 15u16,
    Field = 16u16,
    Function = 17u16,
    Index = 18u16,
    Init = 19u16,
    Inner = 20u16,
    Item = 21u16,
    Items = 22u16,
    Kind = 23u16,
    Left = 24u16,
    Lhs = 25u16,
    List = 26u16,
    Lower = 27u16,
    Macro = 28u16,
    Mut = 29u16,
    Name = 30u16,
    Negated = 31u16,
    Operator = 32u16,
    Parameter = 33u16,
    Parameters = 34u16,
    Path = 35u16,
    Pattern = 36u16,
    Placeholder = 37u16,
    Protocol = 38u16,
    Range = 39u16,
    Result = 40u16,
    ReturnType = 41u16,
    Right = 42u16,
    Size = 43u16,
    Statements = 44u16,
    Type = 45u16,
    TypeArguments = 46u16,
    TypeCheck = 47u16,
    Upper = 48u16,
}

static NODE_KINDS: [NodeKind; 232] = [
    NodeKind::Invalid,
    NodeKind::Identifier,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Identifier,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::ContinueExpression,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::IntegerLiteral,
    NodeKind::FloatLiteral,
    NodeKind::StringLiteral,
    NodeKind::CharLiteral,
    NodeKind::Super,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::MacroIdentifier,
    NodeKind::SourceFile,
    NodeKind::Attributes,
    NodeKind::AttributeItem,
    NodeKind::MetaItem,
    NodeKind::MetaArguments,
    NodeKind::Invalid,
    NodeKind::TopLevelBlock,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::ModDefinition,
    NodeKind::FunctionDefinition,
    NodeKind::MacroDefinition,
    NodeKind::MacroParameterList,
    NodeKind::MacroParameter,
    NodeKind::StructDefinition,
    NodeKind::ProtocolDefinition,
    NodeKind::Mixin,
    NodeKind::TypeDefinition,
    NodeKind::EnumDefinition,
    NodeKind::EnumItem,
    NodeKind::StructField,
    NodeKind::ImplBlock,
    NodeKind::UseDeclaration,
    NodeKind::UseWildcard,
    NodeKind::Invalid,
    NodeKind::UseAsClause,
    NodeKind::UseList,
    NodeKind::ScopedUseList,
    NodeKind::Parameter,
    NodeKind::ProtocolBound,
    NodeKind::GenericArgument,
    NodeKind::GenericArgumentList,
    NodeKind::ParameterList,
    NodeKind::ParameterTypeList,
    NodeKind::PointerOf,
    NodeKind::SliceOf,
    NodeKind::ArrayOf,
    NodeKind::ArrayExpression,
    NodeKind::FunctionPointer,
    NodeKind::TypeArguments,
    NodeKind::Invalid,
    NodeKind::NeverType,
    NodeKind::TupleType,
    NodeKind::Block,
    NodeKind::LetDeclaration,
    NodeKind::StaticDeclaration,
    NodeKind::ConstDeclaration,
    NodeKind::Statement,
    NodeKind::EmptyStatement,
    NodeKind::Invalid,
    NodeKind::ExpressionStatement,
    NodeKind::ReturnExpression,
    NodeKind::DeferExpression,
    NodeKind::Arguments,
    NodeKind::TupleExpression,
    NodeKind::GenericFunction,
    NodeKind::Invalid,
    NodeKind::UnaryExpression,
    NodeKind::ReferenceExpression,
    NodeKind::DereferenceExpression,
    NodeKind::BinaryExpression,
    NodeKind::FieldExpression,
    NodeKind::AssignmentExpression,
    NodeKind::IndexExpression,
    NodeKind::RangeExpression,
    NodeKind::CompoundAssignmentExpr,
    NodeKind::TypeCastExpression,
    NodeKind::CallExpression,
    NodeKind::MacroInvocation,
    NodeKind::StructInitializerItem,
    NodeKind::ScopedIdentifier,
    NodeKind::GenericType,
    NodeKind::ScopedTypeIdentifier,
    NodeKind::GenericTypeWithTurbofish,
    NodeKind::ScopedTypeIdentifier,
    NodeKind::StructInitializer,
    NodeKind::StructExpression,
    NodeKind::ParenthesizedExpression,
    NodeKind::TypeCheck,
    NodeKind::IfExpression,
    NodeKind::SwitchArm,
    NodeKind::SwitchArm,
    NodeKind::Pattern,
    NodeKind::SwitchExpression,
    NodeKind::SwitchBody,
    NodeKind::ElseClause,
    NodeKind::WhileExpression,
    NodeKind::BreakExpression,
    NodeKind::LoopExpression,
    NodeKind::EtCeteraExpression,
    NodeKind::ForExpression,
    NodeKind::Invalid,
    NodeKind::ClosureExpression,
    NodeKind::ClosureParameters,
    NodeKind::BooleanLiteral,
    NodeKind::PtrLiteral,
    NodeKind::VoidLiteral,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::Invalid,
    NodeKind::PrimitiveType,
    NodeKind::TypeIdentifier,
];
protocol NodeVisitor<Self, ReturnType> {
    fn visit_source_file(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_source_file");
    }
    fn visit_use_declaration(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_use_declaration");
    }
    fn visit_use_wildcard(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_use_wildcard");
    }
    fn visit_mixin(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_mixin");
    }
    fn visit_assignment_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_assignment_expression");
    }
    fn visit_struct_initializer_item(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_struct_initializer_item");
    }
    fn visit_scoped_type_identifier(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_scoped_type_identifier");
    }
    fn visit_use_list(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_use_list");
    }
    fn visit_top_level_block(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_top_level_block");
    }
    fn visit_expression_statement(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_expression_statement");
    }
    fn visit_generic_type_with_turbofish(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_generic_type_with_turbofish");
    }
    fn visit_boolean_literal(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_boolean_literal");
    }
    fn visit_compound_assignment_expr(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_compound_assignment_expr");
    }
    fn visit_defer_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_defer_expression");
    }
    fn visit_parameter_type_list(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_parameter_type_list");
    }
    fn visit_pattern(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_pattern");
    }
    fn visit_arguments(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_arguments");
    }
    fn visit_call_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_call_expression");
    }
    fn visit_type_arguments(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_type_arguments");
    }
    fn visit_continue_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_continue_expression");
    }
    fn visit_macro_definition(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_macro_definition");
    }
    fn visit_binary_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_binary_expression");
    }
    fn visit_protocol_bound(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_protocol_bound");
    }
    fn visit_struct_initializer(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_struct_initializer");
    }
    fn visit_block(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_block");
    }
    fn visit_slice_of(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_slice_of");
    }
    fn visit_float_literal(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_float_literal");
    }
    fn visit_array_of(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_array_of");
    }
    fn visit_scoped_use_list(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_scoped_use_list");
    }
    fn visit_array_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_array_expression");
    }
    fn visit_void_literal(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_void_literal");
    }
    fn visit_attributes(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_attributes");
    }
    fn visit_meta_arguments(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_meta_arguments");
    }
    fn visit_range_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_range_expression");
    }
    fn visit_dereference_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_dereference_expression");
    }
    fn visit_type_check(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_type_check");
    }
    fn visit_macro_parameter_list(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_macro_parameter_list");
    }
    fn visit_type_identifier(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_type_identifier");
    }
    fn visit_macro_invocation(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_macro_invocation");
    }
    fn visit_const_declaration(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_const_declaration");
    }
    fn visit_loop_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_loop_expression");
    }
    fn visit_super(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_super");
    }
    fn visit_struct_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_struct_expression");
    }
    fn visit_use_as_clause(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_use_as_clause");
    }
    fn visit_protocol_definition(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_protocol_definition");
    }
    fn visit_parameter(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_parameter");
    }
    fn visit_field_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_field_expression");
    }
    fn visit_ptr_literal(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_ptr_literal");
    }
    fn visit_enum_definition(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_enum_definition");
    }
    fn visit_tuple_type(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_tuple_type");
    }
    fn visit_else_clause(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_else_clause");
    }
    fn visit_type_definition(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_type_definition");
    }
    fn visit_type_cast_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_type_cast_expression");
    }
    fn visit_unary_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_unary_expression");
    }
    fn visit_generic_type(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_generic_type");
    }
    fn visit_identifier(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_identifier");
    }
    fn visit_index_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_index_expression");
    }
    fn visit_let_declaration(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_let_declaration");
    }
    fn visit_static_declaration(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_static_declaration");
    }
    fn visit_macro_parameter(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_macro_parameter");
    }
    fn visit_primitive_type(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_primitive_type");
    }
    fn visit_mod_definition(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_mod_definition");
    }
    fn visit_never_type(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_never_type");
    }
    fn visit_while_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_while_expression");
    }
    fn visit_string_literal(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_string_literal");
    }
    fn visit_impl_block(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_impl_block");
    }
    fn visit_scoped_identifier(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_scoped_identifier");
    }
    fn visit_switch_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_switch_expression");
    }
    fn visit_macro_identifier(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_macro_identifier");
    }
    fn visit_generic_argument(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_generic_argument");
    }
    fn visit_break_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_break_expression");
    }
    fn visit_et_cetera_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_et_cetera_expression");
    }
    fn visit_function_pointer(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_function_pointer");
    }
    fn visit_empty_statement(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_empty_statement");
    }
    fn visit_closure_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_closure_expression");
    }
    fn visit_switch_body(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_switch_body");
    }
    fn visit_closure_parameters(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_closure_parameters");
    }
    fn visit_reference_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_reference_expression");
    }
    fn visit_meta_item(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_meta_item");
    }
    fn visit_attribute_item(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_attribute_item");
    }
    fn visit_generic_argument_list(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_generic_argument_list");
    }
    fn visit_return_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_return_expression");
    }
    fn visit_if_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_if_expression");
    }
    fn visit_switch_arm(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_switch_arm");
    }
    fn visit_struct_definition(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_struct_definition");
    }
    fn visit_statement(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_statement");
    }
    fn visit_tuple_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_tuple_expression");
    }
    fn visit_enum_item(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_enum_item");
    }
    fn visit_generic_function(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_generic_function");
    }
    fn visit_pointer_of(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_pointer_of");
    }
    fn visit_parenthesized_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_parenthesized_expression");
    }
    fn visit_char_literal(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_char_literal");
    }
    fn visit_for_expression(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_for_expression");
    }
    fn visit_integer_literal(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_integer_literal");
    }
    fn visit_struct_field(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_struct_field");
    }
    fn visit_function_definition(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_function_definition");
    }
    fn visit_parameter_list(self: &mut Self, node: Node) -> ReturnType {
        panic!("unimplemented: visit_parameter_list");
    }
    fn visit(self: &mut Self, node: Node) -> ReturnType {
        switch NODE_KINDS[node.symbol() as usize] {
            NodeKind::SourceFile => self.visit_source_file(node),
            NodeKind::UseDeclaration => self.visit_use_declaration(node),
            NodeKind::UseWildcard => self.visit_use_wildcard(node),
            NodeKind::Mixin => self.visit_mixin(node),
            NodeKind::AssignmentExpression => self.visit_assignment_expression(node),
            NodeKind::StructInitializerItem => self.visit_struct_initializer_item(node),
            NodeKind::ScopedTypeIdentifier => self.visit_scoped_type_identifier(node),
            NodeKind::UseList => self.visit_use_list(node),
            NodeKind::TopLevelBlock => self.visit_top_level_block(node),
            NodeKind::ExpressionStatement => self.visit_expression_statement(node),
            NodeKind::GenericTypeWithTurbofish => self.visit_generic_type_with_turbofish(node),
            NodeKind::BooleanLiteral => self.visit_boolean_literal(node),
            NodeKind::CompoundAssignmentExpr => self.visit_compound_assignment_expr(node),
            NodeKind::DeferExpression => self.visit_defer_expression(node),
            NodeKind::ParameterTypeList => self.visit_parameter_type_list(node),
            NodeKind::Pattern => self.visit_pattern(node),
            NodeKind::Arguments => self.visit_arguments(node),
            NodeKind::CallExpression => self.visit_call_expression(node),
            NodeKind::TypeArguments => self.visit_type_arguments(node),
            NodeKind::ContinueExpression => self.visit_continue_expression(node),
            NodeKind::MacroDefinition => self.visit_macro_definition(node),
            NodeKind::BinaryExpression => self.visit_binary_expression(node),
            NodeKind::ProtocolBound => self.visit_protocol_bound(node),
            NodeKind::StructInitializer => self.visit_struct_initializer(node),
            NodeKind::Block => self.visit_block(node),
            NodeKind::SliceOf => self.visit_slice_of(node),
            NodeKind::FloatLiteral => self.visit_float_literal(node),
            NodeKind::ArrayOf => self.visit_array_of(node),
            NodeKind::ScopedUseList => self.visit_scoped_use_list(node),
            NodeKind::ArrayExpression => self.visit_array_expression(node),
            NodeKind::VoidLiteral => self.visit_void_literal(node),
            NodeKind::Attributes => self.visit_attributes(node),
            NodeKind::MetaArguments => self.visit_meta_arguments(node),
            NodeKind::RangeExpression => self.visit_range_expression(node),
            NodeKind::DereferenceExpression => self.visit_dereference_expression(node),
            NodeKind::TypeCheck => self.visit_type_check(node),
            NodeKind::MacroParameterList => self.visit_macro_parameter_list(node),
            NodeKind::TypeIdentifier => self.visit_type_identifier(node),
            NodeKind::MacroInvocation => self.visit_macro_invocation(node),
            NodeKind::ConstDeclaration => self.visit_const_declaration(node),
            NodeKind::LoopExpression => self.visit_loop_expression(node),
            NodeKind::Super => self.visit_super(node),
            NodeKind::StructExpression => self.visit_struct_expression(node),
            NodeKind::UseAsClause => self.visit_use_as_clause(node),
            NodeKind::ProtocolDefinition => self.visit_protocol_definition(node),
            NodeKind::Parameter => self.visit_parameter(node),
            NodeKind::FieldExpression => self.visit_field_expression(node),
            NodeKind::PtrLiteral => self.visit_ptr_literal(node),
            NodeKind::EnumDefinition => self.visit_enum_definition(node),
            NodeKind::TupleType => self.visit_tuple_type(node),
            NodeKind::ElseClause => self.visit_else_clause(node),
            NodeKind::TypeDefinition => self.visit_type_definition(node),
            NodeKind::TypeCastExpression => self.visit_type_cast_expression(node),
            NodeKind::UnaryExpression => self.visit_unary_expression(node),
            NodeKind::GenericType => self.visit_generic_type(node),
            NodeKind::Identifier => self.visit_identifier(node),
            NodeKind::IndexExpression => self.visit_index_expression(node),
            NodeKind::LetDeclaration => self.visit_let_declaration(node),
            NodeKind::StaticDeclaration => self.visit_static_declaration(node),
            NodeKind::MacroParameter => self.visit_macro_parameter(node),
            NodeKind::PrimitiveType => self.visit_primitive_type(node),
            NodeKind::ModDefinition => self.visit_mod_definition(node),
            NodeKind::NeverType => self.visit_never_type(node),
            NodeKind::WhileExpression => self.visit_while_expression(node),
            NodeKind::StringLiteral => self.visit_string_literal(node),
            NodeKind::ImplBlock => self.visit_impl_block(node),
            NodeKind::ScopedIdentifier => self.visit_scoped_identifier(node),
            NodeKind::SwitchExpression => self.visit_switch_expression(node),
            NodeKind::MacroIdentifier => self.visit_macro_identifier(node),
            NodeKind::GenericArgument => self.visit_generic_argument(node),
            NodeKind::BreakExpression => self.visit_break_expression(node),
            NodeKind::EtCeteraExpression => self.visit_et_cetera_expression(node),
            NodeKind::FunctionPointer => self.visit_function_pointer(node),
            NodeKind::EmptyStatement => self.visit_empty_statement(node),
            NodeKind::ClosureExpression => self.visit_closure_expression(node),
            NodeKind::SwitchBody => self.visit_switch_body(node),
            NodeKind::ClosureParameters => self.visit_closure_parameters(node),
            NodeKind::ReferenceExpression => self.visit_reference_expression(node),
            NodeKind::MetaItem => self.visit_meta_item(node),
            NodeKind::AttributeItem => self.visit_attribute_item(node),
            NodeKind::GenericArgumentList => self.visit_generic_argument_list(node),
            NodeKind::ReturnExpression => self.visit_return_expression(node),
            NodeKind::IfExpression => self.visit_if_expression(node),
            NodeKind::SwitchArm => self.visit_switch_arm(node),
            NodeKind::StructDefinition => self.visit_struct_definition(node),
            NodeKind::Statement => self.visit_statement(node),
            NodeKind::TupleExpression => self.visit_tuple_expression(node),
            NodeKind::EnumItem => self.visit_enum_item(node),
            NodeKind::GenericFunction => self.visit_generic_function(node),
            NodeKind::PointerOf => self.visit_pointer_of(node),
            NodeKind::ParenthesizedExpression => self.visit_parenthesized_expression(node),
            NodeKind::CharLiteral => self.visit_char_literal(node),
            NodeKind::ForExpression => self.visit_for_expression(node),
            NodeKind::IntegerLiteral => self.visit_integer_literal(node),
            NodeKind::StructField => self.visit_struct_field(node),
            NodeKind::FunctionDefinition => self.visit_function_definition(node),
            NodeKind::ParameterList => self.visit_parameter_list(node),
            _ => panic!("unimplemented: visit")
        }
    }
}
