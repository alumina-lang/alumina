//! Markdown-ish renderer.

use std::string::{split, StringBuf, starts_with, trim_prefix, trim_start, trim};
use std::fmt::{Formatter, Formattable, Result, write, writeln, Error};

enum State {
    Normal,
    MaybeItalic,
    Italic,
    BoldEnd,
    Bold,
    Code,
    LinkTitle,
    LinkUrlStart,
    LinkUrl,
}

struct InlineMarkdownState {
    kind: State,
    link_text: StringBuf,
    link_url: StringBuf,
}

impl InlineMarkdownState {
    fn default() -> InlineMarkdownState {
        InlineMarkdownState {
            kind: State::Normal,
            link_text: StringBuf::new(),
            link_url: StringBuf::new()
        }
    }

    fn reset(self: &mut InlineMarkdownState) -> ::Result<(), Error> {
        if self.kind != State::Normal {
            return Result::err(Error::new())
        } 
        self.free();
        *self = InlineMarkdownState::default();
        Result::ok(())
    }

    fn move(self: &mut InlineMarkdownState) -> InlineMarkdownState {
        InlineMarkdownState { 
            kind: self.kind, 
            link_text: self.link_text.move(),
            link_url: self.link_url.move()
        }
    }

    fn free(self: &mut InlineMarkdownState) {
        self.link_text.free();
        self.link_url.free();
    }
}

/// A very tiny subset of Markdown is supported, just inline code, bold, italic and links
/// without nesting. 
struct InlineMarkdown {
    inner: &[u8],
    state: &mut InlineMarkdownState,
}

impl InlineMarkdown {
    fn new(inner: &[u8], state: &mut InlineMarkdownState) -> InlineMarkdown {
        InlineMarkdown {
            inner: inner,
            state: state
        }
    }

    fn fmt<F: Formatter<F>>(self: &InlineMarkdown, f: &mut F) -> Result {
        for ch in self.inner {
            switch self.state.kind {
                State::Normal => switch ch {
                    '*' => self.state.kind = State::MaybeItalic,
                    '`' => {
                        write!(f, "<code>")?;
                        self.state.kind = State::Code;
                    },
                    '[' => self.state.kind = State::LinkTitle,
                    _ => f.write_char(ch)?,
                },
                State::MaybeItalic => switch ch {
                    '*' => {
                        self.state.kind = State::Bold;
                        write!(f, "<b>")?;
                    }
                    _ => {
                        self.state.kind = State::Italic;
                        write!(f, "<i>")?;
                        f.write_char(ch)?;
                    }
                },
                State::Italic => switch ch {
                    '*' => {
                        write!(f, "</i>")?;
                        self.state.kind = State::Normal;
                    },
                    _ => f.write_char(ch)?,
                },
                State::Bold => switch ch {
                    '*' => {
                        write!(f, "</b>")?;
                        self.state.kind = State::BoldEnd;
                    },
                    _ => f.write_char(ch)?,
                },
                State::BoldEnd => switch ch {
                    '*' => {
                        self.state.kind = State::Normal;
                    },
                    _ => return Result::err(Error::new())
                },
                State::Code => switch ch {
                    '`' => {
                        write!(f, "</code>")?;
                        self.state.kind = State::Normal;
                    },
                    _ => f.write_char(ch)?,
                },
                State::LinkTitle => switch ch {
                    ']' => self.state.kind = State::LinkUrlStart,
                    _ => self.state.link_text.push(ch),
                },
                State::LinkUrlStart => switch ch {
                    '(' => self.state.kind = State::LinkUrl,
                    _ => return Result::err(Error::new()),
                },
                State::LinkUrl => switch ch {
                    ')' => {
                        write!(f, 
                            "<a href=\"{}\">{}</a>", 
                            self.state.link_url.as_slice(), 
                            self.state.link_text.as_slice()
                        )?;
                        self.state.kind = State::Normal;
                    },
                    _ => self.state.link_url.push(ch),
                },
            }
        }

        Result::ok(())
    }
}


/// A mini-markdown subset parser
fn write_docstring<T: std::io::Writable<T>>(writer: &mut T, doc_comment: &[u8], tagline_only: bool) -> Result {
    use markdown::{InlineMarkdown, InlineMarkdownState};

    if doc_comment.len == 0 {
        return Result::ok(());
    }

    if !tagline_only {
        writeln!(writer, "<p>");
    }

    let in_a_code_block = false;
    let md_state = InlineMarkdownState::default();
    defer md_state.free();

    for i in doc_comment.split("\n") {
        let docline =  if i.starts_with("///") {
            i.trim_prefix("///")
        } else {
            i.trim_prefix("//!")
        };

        if docline.trim() == "```" {
            if in_a_code_block {
                writeln!(writer, "</code></pre>");
            } else {
                write!(writer, "<pre><code>");
            };
            in_a_code_block = !in_a_code_block;
        } else if !in_a_code_block {
            docline = docline.trim_start();
            if docline.len == 0 {
                if tagline_only {
                    return Result::ok(());
                } else {
                    writeln!(writer, "</p><p>");
                }
            } else if docline.starts_with("###") {
                md_state.reset()?;
                writeln!(writer, "</p>");
                writeln!(writer, "<h4>{}</h4>", InlineMarkdown::new(
                    docline.trim_prefix("###").trim(), &md_state
                ));
                md_state.reset()?;
                writeln!(writer, "<p>");
            } else if docline.starts_with("##") {
                md_state.reset()?;
                writeln!(writer, "</p>");
                writeln!(writer, "<h3>{}</h3>", InlineMarkdown::new(
                    docline.trim_prefix("##").trim(), &md_state
                ));
                md_state.reset()?;
                writeln!(writer, "<p>");
            } else if docline.starts_with("#!") {
                md_state.reset()?;
                writeln!(writer, "</p>");
                writeln!(writer, "<h1>{}</h1>", InlineMarkdown::new(
                    docline.trim_prefix("#!").trim(), &md_state
                ));
                md_state.reset()?;
                writeln!(writer, "<p>");
            } else if docline.starts_with("#") {
                md_state.reset()?;
                writeln!(writer, "</p>");
                writeln!(writer, "<h2>{}</h2>", InlineMarkdown::new(
                    docline.trim_prefix("#").trim(), &md_state
                ));
                md_state.reset()?;
                writeln!(writer, "<p>");
            } else {
                writeln!(writer, "{}", InlineMarkdown::new(
                    docline.trim(), 
                    &md_state
                ));
            }
        } else {
            writeln!(writer, "{}", docline);
        }
    }

    if in_a_code_block {
        return Result::err(Error::new());
    }

    if !tagline_only {
        writeln!(writer, "</p>");
    }
    Result::ok(())
}
