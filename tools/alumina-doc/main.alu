use std::fs::File;
use std::fmt::format;
use std::collections::{Vector, sort_by};
use std::string::{StringBuf, split, join, trim_prefix, starts_with, join_fmt, replace, trim};

use tree_sitter::{TSLanguage, Node, Parser, TSTreeCursor, TSFieldId};

use aluminac::lib::common::{NodeVisitorExt, child_by};
use aluminac::lib::arena::Arena;
use aluminac::lib::node_kinds::{NodeVisitor, FieldKind};

use alumina_doc::error::{Error, Result};
use alumina_doc::common::{Item, ItemKind, Path, ParseContext, ItemBag};
use alumina_doc::visitors::{TopLevelVisitor, CodePrinter};

extern "C" fn tree_sitter_alumina() -> &TSLanguage;

macro w($writer, $fmt, $args...) {
    std::fmt::write!($writer, $fmt, $args...).map_err(Error::from::<std::fmt::Error>)?
}

macro wln($writer, $fmt, $args...) {
    std::fmt::writeln!($writer, $fmt, $args...).map_err(Error::from::<std::fmt::Error>)?
}

struct Processor {
    parser: Parser,
    arena: Arena,
    items: ItemBag,
    parse_contexts: Vector<&mut ParseContext>
}

impl Processor {
    fn new() -> Processor {
        let parser = Parser::new(); 
        parser.set_language(tree_sitter_alumina()).unwrap();

        Processor {
            parser: parser,
            items: ItemBag::new(),
            arena: Arena::new(),
            parse_contexts: Vector::new(),
        }
    }

    fn free(self: &mut Processor) {
        use std::collections::free_all;

        self.parser.free();
        self.arena.free();
        self.items.free();
        self.parse_contexts.free_all();
    }
    
    fn move(self: &mut Processor) -> Processor {
        Processor { 
            parser: self.parser.move(), 
            items: self.items.move(), 
            arena: self.arena.move(),
        }
    }

    fn process_file(self: &mut Processor, module_path: &[u8], filename: &[u8]) -> Result<()> {
        let parse_context = self.arena.alloc(ParseContext::from_file(&self.parser, filename)?);
        self.parse_contexts.push(parse_context);
            
        let path = Path::new(module_path
            .split("::")
            .filter(|segment: &[u8]| -> bool { segment.len > 0 })
            .to_vector()
        );

        defer path.free();

        let visitor = TopLevelVisitor::new(parse_context, path.clone(), &self.items);
        defer visitor.free();

        visitor.visit(parse_context.root_node());

        self.items.add_item(Item {
            kind: ItemKind::Module,
            path: path.move(),
            node: parse_context.root_node(),
            parse_context: parse_context,
            doc_comment: visitor.file_doc_comment.move(),
        });

        Result::ok(())
    }

}

fn ensure_dir(f: &[u8]) -> Result<()> {
    let segments = f.split("/").to_vector();
    defer segments.free();
    segments.pop();

    let dirname = "/".join(&segments.iter());
    defer dirname.free();

    std::process::Command::new("/usr/bin/mkdir")
        .args(&[
            "-p",
            dirname.as_slice()
        ])
        .spawn()
        .map_err(Error::from_io)?
        .wait()
        .map_err(Error::from_io)?;

    Result::ok(())
}

fn link_for_path(prefix: &[u8], path: &Path) -> StringBuf {
    if path.segments.empty() {
        format!("{}/index.html", prefix).unwrap()
    } else {
        format!("{}/{}.html", prefix, "/".join_fmt(path.segments.iter())).unwrap()
    }
}

fn write_breadcrumbs<T: std::io::Writable<T>>(writer: &mut T, item: &Item, with_kind: bool) -> Result<()> {
    if item.path.segments.empty() {
        wln!(writer, "<h1>{}</h1>", item.kind);
        return Result::ok(());
    } 
    
    if with_kind {
        w!(writer, "<h1>{} ", item.kind);
    } else {
        w!(writer, "<h1>");
    }

    for (idx, segment) in item.path.segments.iter().enumerate() {
        let partial_path = Path::new(Vector::from_slice(item.path.segments.as_slice()[..idx + 1]));
        let link = link_for_path("", &partial_path);

        if idx == 0 {
            w!(writer, "<a class=\"breadcrumbs\" href=\"{}\">{}</a>", link.as_slice(), segment);
        } else {
            w!(writer, "::<a class=\"breadcrumbs\" href=\"{}\">{}</a>", link.as_slice(), segment);
        }

        partial_path.free();
        link.free();
    }
    wln!(writer, "</h1>");
    Result::ok(())
}

fn write_docstring<T: std::io::Writable<T>>(writer: &mut T, item: &Item, tagline_only: bool) -> Result<()> {
    if item.doc_comment.len() == 0 {
        return Result::ok(());
    }

    if !tagline_only {
        wln!(writer, "<p>");
    }

    let in_a_code_block = false;

    for i in item.doc_comment.as_slice().split("\n") {
        let without_prefix =  if i.starts_with("///") {
            i.trim_prefix("///").trim()
        } else {
            i.trim_prefix("//!").trim()
        };

        if without_prefix.len == 0 {
            if tagline_only {
                return Result::ok(());
            } else {
                wln!(writer, "</p><p>");
            }
        } else if without_prefix == "```" {
            if in_a_code_block {
                wln!(writer, "</code></pre>");
                in_a_code_block = false;
            } else {
                w!(writer, "<pre><code>");
                in_a_code_block = true;
            }
        } else {
            wln!(writer, "{}", without_prefix);
        }
    }

    if in_a_code_block {
        return Result::err(Error::from_custom("unclosed code block"));
    }

    if !tagline_only {
        wln!(writer, "</p>");
    }
    Result::ok(())
}

fn write_source<T: std::io::Writable<T>>(writer: &mut T, item: &Item) -> Result<()> {
    let source: StringBuf = StringBuf::from_slice(item.node.text(item.parse_context.source()));
    defer source.free();

    switch item.kind {
        ItemKind::Enum, ItemKind::Struct, ItemKind::Union, ItemKind::TypeDef, ItemKind::Const, ItemKind::Static, ItemKind::Function, ItemKind::Macro => {},
        // todo: signature only
        ItemKind::Module, ItemKind::Protocol, ItemKind::Mixin => return Result::ok(()),
        _ => unreachable!()
    };

    
    w!(writer, "<pre><code>");
    
    let printer = CodePrinter::new(item.parse_context, writer);
    printer.visit(item.node);

    wln!(writer, "</code></pre>");

    Result::ok(())
}

fn write_page_inner(nav_item: &Item, top_level: &Item, nav_items: &Vector<&Item>, main_items: &Vector<&Item>) -> Result<()> {
    let filename = link_for_path("./build/docs", &top_level.path);
    defer filename.free();

    ensure_dir(filename.as_slice())?;

    let file = std::fs::File::create(filename.as_slice()).map_err(Error::from_io)?;
    defer file.close();

    let writer = std::io::BufferedWriter::new(&file, 1024);
    defer {
        writer.flush();
        writer.free();
    };

    wln!(&writer, "<html>");
    wln!(&writer, "<head>");

    if top_level.path.segments.len() == 0 {
        wln!(&writer, "<title>Alumina Docs</title>");
    } else {
        wln!(&writer, "<title>{} - Alumina Docs</title>", top_level.path);
    }

    wln!(&writer, "<link rel=\"stylesheet\" href=\"/static/styles.css\">");
    wln!(&writer, "<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">");
    wln!(&writer, "<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>");
    wln!(&writer, "<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\" />");
    wln!(&writer, "<link href=\"https://fonts.googleapis.com/css2?family=Fira+Sans:wght@400;500&family=Source+Code+Pro:wght@400;600&family=Source+Serif+4:opsz,wght@8..60,400;8..60,700&display=swap\" rel=\"stylesheet\">");
    wln!(&writer, "</head>");
    wln!(&writer, "<body>");
    
    // Left sidebar

    wln!(&writer, "<nav>");
    wln!(&writer, "<a href=\"/\"><img class=\"logo\" src=\"/static/logo.svg\"></a>");
    let top_level_link = link_for_path("", &top_level.path);
    defer top_level_link.free();

    if nav_item.path.last().is_some {
        write_breadcrumbs(&writer, nav_item, false)?;
    }

    for grp in nav_items.iter().group_by(|i: &Item| -> ItemKind { i.kind }) {
        wln!(&writer, "<h2>{}s</h2>", grp.key);
        wln!(&writer, "<ul>");
        
        for item in grp {
            let link = link_for_path("", &item.path);
            wln!(&writer, "<li>");

            if item.kind.has_own_page() {
                wln!(&writer, "<a href=\"{}\">{}</a>", link, item.path.last().unwrap());
            } else {
                wln!(&writer, "<a href=\"{}#item.{}\">{}</a>", top_level_link, item.path.last().unwrap(), item.path.last().unwrap());
            }

            wln!(&writer, "</li>");
            link.free();
        }
        wln!(&writer, "</ul>");
    }
    wln!(&writer, "</nav>");

    // Main section

    wln!(&writer, "<main>");

    write_breadcrumbs(&writer, top_level, true)?;
    write_source(&writer, top_level)?;
    write_docstring(&writer, top_level, false)?;    

    if top_level.kind.has_own_page() {
        for grp in main_items.iter().group_by(|i: &Item| -> ItemKind { i.kind }) {
            wln!(&writer, "<h2 id=\"{}\">{}s</h2>", grp.key, grp.key);
            
            if grp.key.has_own_page() {
                wln!(&writer, "<div class=\"item-short-table\">");
                for item in grp {
                    let name = item.path.last().unwrap();
                    let link = link_for_path("", &item.path);
                    
                    wln!(&writer, "<div class=\"row\" id=\"item.{}\">", name);
                    wln!(&writer, "<div class=\"cell-name\"><a href=\"{}\">{}</a></div>", link, name);
                    w!(&writer, "<div class=\"cell-doc\">");
                    write_docstring(&writer, item, true);
                    wln!(&writer, "</div>");
                    wln!(&writer, "</div>");
    
                    link.free();
                }
                wln!(&writer, "</div>");
                
            } else {
                wln!(&writer, "<ul>");
                for item in grp {
                    let name = item.path.last().unwrap();
                    
                    wln!(&writer, "<li id=\"item.{}\">", name);
                    
                    
                    wln!(&writer, "<h4 class=\"signature\">");
                    let printer = CodePrinter::new(item.parse_context, &writer);
                    printer.visit(item.node);
                    wln!(&writer, "</h4>");
                    wln!(&writer, "<div class=\"item-doc\">");
                    write_docstring(&writer, item, false);
                    wln!(&writer, "</div>");
                    wln!(&writer, "</li>");
                }
    
                wln!(&writer, "</ul>");
            }
        }
    }

    wln!(&writer, "</main>");
    wln!(&writer, "</body>");
    wln!(&writer, "</html>");

    Result::ok(())
}


fn write_page(items: &ItemBag, top_level: &Item) -> Result<()> {
    let main_items = items
        .filtered(|&top_level, v: &Item| -> bool { 
            v.path.len() == top_level.path.len() + 1 && v.path.starts_with(&top_level.path)
        });
    defer main_items.free();

    let (nav_item, nav_items) = if !top_level.kind.show_siblings() {
        (top_level, &main_items)
    } else {
        let nav_items = items
            .filtered(|&top_level, v: &Item| -> bool { 
                v.path.len() == top_level.path.len() && 
                    v.path.segments.as_slice()[..v.path.len() - 1] == 
                        top_level.path.segments.as_slice()[..v.path.len() - 1]
            });
        
        defer nav_items.free();
        
        let parent_path = top_level.path.clone();
        defer parent_path.free();
        parent_path.pop();

        let parent = items.get(&parent_path).unwrap();
        (parent, &nav_items)
    };

    write_page_inner(nav_item, top_level, nav_items, &main_items)  
} 

fn write_html(items: &ItemBag) -> Result<()> { 
    use std::string::join_fmt;
    use std::fmt::format;

    for top_level in items.all().filter(|v: &Item| -> bool { v.kind.has_own_page() }) {
        write_page(items, top_level)?;
    }

    Result::ok(())
}

fn main_inner(args: &[&[u8]]) -> Result<()> {
    let processor = Processor::new();
    defer processor.free();

    let inputs = args
        .iter()
        .skip(1)
        .filter_map(|s: &[u8]| -> Option<(&[u8], &[u8])> {
            use std::option::try;

            let segments = s.split("=");
            let module_path = segments.next()?
            let filename = segments.next()?;

            Option::some((module_path, filename))
        });

    for (module_path, filename) in inputs {
        processor.process_file(module_path, filename)?;
    }

    processor.items.sort();

    write_html(&processor.items)?;
        
    Result::ok(())
}

fn main(args: &[&[u8]]) -> i32 {
    let res = main_inner(args);
    if !res.is_ok {
        println!("{}", res.unwrap_err());
        1
    } else {
        0
    }
}


