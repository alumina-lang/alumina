//! This tool generates strongly-typed Tree-Sitter node types for the self-hosting compiler 
//! (to avoid matching by string) and visitor protocols.

use std::collections::{Vector, HashMap, HashSet};
use tree_sitter::{TSLanguage, TSSymbolType, TSSymbol, Parser};
use std::fmt::Formatter;

extern "C" fn tree_sitter_alumina() -> &TSLanguage;

struct SanitizedIdentifier {
    inner: &[u8],
    pascal_case: bool
}

impl SanitizedIdentifier {
    fn default(identifier: &[u8]) -> SanitizedIdentifier {
        SanitizedIdentifier {
            inner: identifier,
            pascal_case: false
        }
    }

    fn pascal(identifier: &[u8]) -> SanitizedIdentifier {
        SanitizedIdentifier {
            inner: identifier,
            pascal_case: true
        }
    }    

    fn fmt<F: Formatter<F>>(self: &SanitizedIdentifier, f: &mut F) -> Result<(), std::fmt::Error> {
        let first_char = true;

        for ch in self.inner {
            if (ch >= 'a' && ch <= 'z') || 
                (ch >= 'A' && ch <= 'Z') || 
                (ch >= '0' && ch <= '9') || ch == '_' {
                    // Convert to PascalCase
                    if self.pascal_case {
                        if ch >= 'a' && ch <= 'z' {
                            if first_char {
                                ch += 'A' - 'a';
                                first_char = false;
                            } 
                        } else {
                            first_char = true;
                        }
                        if ch != '_' {
                            f.write_char(ch)?;
                        }
                    } else {
                        f.write_char(ch)?;
                    }
                    continue;
            } 
            let replacement = switch ch {
                '~' => "TILDE",
                '`' => "BQUOTE",
                '!' => "BANG",
                '@' => "AT",
                '#' => "POUND",
                '$' => "DOLLAR",
                '%' => "PERCENT",
                '^' => "CARET",
                '&' => "AMP",
                '*' => "STAR",
                '(' => "LPAREN",
                ')' => "RPAREN",
                '-' => "DASH",
                '+' => "PLUS",
                '=' => "EQ",
                '{' => "LBRACE",
                '}' => "RBRACE",
                '[' => "LBRACK",
                ']' => "RBRACK",
                '\\' => "BSLASH",
                '|' => "PIPE",
                ':' => "COLON",
                ';' => "SEMI",
                '\"' => "DQUOTE",
                '\'' => "SQUOTE",
                '<' => "LT",
                '>' => "GT",
                ',' => "COMMA",
                '.' => "DOT",
                '?' => "QMARK",
                '/' => "SLASH",
                '\n' => "LF",
                '\r' => "CR",
                '\t' => "TAB",
                _ => continue
            };

            f.write_str(replacement)?;
        }

        Result::ok(())
    }
}

fn main(args: &[&[u8]]) {
    let language = tree_sitter_alumina();

    let unique_symbol_names : HashSet<&[u8]> = HashSet::new();

    let max_symbol_id = 0 as TSSymbol;
    for symbol in language.symbols() {
        if language.symbol_type(symbol) != TSSymbolType::Regular {
            continue;
        }
        let name = language.symbol_name(symbol);
        unique_symbol_names.insert(name);
        max_symbol_id = std::math::max(max_symbol_id, symbol);
    }
    println!("// DO NOT EDIT THIS FILE. IT IS AUTOMATICALLY GENERATED.");
    println!("// Make changes in tools/tree-sitter-codegen/main.alu");
    println!("");
    println!("use std::collections::HashMap;");
    println!("use tree_sitter::{{TSSymbol, Node}};");
    println!("");
    println!("enum NodeKind {{")
    println!("    Invalid,");
    for name in unique_symbol_names {
        println!("    {},", SanitizedIdentifier::pascal(name));
    }
    println!("}}")
    println!("")
    println!("enum FieldKind {{")
    for field in language.fields() {
        let name = language.field_name(field);
        println!("    {} = {}u16,", SanitizedIdentifier::pascal(name), field);
    }
    println!("}}");
    println!("")
    println!("static NODE_KINDS: [NodeKind; {}] = [", language.symbols().len() + 1)
    for symbol in (0 as TSSymbol)..(max_symbol_id + 1) {
        if symbol == 0 || language.symbol_type(symbol) != TSSymbolType::Regular {
            println!("    NodeKind::Invalid,");
            continue;
        } 

        let name = language.symbol_name(symbol);
        println!("    NodeKind::{},", SanitizedIdentifier::pascal(name));
    }
    println!("];");
    println!("protocol NodeVisitor<Self, ReturnType> {{")
    for name in unique_symbol_names {
        println!("    fn visit_{}(self: &mut Self, node: Node) -> ReturnType {{", SanitizedIdentifier::default(name));
        println!("        panic!(\"unimplemented: visit_{}\");", SanitizedIdentifier::default(name));
        println!("    }}");
    }

    println!("    fn visit_unknown(self: &mut Self, node: Node) -> ReturnType {{");
    println!("        panic!(\"unimplemented: visit unknown\");");
    println!("    }}");

    println!("    fn visit(self: &mut Self, node: Node) -> ReturnType {{");
    println!("        switch NODE_KINDS[node.symbol() as usize] {{");
    for name in unique_symbol_names {
        println!("            NodeKind::{} => self.visit_{}(node),",
            SanitizedIdentifier::pascal(name),
            SanitizedIdentifier::default(name)    
        );
    }
    println!("            _ => self.visit_unknown(node),");
    println!("        }}");
    println!("    }}");
    println!("}}")
}


